

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://gitee.com/ylea/imagehost/raw/master/img/logo1.png">
  <link rel="icon" type="image/png" href="https://gitee.com/ylea/imagehost/raw/master/img/logo1.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>手撕JS代码1 - Ylea</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/atelier-seaside-light.min.css" />
    
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/custom/custom_css.css">
<link rel="stylesheet" href="//at.alicdn.com/t/font_2138234_h0gvk1u4g3q.css">



  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.0.2"></head>


<script type="text/javascript" src="/js/FunnyTitle.js"></script>

<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Ylea</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('https://gitee.com/ylea/imagehost/raw/master/banner_img/54.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-12-13 22:16" pubdate>
        2020年12月13日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      10.5k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      145
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">手撕JS代码1</h1>
            
            <div class="markdown-body" id="post-body">
              <h1 id="1-节流和防抖"><a class="markdownIt-Anchor" href="#1-节流和防抖"></a> 1. 节流和防抖</h1>
<p>  对于一些频繁的操作，如对窗口的 <code>resize</code>、<code>scroll</code>、输入框内容改动响应时，如果相应处理函数没有频率限制的话，会加重浏览器的负担，导致用户体验差，而防抖(debounce) 和节流(throttle) 可以有效减少处理函数的调用频率，同时不影响实际效果。</p>
<h2 id="21-防抖"><a class="markdownIt-Anchor" href="#21-防抖"></a> 2.1 防抖</h2>
<p>  触发高频事件后 <code>n</code> 秒内函数只会执行一次，如果 <code>n</code> 秒内高频事件再次被触发，则重新计算时间。</p>
<p>  一个连续操作中的处理，只触发一次，从而实现防抖动。</p>
<blockquote>
<p>思路：使用一个定时器延迟调用处理函数，每次触发事件后都取消之前延迟调用的方法</p>
</blockquote>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, wait</span>) </span>&#123;
    <span class="hljs-keyword">let</span> timeout = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-built_in">clearTimeout</span>(timeout); <span class="hljs-comment">// 每当用户输入的时候把前一个 setTimeout clear 掉</span>
        <span class="hljs-comment">// 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数</span>
        timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;
            <span class="hljs-comment">// this 确保当前指向的对象是调用函数的对象，如 input 对象</span>
            fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);
        &#125;, wait);
    &#125;;
&#125;</code></pre>
<h3 id="1-立即执行的防抖"><a class="markdownIt-Anchor" href="#1-立即执行的防抖"></a> 1. 立即执行的防抖</h3>
<p>  <code>underscore</code> 中的防抖还可以实现立即执行的功能：当 <code>immediate</code> 为 <code>true</code> 时，立即执行函数， <code>wait</code> 秒后才能重新触发（即当 <code>timer</code> 为 <code>null</code> 时）。</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">immedDebounce</span>(<span class="hljs-params">fn, wait, immediate</span>) </span>&#123;
    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-keyword">if</span> (timer) &#123;
            <span class="hljs-built_in">clearTimeout</span>(timer);
        &#125;

        <span class="hljs-keyword">if</span> (immediate) &#123;
            <span class="hljs-keyword">let</span> callNow = !timer;

            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;
                timer = <span class="hljs-literal">null</span>;
            &#125;, wait);

            <span class="hljs-keyword">if</span> (callNow) &#123;
                fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);
            &#125;
        &#125; <span class="hljs-keyword">else</span> &#123;
            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;
                fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);
            &#125;, wait);
        &#125;
    &#125;
&#125;</code></pre>
<h3 id="2-带返回值的-debounce"><a class="markdownIt-Anchor" href="#2-带返回值的-debounce"></a> 2 带返回值的 debounce</h3>
<p>  对于立即执行的 <code>debounce</code>，当 <code>immediate</code> 为 <code>true</code> 时，当函数立即执行时，可以直接返回函数结果，而当 <code>immediate</code> 为 <code>false</code> 时，因为设置了 <code>timeout</code> ，因此获取不到返回值，函数返回 <code>undefined</code>。</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">retDebounce</span>(<span class="hljs-params">fn, wait, immediate</span>) </span>&#123;
    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-keyword">let</span> result;
        <span class="hljs-keyword">if</span> (timer) &#123;
            <span class="hljs-built_in">clearTimeout</span>(timer);
        &#125;

        <span class="hljs-keyword">if</span> (immediate) &#123;
            <span class="hljs-keyword">let</span> callNow = !timer;

            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;
                timer = <span class="hljs-literal">null</span>;
            &#125;, wait);

            <span class="hljs-keyword">if</span> (callNow) &#123;
                result = fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);
            &#125;
        &#125; <span class="hljs-keyword">else</span> &#123;
            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;
                fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);
            &#125;, wait);
        &#125;

        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;</code></pre>
<h3 id="3-可取消的-debounce"><a class="markdownIt-Anchor" href="#3-可取消的-debounce"></a> 3. 可取消的 debounce</h3>
<p>  若防抖时间较长，而 <code>immediate</code> 为 <code>true</code> 时（立即执行一次，然后需要再等待 <code>wait</code> 后才能触发），又想早点再次触发，可以选择取消防抖状态。</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cancelDebounce</span>(<span class="hljs-params">fn, wait, immediate</span>) </span>&#123;
    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">const</span> debounced = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-keyword">let</span> result;

        <span class="hljs-keyword">if</span> (timer) &#123;
            <span class="hljs-built_in">clearTimeout</span>(timer);
        &#125;

        <span class="hljs-keyword">if</span> (immediate) &#123;
            <span class="hljs-keyword">let</span> callNow = !timer;

            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;
                timer = <span class="hljs-literal">null</span>;
            &#125;, wait);

            <span class="hljs-keyword">if</span> (callNow) &#123;
                result = fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);
            &#125;
        &#125; <span class="hljs-keyword">else</span> &#123;
            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;
                fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);
            &#125;, wait);
        &#125;

        <span class="hljs-keyword">return</span> result;
    &#125;;

    debounced.cancel = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-built_in">clearTimeout</span>(timer);
        timer = <span class="hljs-literal">null</span>;
    &#125;;

    <span class="hljs-keyword">return</span> debounced;
&#125;</code></pre>
<h3 id="4-防抖实例"><a class="markdownIt-Anchor" href="#4-防抖实例"></a> 4. 防抖实例</h3>
<p>  使用实例：两个按钮，当点击了 <code>say hello</code> 按钮后，需要等待两秒后再次点击按钮才能输出 <code>hello</code>，若不想等待，点击 <code>cancel hello</code> 后再次点击 <code>say hello</code> 后会立即输出 <code>hello</code>。</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hi</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>);
&#125;

<span class="hljs-keyword">let</span> inp = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;button&#x27;</span>);
inp.innerHTML = <span class="hljs-string">&#x27;say hello&#x27;</span>;

<span class="hljs-keyword">let</span> inp1 = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;button&#x27;</span>);
inp1.innerHTML = <span class="hljs-string">&#x27;cancel hello&#x27;</span>;

<span class="hljs-built_in">document</span>.body.appendChild(inp);
<span class="hljs-built_in">document</span>.body.appendChild(inp1);

<span class="hljs-keyword">let</span> de = cancelDebounce(hi, <span class="hljs-number">2000</span>, <span class="hljs-literal">true</span>);
inp.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, de);
inp1.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, de.cancel);</code></pre>
<h2 id="22-节流"><a class="markdownIt-Anchor" href="#22-节流"></a> 2.2 节流</h2>
<p>  高频事件触发，但在 <code>n</code> 秒内只会执行一次，所以节流会稀释函数的执行频率。</p>
<p>  一个连续操作中的处理，按照阀值时间间隔进行触发，从而实现节流。</p>
<p>  在一定的时间间隔内，某个事件只会执行一次</p>
<blockquote>
<p>思路：每次触发事件时都判断当前是否有在等待执行的回调函数</p>
</blockquote>
<h3 id="1-节流-使用定时器"><a class="markdownIt-Anchor" href="#1-节流-使用定时器"></a> 1. 节流 - 使用定时器</h3>
<p>  使用了定时器，当<strong>事件触发时不会立即执行</strong>，等待时间过后才会开始执行，然后清空计数器。</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle1</span>(<span class="hljs-params">fn, wait</span>) </span>&#123;
    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-keyword">if</span> (!timer) &#123;
            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;
                timer = <span class="hljs-literal">null</span>;
                fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);
            &#125;, wait);
        &#125;
    &#125;
&#125;</code></pre>
<h3 id="2-节流-使用时间戳"><a class="markdownIt-Anchor" href="#2-节流-使用时间戳"></a> 2. 节流 - 使用时间戳</h3>
<p>  根据时间戳来判断两次响应的间隔是否大于设置的间隔，大于才能执行下一次响应函数。这种方法<strong>响应函数 <code>fn</code> 会立即执行。</strong></p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, time</span>) </span>&#123;
    <span class="hljs-keyword">let</span> activeTime = <span class="hljs-number">0</span>;
    reutrn () =&gt; &#123;
        <span class="hljs-keyword">const</span> current = <span class="hljs-built_in">Date</span>.now(); <span class="hljs-comment">// +new Date()</span>
        <span class="hljs-keyword">if</span> (current - activeTime &gt; time) &#123;
            fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);
            activeTime = current;
        &#125;
    &#125;;
&#125;</code></pre>
<p>  其实使用定时器也可以达到<strong>立即执行</strong>的效果：</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, wait</span>) </span>&#123;
    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-keyword">if</span> (!timer) &#123;
            <span class="hljs-comment">// 将执行函数放外面 就有立即执行的效果了</span>
            fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);
            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;
                timer = <span class="hljs-literal">null</span>;
            &#125;, wait);
        &#125;
    &#125;;
&#125;</code></pre>
<h3 id="3-节流-综合写法-立即执行效果-尾执行"><a class="markdownIt-Anchor" href="#3-节流-综合写法-立即执行效果-尾执行"></a> 3. 节流 - 综合写法 ： 立即执行效果 + 尾执行</h3>
<p>  比较上面两个节流方法：</p>
<ol>
<li>使用<strong>时间戳</strong>的节流方法触发事件时会<strong>立即执行</strong>，而使用<strong>定时器</strong>的方法会在触发事件 <strong><code>n</code> 秒后再执行</strong>；</li>
<li>使用<strong>时间戳</strong>的方法<strong>停止触发事件后不会再执行</strong>，使用<strong>定时器</strong>的方法会在<strong>停止触发事件的 <code>n</code> 秒后再执行一次。</strong></li>
</ol>
<p>  可以综合时间戳和定时器的效果，当触发事件时会立即执行，且在停止事件触发的 <code>n</code> 秒后还会再执行一次。</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle2</span>(<span class="hljs-params">fn, wait</span>) </span>&#123;
    <span class="hljs-keyword">let</span> previous = <span class="hljs-number">0</span>, timer = <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">let</span> later = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
        timer = <span class="hljs-literal">null</span>;
        previous = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
        fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);
    &#125;;

    <span class="hljs-keyword">let</span> throttled = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-keyword">let</span> now = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
        <span class="hljs-comment">// 剩余等待时间</span>
        <span class="hljs-keyword">let</span> remain = wait - (now - previous);
        <span class="hljs-comment">// 若没有剩余时间或因修改了系统时间导致剩余时间大于等待时间</span>
        <span class="hljs-comment">// 若非主动修改系统时间，此时会是第一次触发执行</span>
        <span class="hljs-keyword">if</span> (remain &lt;= <span class="hljs-number">0</span> || remain &gt; wait) &#123;
            <span class="hljs-comment">// 若前面有在等待时间内设置的 timer，需要将其清除，否则可能造成连续调用的情况</span>
            <span class="hljs-keyword">if</span> (timer) &#123;
                <span class="hljs-built_in">clearTimeout</span>(timer);
                timer = <span class="hljs-literal">null</span>;
            &#125;

            previous = now;
            fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!timer) &#123;
            <span class="hljs-comment">// 否则若处于等待时间内触发且前面的定时器被清除，那么会延迟执行，延迟时间即为剩余等待时间</span>
            timer = <span class="hljs-built_in">setTimeout</span>(later, remain);
        &#125;
    &#125;;

    <span class="hljs-keyword">return</span> throttled;
&#125;</code></pre>
<h3 id="4-根据参数调整节流效果"><a class="markdownIt-Anchor" href="#4-根据参数调整节流效果"></a> 4. 根据参数调整节流效果</h3>
<p>  有时候我们希望节流效果为 “有头无尾”， 有时候希望是 “有尾无头”。</p>
<p>  这样的话我们可以通过设置参数 <code>options</code> 来调整，约定：</p>
<ul>
<li><code>leading: false</code> ：表示禁用第一次执行</li>
<li><code>trailing: false</code> ：表示禁用停止触发的回调</li>
</ul>
<pre><code class="hljs js"><span class="hljs-comment">// 当设置了 leading 为 false 时，表示禁用第一次执行，当 trailing 为 false，表示禁用停止后的回调</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle3</span>(<span class="hljs-params">fn, wait, options=&#123;&#125;</span>) </span>&#123;
    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>, previous = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">let</span> later = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
        timer = <span class="hljs-literal">null</span>;
        <span class="hljs-comment">// leading 为 false 时，将 previous 设置为 0，那么每次触发时，remain 计算结果都会是 wait</span>
        previous = options.leading === <span class="hljs-literal">false</span> ? <span class="hljs-number">0</span> : <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime();
        fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);
    &#125;;

    <span class="hljs-keyword">let</span> throttled = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-keyword">let</span> now = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
        <span class="hljs-comment">// 当 leading 为 false 时，每次执行 fn，previous 都会被设置为 0，再加上初始时刻 previous = 0</span>
        <span class="hljs-comment">// 就达到了取消第一次立即执行的效果，也就是会跳过接下来的第一个 if 判断，直接进行 timer 设置</span>
        <span class="hljs-keyword">if</span> (options.leading === <span class="hljs-literal">false</span> &amp;&amp; !previous) &#123;
            previous = now;
        &#125;
        <span class="hljs-keyword">let</span> remain = wait - (now - previous);

        <span class="hljs-comment">// 否则，若设置 trailing 为 false ，第一次 remain 会小于 0，从而使 fn 立即执行</span>
        <span class="hljs-comment">// 之后，在间隔时间之内(remain &gt; 0)，由于 trailing 为 false，因此下面延迟设置的判断进不去</span>
        <span class="hljs-comment">// 从而达到每次只有当 remain 为 0 时，才会执行 fn，且在停止触发后，不会再延迟执行了</span>
        <span class="hljs-keyword">if</span> (remain &lt;= <span class="hljs-number">0</span> || remain &gt; wait) &#123;
            <span class="hljs-keyword">if</span> (timer) &#123;
                <span class="hljs-built_in">clearTimeout</span>(timer);
                timer = <span class="hljs-literal">null</span>;
            &#125;
            previous = now;
            fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!timer &amp;&amp; options.trailing !== <span class="hljs-literal">false</span>) &#123;
            timer = <span class="hljs-built_in">setTimeout</span>(later, remain);
        &#125;
    &#125;;

    <span class="hljs-keyword">return</span> throttled;
&#125;</code></pre>
<h4 id="设置取消功能"><a class="markdownIt-Anchor" href="#设置取消功能"></a> 设置取消功能</h4>
<p>  与防抖中相似，当节流中需要等待很久才能进行下一次响应时，若想提前响应，可以使用 <code>cancel</code> 来取消：</p>
<pre><code class="hljs js">throttled.cancel = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">clearTimeout</span>(timeout);
    previous = <span class="hljs-number">0</span>;
    timer = <span class="hljs-literal">null</span>;
&#125;;</code></pre>
<h4 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h4>
<p>  在上面的带有 <code>options</code> 参数的实现中，<code>leading：false</code> 和 <code>trailing: false</code> 不能同时设置。</p>
<p>  若同时设置的话，当将鼠标移出时，因为 <code>trailing</code> 设置为 <code>false</code> ，停止触发的时候不会设置定时器，所以只要再过了设置的时间，再移入的话，就会立即执行了，这就违反了 <code>leading: false</code> 的规则。因此，这个 <code>throttle</code> 只有三种使用方法：</p>
<pre><code class="hljs js"><span class="hljs-comment">// 1. 开始立即执行且停止触发后过一段时间会有一个回调</span>
continer.onmousemove = throttle(getUserAction, <span class="hljs-number">1000</span>);

<span class="hljs-comment">// 2. 取消开始时的立即执行</span>
continer.onmousemove = throttle(getUserAction, <span class="hljs-number">1000</span>, &#123;
    leading: <span class="hljs-literal">false</span>
&#125;);

<span class="hljs-comment">// 3. 取消停止时设置的回调</span>
continer.onmousemove = throttle(getUserAction, <span class="hljs-number">1000</span>, &#123;
    trailing: <span class="hljs-literal">false</span>
&#125;);</code></pre>
<h3 id="5-实例"><a class="markdownIt-Anchor" href="#5-实例"></a> 5. 实例</h3>
<p>  示例：当窗口进行缩放时，一秒内只会执行一次打印窗口大小的函数。</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params">e</span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(e.target.innerWidth, e.target.innerHeight);
&#125;

<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;resize&#x27;</span>, throttle(sayHi));</code></pre>
<h2 id="23-节流和防抖场景"><a class="markdownIt-Anchor" href="#23-节流和防抖场景"></a> 2.3 节流和防抖场景</h2>
<ul>
<li>a、<code>scroll</code>事件：当页面发生滚动时，<code>scroll</code>事件会被频繁的触发，<code>1s</code>触发可高达上百次。在<code>scroll</code>事件中，如果有复杂的操作（特别是影响布局的操作），将会大大影响性能，甚至导致浏览器崩溃。所以，对其进行防抖、限频很重要。</li>
<li>b、<code>click</code>事件：用户进行<code>click</code>事件时，有可能连续触发点击（用户本意并非双击）。该操作有可能是不小心多次连续点击，也可能是页面状况不好的情况下，期待尽快得到反馈的有意行为；但这样的操作，反而会加剧性能问题，因此也有必要考虑防抖、限频。</li>
<li>c、<code>input</code>事件：如<code>sug</code>等需要通过<code>ajax</code>及时获得数据的情况，需要进行限频，防止频繁的请求发生，减少服务器压力的同时，提高页面响应性能。</li>
<li>d、<code>touchmove</code>事件：同<code>scroll</code>事件类似。</li>
</ul>
<h1 id="2-深拷贝和浅拷贝"><a class="markdownIt-Anchor" href="#2-深拷贝和浅拷贝"></a> 2. 深拷贝和浅拷贝</h1>
<p>  浅拷贝和深拷贝都只针对于引用数据类型</p>
<p>  浅拷贝和深拷贝的区别用一张图来说就是：</p>
<img src="https://gitee.com/ylea/imagehost/raw/master/img/13263206-c651dc07788bf561.png" srcset="/img/loading.gif" style="zoom: 33%;" />
<p>  图中的每个节点相当于对象的层次，浅拷贝只会复制对象的第一层元素，若其有嵌套的对象，那么这些嵌套对象的引用都是相同的，而深拷贝的复制会包括这些嵌套的对象，因此复制出的对象会是完全不同的两个对象。</p>
<h2 id="21-浅拷贝"><a class="markdownIt-Anchor" href="#21-浅拷贝"></a> 2.1 浅拷贝</h2>
<h3 id="1-objectassign"><a class="markdownIt-Anchor" href="#1-objectassign"></a> 1. Object.assign</h3>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> obj2 = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, obj);</code></pre>
<h3 id="2-展开运算符"><a class="markdownIt-Anchor" href="#2-展开运算符"></a> 2. 展开运算符</h3>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> obj2 = &#123;...obj&#125;;</code></pre>
<h3 id="3-objectcreate"><a class="markdownIt-Anchor" href="#3-objectcreate"></a> 3. Object.create</h3>
<p>MDN 文档](<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create</a>)</p>
<blockquote>
<p><strong><code>Object.create()</code></strong> 方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。</p>
</blockquote>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> obj2 = <span class="hljs-built_in">Object</span>.create(obj);</code></pre>
<h3 id="4-循环"><a class="markdownIt-Anchor" href="#4-循环"></a> 4. 循环</h3>
<p>  在下面的循环中，因为 <code>Object.entries</code> 或 <code>Object.keys</code> 不会遍历到原型链上的属性，因此不需要使用 <code>obj.hasOwnProperty</code> 来验证是否是自身的属性，若是 <code>for in</code> 则需要。</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shallowCopy</span>(<span class="hljs-params">obj</span>) </span>&#123;
    <span class="hljs-keyword">if</span> (!obj || <span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span>) &#123;
        <span class="hljs-keyword">return</span> obj;
    &#125;
    <span class="hljs-keyword">const</span> obj2 = <span class="hljs-built_in">Array</span>.isArray(obj) ? [] : &#123;&#125;;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(obj)) &#123;
        obj2[key] = value;
    &#125;

    <span class="hljs-keyword">return</span> obj2;
&#125;
<span class="hljs-keyword">const</span> obj2 = shallowCopy(obj);</code></pre>
<h3 id="5-slice-concat-arrayfrom-方法-arrayobject"><a class="markdownIt-Anchor" href="#5-slice-concat-arrayfrom-方法-arrayobject"></a> 5. slice() 、 concat()、Array.from() 方法 （ArrayObject）</h3>
<p>  这几个方法都不会改变原数组，它们返回一个新数组：</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> arr2 = arr.slice();

<span class="hljs-keyword">const</span> arr3 = arr.concat([]); <span class="hljs-comment">// [].concat(arr);</span></code></pre>
<h2 id="22-深拷贝"><a class="markdownIt-Anchor" href="#22-深拷贝"></a> 2.2 深拷贝</h2>
<p>  在进行深拷贝时需要考虑<strong>循环引用</strong>的问题。</p>
<p>  如果遇到复杂对象，我们可以使用工具库，比如 lodash 的 <a target="_blank" rel="noopener" href="https://www.lodashjs.com/docs/lodash.cloneDeep/">cloneDeep</a> 方法</p>
<h3 id="1-jsonparse-和-jsonstringfy"><a class="markdownIt-Anchor" href="#1-jsonparse-和-jsonstringfy"></a> 1. JSON.parse 和 JSON.stringfy</h3>
<p>  <strong>该方法不能解决循环引用问题</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> obj2 = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(obj));</code></pre>
<p>  <strong>缺陷</strong>：它会抛弃对象的<code>constructor</code>，深拷贝之后，不管这个对象原来的构造函数是什么，在深拷贝之后都会变成<code>Object</code>；会忽略<code>undefined、任意的函数、symbol 值</code>；</p>
<p>  这种方法能正确处理的对象只有 <code>Number</code>, <code>String</code>, <code>Boolean</code>, <code>Array</code>, 扁平对象，也就是说，只有可以转成 JSON 格式的对象才可以这样用，像<code>function</code>没办法转成 JSON；</p>
<p>  因此特殊的对象无拷贝，比如 <code>函数、RegExp、Date、Set、Map</code> 等。</p>
<h3 id="2-循环"><a class="markdownIt-Anchor" href="#2-循环"></a> 2. 循环</h3>
<p>  可处理 <code>RegExp</code> 、<code>Date</code>、<code>Array</code> 和 <code>Object</code> 类型的对象，考虑了原型链，且能解决循环引用问题。</p>
<p>  函数一般不需要进行深拷贝。</p>
<p>  避免循环引用的方法就是使用一个对象保存每次递归时的父对象，若有一个对象引用了其任意父级对象，那么就返回那个父级对象的复制即可。</p>
<p>  在下面的代码中， <code>parent</code>  是一个对象，保存了三个属性：</p>
<ul>
<li>
<p><code>originParent</code> ： 当前递归函数中的 <code>obj</code>，根据 <code>_parent.originParent</code> 就能找到其所有父级对象；</p>
</li>
<li>
<p><code>currentParent</code>：当前要返回的克隆对象，因为对象是保存其引用，因此若当前对象下面有属性与其父级对象循环引用，那么该属性值就是那个父级对象的克隆对象。</p>
<p>比如这个例子中的:</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> obj1 = &#123;
  f: <span class="hljs-string">&#x27;other obj&#x27;</span>,
  obj: &#123;
      innerObj: obj
  &#125;
</li>
</ul>
<p>&#125;;</p>
<p>obj.j = obj1;	<span class="hljs-comment">// obj1.obj 引用了父级对象 obj</span><br />
obj.b = obj;	<span class="hljs-comment">// 循环引用自身</span></code></pre>:hexoPostRenderEscape–&gt;</p>
<p>那么在递归函数中就会判断到 <code>obj1.obj</code> 造成了循环引用，因此其属性值就是父级对象 <code>obj</code> 的拷贝结果。</p>
<ul>
<li><code>parent</code>：用于得到每一级的父级对象</li>
</ul>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepCopy</span>(<span class="hljs-params">obj, parent = null</span>) </span>&#123;
    <span class="hljs-comment">// 先排除空值和基本数据类型</span>
    <span class="hljs-keyword">if</span> (!obj || <span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span>) &#123;
        <span class="hljs-keyword">return</span> obj;
    &#125;

    <span class="hljs-keyword">let</span> o, _parent = parent;

    <span class="hljs-comment">// 处理循环引用问题</span>
    <span class="hljs-keyword">while</span> (_parent) &#123;
        <span class="hljs-keyword">if</span> (_parent.originParent === obj) &#123;
            <span class="hljs-keyword">return</span> _parent.currentParent;
        &#125;

        _parent = _parent.parent;
    &#125;

    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">RegExp</span>) &#123;    <span class="hljs-comment">// 处理正则</span>
        o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(obj.source, obj.flags);
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span>) &#123;   <span class="hljs-comment">// 处理日期类型</span>
        o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(obj.getTime());
    &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 数组和对象统一处理，因为可能需要递归复制</span>
        <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>) &#123; 
            o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();
        &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 若是对象，继承其原型</span>
            <span class="hljs-keyword">let</span> proto = <span class="hljs-built_in">Object</span>.getPrototypeOf(obj);
            o = <span class="hljs-built_in">Object</span>.create(proto);
        &#125;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, val] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(obj)) &#123;
            <span class="hljs-keyword">if</span> (val &amp;&amp; <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;
                val = deepCopy(val, &#123;
                    originParent: obj,
                    currentParent: o,
                    parent: parent
                &#125;);
            &#125;
            o[key] = val;
        &#125;
    &#125;

    <span class="hljs-keyword">return</span> o;
&#125;</code></pre>
<h3 id="3-更完备的深拷贝"><a class="markdownIt-Anchor" href="#3-更完备的深拷贝"></a> 3. 更完备的深拷贝</h3>
<p>  使用了 <code>WeakMap</code> 解决了循环引用问题，且不会造成内存泄漏</p>
<p>  能应对 <code>RegExp</code>、<code>Date</code>、<code>Function</code>、<code>Map</code>、<code>Set</code> 等特殊对象的拷贝</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">obj, map=new WeakMap()</span>) </span>&#123;
    <span class="hljs-comment">// 处理 null 和 undefined</span>
    <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> obj;

    <span class="hljs-comment">// 若是基本类型，直接返回</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;function&#x27;</span>) <span class="hljs-keyword">return</span> obj;

    <span class="hljs-comment">// 处理 Date 和 RegExp</span>
    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(obj);
    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">RegExp</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(obj.source, obj.flags);

    <span class="hljs-comment">// 使用 map 解决循环引用问题</span>
    <span class="hljs-keyword">if</span> (map.has(obj)) <span class="hljs-keyword">return</span> map.get(obj);

    <span class="hljs-comment">// 处理函数对象 返回一个新函数，在调用这个函数时会返回原本函数的执行结果</span>
    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span>) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
            <span class="hljs-keyword">return</span> obj.apply(<span class="hljs-built_in">this</span>, [...arguments]);
        &#125;
    &#125;

    <span class="hljs-comment">// 下面是 数组/普通对象/Set/Map 的处理</span>

    <span class="hljs-comment">// 从其原型链中继承的 constructor</span>
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">new</span> obj.constructor();

    <span class="hljs-comment">// 设置 map 以处理循环引用问题</span>
    map.set(obj, res);

    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Map</span>) &#123;
        obj.forEach(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;
            <span class="hljs-comment">// key(index) 不一定是基本数据类型</span>
            res.set(deepClone(index, map), deepClone(item, map));
        &#125;);
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Set</span>) &#123;
        obj.forEach(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;
            obj.add(deepClone(item, map));
        &#125;);
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(obj)) &#123;
            <span class="hljs-keyword">if</span> (value &amp;&amp; <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;
                res[key] = deepClone(value, map);
            &#125; <span class="hljs-keyword">else</span> &#123;
                res[key] = value;
            &#125;
        &#125;
    &#125;

    <span class="hljs-keyword">return</span> res;
&#125;</code></pre>
<h1 id="3-js"><a class="markdownIt-Anchor" href="#3-js"></a> 3. JS</h1>
<h2 id="31-instanceof"><a class="markdownIt-Anchor" href="#31-instanceof"></a> 3.1 instanceof</h2>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof">MDN 文档</a></p>
<p>  <strong><code>instanceof</code></strong> <strong>运算符</strong> 用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。</p>
<p>  故：<code>instanceof</code>操作符其实就是检查左侧的元素的 **<strong>proto</strong>**链上有没有右侧类或对象的<code>prototype</code>存在。</p>
<blockquote>
<p>思路：顺着原型链逐层查找，直到原型链的尽头 <code>null</code> 为止，若过程中 <code>left</code> 的原型与 <code>right</code> 的原型相同，则返回 <code>true</code>。</p>
</blockquote>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myInstanceof</span>(<span class="hljs-params">left, right</span>) </span>&#123;
    <span class="hljs-comment">// 首先，对于基本数据类型，一律返回 false</span>
    <span class="hljs-keyword">if</span> (!left|| <span class="hljs-keyword">typeof</span> left !== <span class="hljs-string">&#x27;object&#x27;</span>) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;

    <span class="hljs-comment">// 获取左边的原型</span>
    <span class="hljs-keyword">let</span> proto = <span class="hljs-built_in">Object</span>.getPrototypeOf(left);

    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;
        <span class="hljs-keyword">if</span> (proto === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">if</span> (proto === right.prototype) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        proto = <span class="hljs-built_in">Object</span>.getPrototypeOf(proto);
    &#125;
&#125;</code></pre>
<h2 id="32-objectcreate"><a class="markdownIt-Anchor" href="#32-objectcreate"></a> 3.2 Object.create</h2>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create#polyfill">MDN polyfill</a></p>
<blockquote>
<p>创建一个纯净的新对象，然后继承其原型</p>
</blockquote>
<pre><code class="hljs js"><span class="hljs-built_in">Object</span>.prototype.myCreate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proto</span>) </span>&#123;
    <span class="hljs-keyword">if</span> (!proto || (<span class="hljs-keyword">typeof</span> proto !== <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> proto !== <span class="hljs-string">&#x27;function&#x27;</span>)) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;proto must be an object!&#x27;</span> + proto);
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>&#123;&#125;
    F.prototype = proto;

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> F();
&#125;</code></pre>
<h2 id="33-new"><a class="markdownIt-Anchor" href="#33-new"></a> 3.3 new</h2>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new">MDN new</a></p>
<p><code>new</code> 被调用后做了三件事：</p>
<ul>
<li>让实例对象可以访问到构造函数的属性</li>
<li>让实例对象可以访问构造函数原型所在原型链上的属性</li>
<li>考虑构造函数有返回值且返回值为对象的情况，这时候返回的对象的优先级更高</li>
</ul>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myNew</span>(<span class="hljs-params">ctor, ...args</span>) </span>&#123;
    <span class="hljs-keyword">let</span> fn = <span class="hljs-built_in">Array</span>.prototype.shift.call(<span class="hljs-built_in">arguments</span>);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&#x27;function&#x27;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;fn&#125;</span> is not a constructor`</span>;
    <span class="hljs-keyword">let</span> obj = <span class="hljs-built_in">Object</span>.create(fn.prototype);	<span class="hljs-comment">// 创建一个新的对象，且继承其原型</span>
    <span class="hljs-keyword">let</span> res = fn.apply(obj, args);
    <span class="hljs-keyword">let</span> isObject = res &amp;&amp; <span class="hljs-keyword">typeof</span> res === <span class="hljs-string">&#x27;object&#x27;</span>;
    <span class="hljs-keyword">let</span> isFunction = <span class="hljs-keyword">typeof</span> res === <span class="hljs-string">&#x27;function&#x27;</span>;
    <span class="hljs-keyword">return</span> isObject || isFunction ? res : obj;
&#125;</code></pre>
<h2 id="34-call-apply"><a class="markdownIt-Anchor" href="#34-call-apply"></a> 3.4 call &amp; apply</h2>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call">MDN call</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">MDN apply</a></p>
<blockquote>
<p>call()方法的作用和 apply() 方法类似，区别就是<code>call()</code>方法接受的是<strong>参数列表</strong>，而<code>apply()</code>方法接受的是<strong>一个参数数组</strong>。</p>
</blockquote>
<p>  主要实现思路就是将需要被调用的函数作为需要使用的 <code>this</code> 指向的对象的属性值，然后调用即可，它会自动绑定 <code>this</code>。</p>
<pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.myCall = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj, ...args</span>) </span>&#123;    <span class="hljs-comment">// or myApply</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;caller must be a function&#x27;</span>;
    <span class="hljs-keyword">let</span> self = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>] || <span class="hljs-built_in">window</span>;  <span class="hljs-comment">// 获取 this 指向的对象，也就是 参数 obj</span>
    self._fn = <span class="hljs-built_in">this</span>;
    <span class="hljs-keyword">let</span> _args = [...arguments].flat().slice(<span class="hljs-number">1</span>); <span class="hljs-comment">// 获取展开后的参数列表，且去除第一个参数 this 指向，使用 flat 展开的原因：若是 apply 函数，传入的参数会是一个数组，因此需要展开</span>
    <span class="hljs-keyword">let</span> res = self._fn(..._args);   <span class="hljs-comment">// 因为是 self 调用的 fn, 因此 fn 中的 this 是指向 self 的</span>
    <span class="hljs-built_in">Reflect</span>.deleteProperty(self, <span class="hljs-string">&#x27;_fn&#x27;</span>);  <span class="hljs-comment">// 将 _fn 从 self 中删除</span>
    <span class="hljs-keyword">return</span>
    res;
&#125;</code></pre>
<h2 id="35-bind"><a class="markdownIt-Anchor" href="#35-bind"></a> 3.5 bind</h2>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">MDN</a></p>
<blockquote>
<p><code>bind()</code> 方法创建一个新的函数，在 <code>bind()</code> 被调用时，这个新函数的 <code>this</code> 被指定为 <code>bind()</code> 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p>
</blockquote>
<pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.myBind = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;caller must be a function!&#x27;</span>;
    <span class="hljs-keyword">let</span> slice = <span class="hljs-built_in">Array</span>.prototype.slice;
    <span class="hljs-keyword">let</span> self = <span class="hljs-built_in">this</span>;
    <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">let</span> args = slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);

    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-comment">// 调用 bind 时会返回一个新函数，然后新函数后还会传递参数，拼接这些参数</span>
        <span class="hljs-keyword">let</span> funcArgs = args.concat(slice.call(<span class="hljs-built_in">arguments</span>));
        <span class="hljs-comment">// 最后返回函数调用结果</span>
        <span class="hljs-keyword">return</span> self.apply(context, funcArgs);
    &#125;;
&#125;;</code></pre>
<p>此外，<code>bind</code> 还有一个特点：</p>
<blockquote>
<p>一个绑定函数也能使用<code>new</code>操作符创建对象：这种行为就像把原函数当成构造器。提供的 <code>this</code>值被忽略，同时调用时的参数被提供给模拟函数。</p>
</blockquote>
<p>也就是说，当 <code>bind</code> 返回的函数作为构造器时，绑定的 <code>this</code> 值将失效，而传入的参数依然生效.</p>
<pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.myBind = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;caller is not a function!&#x27;</span>);

    <span class="hljs-keyword">let</span> slice = <span class="hljs-built_in">Array</span>.prototype.slice;
    <span class="hljs-keyword">let</span> self = <span class="hljs-built_in">this</span>;
    <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">let</span> args = slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);

    <span class="hljs-keyword">let</span> fBound = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-keyword">let</span> newArgs = args.concat(slice(<span class="hljs-built_in">arguments</span>));

        <span class="hljs-comment">// 当 fBound 作为构造函数时，this 指向实例，因此 instanceof 返回 true，因此传入 this 让实例继承来自绑定函数的值</span>
        <span class="hljs-comment">// 当 fBound 作为普通函数时，this 指向 wondow，因此会将 this 绑定到 context</span>
        <span class="hljs-keyword">return</span> self.apply(<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> fBound ? <span class="hljs-built_in">this</span> : context, newArgs);
    &#125;;

    <span class="hljs-comment">// 修改返回函数的 prototype 为绑定函数的 prototype ，实例就可以继承绑定函数原型中的值</span>
    fBound.prototype = <span class="hljs-built_in">Object</span>.create(self.prototype);

    <span class="hljs-keyword">return</span> fBound;
&#125;;</code></pre>
<h2 id="36-arraymap"><a class="markdownIt-Anchor" href="#36-arraymap"></a> 3.6 Array.map</h2>
<p><strong>map 概念：</strong></p>
<p>  <code>map(callback(val, idx, arr), thisArg)</code> 方法将<strong>创建一个新数组</strong>，这个数组中的元素是原数组中的每个元素都调用 <code>callback</code> 后的结果，其中 <code>callback</code> 的三个参数分别是原数组中的<strong>元素</strong>、<strong>元素对应索引值</strong>和<strong>原数组</strong>，<code>thisArg</code> 是 <code>map</code> 函数的 <code>this</code> 指向。</p>
<p>  因此调用 <code>map</code> 函数后，<strong>原数组不会发生改变</strong>。</p>
<p>  且，调用的数组 <code>arr</code> 中的元素不一定是连续的（有的索引位置会为 <code>empty</code>），这点需要注意。</p>
<pre><code class="hljs js"><span class="hljs-built_in">Array</span>.prototype.myMap = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callbackFn, thisArg</span>) </span>&#123;
    <span class="hljs-comment">// null 或 undefined</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == <span class="hljs-literal">null</span>) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">`can&#x27;t not read proterty &#x27;map&#x27; of <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>&#125;</span>`</span> );
    &#125;

    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.prototype.toString.call(callbackFn) !== <span class="hljs-string">&#x27;[object Function]&#x27;</span>) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;callbackFn&#125;</span> is not a function!`</span>);
    &#125;

    <span class="hljs-keyword">let</span> O = <span class="hljs-built_in">Object</span>(<span class="hljs-built_in">this</span>);   <span class="hljs-comment">// 规定 this 需要先转换为对象</span>
    <span class="hljs-keyword">let</span> len = O.length &gt;&gt;&gt; <span class="hljs-number">0</span>;   <span class="hljs-comment">// 保证 len 为数字且为整数</span>
    <span class="hljs-keyword">let</span> T = thisArg || <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">let</span> res = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;
        <span class="hljs-keyword">if</span> (i <span class="hljs-keyword">in</span> O) &#123;
            <span class="hljs-keyword">let</span> mappedValue = callbackFn.call(T, O[i], i, O);
            res[i] = mappedValue;
        &#125;
    &#125;

    <span class="hljs-keyword">return</span> res;
&#125;;</code></pre>
<p>其中：</p>
<ul>
<li>
<p><code>&gt;&gt;&gt;</code>运算符为 零填充右移运算符，如 <code>0101 &gt;&gt;&gt; 1 : 0010</code>，保证 <code>len</code> 为数字且为整数</p>
</li>
<li>
<p>使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object">Object</a>  是为了保证 <code>o</code> 一定是一个对象：</p>
<ul>
<li>当给定值是 <code>null</code> 或 <code>undefined</code> 时，会创建并返回一个空对象</li>
<li>若传进去的是一个基本类型的值，则会构造其包装类型的对象，如 <code>Object(3)</code> ，会返回 <code>Number &#123;3&#125;</code></li>
<li>若传的是引用类型的值，仍会返回这个值，因此引用是相同的</li>
</ul>
</li>
</ul>
<h1 id="4-柯里化"><a class="markdownIt-Anchor" href="#4-柯里化"></a> 4.  柯里化</h1>
<p>  柯里化，是函数式编程的一个重要概念。</p>
<p>  概念：是一种将使用多个参数的函数转换成<strong>一系列</strong>使用一个参数的函数的技术。为了保证柯里化能达到预期结果，这个函数需要是纯函数。</p>
<p>  好处：减少代码冗余，增加可读性</p>
<p>  坏处：若参数过多难免会对性能造成一定的影响</p>
<blockquote>
<p>纯函数：一个函数的返回结果只依赖于它的参数，并且在执行过程中不会产生副作用，那么这种函数就叫做纯函数</p>
</blockquote>
<p>  一个最常见的柯里化例子：</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a, b, c</span>) </span>&#123;
    <span class="hljs-keyword">return</span> a + b + c;
&#125;

<span class="hljs-comment">// 柯里化后</span>
<span class="hljs-keyword">let</span> curryingSum = curry(sum);

curryingSum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// =&gt; 6</span>
curryingSum(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>); <span class="hljs-comment">// =&gt; 6</span>
curryingSum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)(<span class="hljs-number">3</span>); <span class="hljs-comment">// =&gt; 6</span>
curryingSum(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// =&gt; 6</span></code></pre>
<p><mark>新知识</mark>：<code>函数名.length = 函数参数个数</code></p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span>(<span class="hljs-params">fn, args=[]</span>) </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-keyword">let</span> newArgs = args.concat(<span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>));
        <span class="hljs-comment">// 若 fn 参数个数大于 当前参数列表的参数个数，那么递归调用 curry</span>
        <span class="hljs-comment">// 每次调用 curry 都会返回一个函数，然后这个函数中会保存当前已传入的参数</span>
        <span class="hljs-comment">// 一直调用 curry 直到参数个数足够，就调用 fn 返回结果</span>
        <span class="hljs-keyword">if</span> (fn.length &gt; newArgs.length) &#123;
            <span class="hljs-keyword">return</span> curry.call(<span class="hljs-built_in">this</span>, fn, newArgs);
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-built_in">this</span>, newArgs);
        &#125;
    &#125;;
&#125;

<span class="hljs-comment">// ES6 装逼写法</span>
<span class="hljs-keyword">const</span> curry = <span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> 
    judge = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> 
        args.length === fn.length
        	? fn(...args)
        	: <span class="hljs-function">(<span class="hljs-params">arg</span>) =&gt;</span> judge(...args, arg)</code></pre>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2975c25e4d71">https://www.jianshu.com/p/2975c25e4d71</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000018180159">https://segmentfault.com/a/1190000018180159</a></p>
<h1 id="5-组合寄生继承"><a class="markdownIt-Anchor" href="#5-组合寄生继承"></a> 5. 组合寄生继承</h1>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf">Object.setPrototypeOf</a></p>
<h2 id="组合继承"><a class="markdownIt-Anchor" href="#组合继承"></a> 组合继承</h2>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">this</span>.id = <span class="hljs-string">&#x27;001&#x27;</span>;
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params"></span>) </span>&#123;
    Parent.call(<span class="hljs-built_in">this</span>);	<span class="hljs-comment">// 继承 Parent 的属性</span>
    <span class="hljs-built_in">this</span>.age = <span class="hljs-number">18</span>;
&#125;

Child.prototype = <span class="hljs-keyword">new</span> Parent();	<span class="hljs-comment">// 继承原型属性和方法</span>
Child.prototype.constructor = Child;</code></pre>
<p>  上面这种继承方式就叫做<strong>组合继承</strong>，这种方法最大的缺点就是调用了两次父类的构造函数，带来的影响就是子类内部和子类的原型链上会有属性冗余，如上例中 <code>id</code> 属性就会同时存在与 <code>Child</code> 和 <code>Child.prototype</code> 中。</p>
<img src="https://gitee.com/ylea/imagehost/raw/master/img/image-20210222165839847.png" srcset="/img/loading.gif" alt="image-20210222165839847" style="zoom:80%;" />
<h2 id="寄生继承"><a class="markdownIt-Anchor" href="#寄生继承"></a> 寄生继承</h2>
<p>  <strong>寄生继承</strong> 就是借用一个中间对象来继承原对象的属性和方法，然后在这个新对象上进行二次封装，如：</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">object</span>(<span class="hljs-params">o</span>) </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;
    F.prototype = o;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> F();
&#125;
<span class="hljs-keyword">var</span> twoD = &#123;
    name: <span class="hljs-string">&#x27;2D shape&#x27;</span>,
    dimensions: <span class="hljs-number">2</span>
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">triangle</span>(<span class="hljs-params">s, h</span>) </span>&#123;
    <span class="hljs-keyword">var</span> that = object(twoD);
    that.name = <span class="hljs-string">&#x27;Triangle&#x27;</span>;
    <span class="hljs-keyword">return</span> that;
&#125;</code></pre>
<p>  上面的 <code>object</code> 方法可以使用 <code>Object.create</code> 方法来替代。</p>
<p>  <strong>寄生组合继承</strong> 就是结合了以上两种继承方法，用来解决组合继承中冗余的属性问题：</p>
<ul>
<li>
<p>通过借用构造函数来继承属性；</p>
</li>
<li>
<p>通过原型链来继承方法。</p>
</li>
</ul>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">this</span>.id = <span class="hljs-string">&#x27;001&#x27;</span>;
&#125;

<span class="hljs-comment">// 定义静态属性和方法</span>
Parent.log = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;static&#x27;</span>);
&#125;
Parent.x = <span class="hljs-number">3</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params"></span>) </span>&#123;
    Parent.call(<span class="hljs-built_in">this</span>);  <span class="hljs-comment">// 继承父类属性</span>
    <span class="hljs-built_in">this</span>.age = <span class="hljs-number">18</span>;
&#125;

Child.prototype = <span class="hljs-built_in">Object</span>.create(Parent.prototype);  <span class="hljs-comment">// 继承父类原型的属性和方法</span>
<span class="hljs-built_in">Object</span>.setPrototypeOf(Child, Parent);   <span class="hljs-comment">// 继承静态属性</span>
Child.prototype.constructor = Child;    <span class="hljs-comment">// constructor 重新指向 Child</span></code></pre>
<p>  使用寄生组合继承的话，就能解决组合继承的问题：</p>
<img src="https://gitee.com/ylea/imagehost/raw/master/img/image-20210222170020436.png" srcset="/img/loading.gif" alt="image-20210222170020436" style="zoom:80%;" />
<h1 id="6-class-私有属性"><a class="markdownIt-Anchor" href="#6-class-私有属性"></a> 6. class 私有属性</h1>
<p>  私有属性一般满足：</p>
<ul>
<li>能被 class 内部的不同方法访问，但是不能在类外部被访问</li>
<li>不能被子类继承</li>
</ul>
<p>  ES6 中已经有了一个 <code>#</code> 来创建私有属性，不过需要 <code>babel</code> 转译。</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> MyClass = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;	<span class="hljs-comment">// 利用闭包和 WeakMap</span>
    <span class="hljs-keyword">const</span> _x = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>();
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerClass</span> </span>&#123;
        <span class="hljs-keyword">constructor</span>(x) &#123;
            _x.set(<span class="hljs-built_in">this</span>, x);
        &#125;

        getX() &#123;
            <span class="hljs-keyword">return</span> _x.get(<span class="hljs-built_in">this</span>);
        &#125;
    &#125;

    <span class="hljs-keyword">return</span> InnerClass;
&#125;)();

<span class="hljs-keyword">let</span> c = <span class="hljs-keyword">new</span> MyClass(<span class="hljs-number">5</span>);
<span class="hljs-built_in">console</span>.log(c.getX());  <span class="hljs-comment">// 5</span>
<span class="hljs-built_in">console</span>.log(c._x)   <span class="hljs-comment">// undefined</span></code></pre>
<h1 id="7-数组排序"><a class="markdownIt-Anchor" href="#7-数组排序"></a> 7.  数组排序</h1>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">菜鸟教程</a></p>
<p>排序算法分类：</p>
<img src="https://gitee.com/ylea/imagehost/raw/master/img/849589-20190306165258970-1789860540.png" srcset="/img/loading.gif" style="zoom:67%;" />
<p><img src="https://gitee.com/ylea/imagehost/raw/master/img/sort.png" srcset="/img/loading.gif" alt="" /></p>
<h2 id="71-冒泡排序"><a class="markdownIt-Anchor" href="#71-冒泡排序"></a> 7.1 冒泡排序</h2>
<p>  冒泡排序的思想就是使用双循环，将相邻数字中大的数字往前冒泡。</p>
<p>  若一趟排序中没有进行交换，则表示数组已经有序，可以退出了。</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bubbleSort</span>(<span class="hljs-params">arr</span>) </span>&#123;
    <span class="hljs-keyword">let</span> len = arr.length;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;
        <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt; len - i; ++j) &#123;
            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[j<span class="hljs-number">-1</span>]) &#123;
                [arr[j], arr[j<span class="hljs-number">-1</span>]] = [arr[j<span class="hljs-number">-1</span>], arr[j]];
                flag = <span class="hljs-literal">false</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">if</span> (flag) &#123;
            <span class="hljs-keyword">break</span>;
        &#125;
    &#125;
&#125;</code></pre>
<h2 id="72-简单插入排序"><a class="markdownIt-Anchor" href="#72-简单插入排序"></a> 7.2 简单插入排序</h2>
<p>  思想：分为已排序部分和未排序部分，遍历未排序部分，每次将第一个数在已排序部分中选择一个合适的位置插入。</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertSort</span>(<span class="hljs-params">arr</span>) </span>&#123;
    <span class="hljs-keyword">let</span> len = arr.length;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; len; ++i) &#123;
        <span class="hljs-keyword">let</span> val = arr[i];
        <span class="hljs-keyword">let</span> j = i - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; val) &#123;
            arr[j + <span class="hljs-number">1</span>] = arr[j];
            j--;
        &#125;
        arr[j + <span class="hljs-number">1</span>] = val;
    &#125;
&#125;</code></pre>
<h2 id="73-简单选择排序"><a class="markdownIt-Anchor" href="#73-简单选择排序"></a> 7.3 简单选择排序</h2>
<p>  基本思想是每次从无序列表中选择一个最大/小的数放到有序列表的前/后面。</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">selectSort</span>(<span class="hljs-params">arr</span>) </span>&#123;
    <span class="hljs-keyword">let</span> len = arr.length;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; ++i) &#123;
        <span class="hljs-keyword">let</span> idx = i;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; len; ++j) &#123;
            <span class="hljs-keyword">if</span> (arr[idx] &gt; arr[j]) &#123;
                idx = j;
            &#125;

            <span class="hljs-keyword">if</span> (idx !== i) &#123;
                [arr[idx], arr[i]] = [arr[i], arr[idx]];
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<h2 id="74-快速排序"><a class="markdownIt-Anchor" href="#74-快速排序"></a> 7.4 快速排序</h2>
<p>  快排是不稳定的原因是：在排序过程中，若选择一个 <code>pivot</code>，此时将小于等于 <code>pivot</code> 的都放左边，大于的都放右边，那么就是不稳定的了；或者是将大于等于的放右边，小于等于的放左边，同样也是不稳定的。（因为除了小于后就是大于等于了）</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">qiuckSort</span>(<span class="hljs-params">arr, left=<span class="hljs-number">0</span>, right=arr.length<span class="hljs-number">-1</span></span>) </span>&#123;
    <span class="hljs-keyword">if</span> (left &lt; right) &#123;
        <span class="hljs-keyword">let</span> idx = partition(arr, left, right);
        qiuckSort(arr, left, idx - <span class="hljs-number">1</span>);
        qiuckSort(arr, idx + <span class="hljs-number">1</span>, right);
    &#125;
&#125;</code></pre>
<p>  其中 <code>partition</code> 有两种写法：</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">partition</span>(<span class="hljs-params">arr, left, right</span>) </span>&#123;
    <span class="hljs-comment">// 以 left 值为基准</span>
    <span class="hljs-keyword">let</span> index = left + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">let</span> pivot = arr[left];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = index; i &lt;= right; ++i) &#123;
        <span class="hljs-keyword">if</span> (arr[i] &lt; pivot) &#123;
            [arr[i], arr[index]] = [arr[index], arr[i]];
            index++;
        &#125;
    &#125;
    [arr[left], arr[index<span class="hljs-number">-1</span>]] = [arr[index<span class="hljs-number">-1</span>], arr[left]];

    <span class="hljs-keyword">return</span> index - <span class="hljs-number">1</span>;

    <span class="hljs-comment">// 以 right 为基准</span>
    <span class="hljs-comment">// let index = left;</span>
    <span class="hljs-comment">// for (let i = index; i &lt; right; ++i) &#123;</span>
    <span class="hljs-comment">//     if (arr[i] &lt; arr[right]) &#123;</span>
    <span class="hljs-comment">//         [arr[i], arr[index]] = [arr[index], arr[i]];</span>
    <span class="hljs-comment">//         index++;</span>
    <span class="hljs-comment">//     &#125;</span>
    <span class="hljs-comment">// &#125;</span>
    <span class="hljs-comment">// [arr[right], arr[index]] = [arr[index], arr[right]];</span>

    <span class="hljs-comment">// return index;</span>
&#125;</code></pre>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">partition</span>(<span class="hljs-params">arr, left, right</span>) </span>&#123;
    <span class="hljs-keyword">let</span> pivot = arr[left];
    <span class="hljs-keyword">while</span> (left &lt; right) &#123;
        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt; pivot) &#123;
            right--;
        &#125;
        arr[left] = arr[right];
        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot) &#123;
            left++;
        &#125;
        arr[right] = arr[left];
    &#125;
    arr[left] = pivot;

    <span class="hljs-keyword">return</span> left;
&#125;</code></pre>
<h2 id="75-归并排序"><a class="markdownIt-Anchor" href="#75-归并排序"></a> 7.5 归并排序</h2>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeSort</span>(<span class="hljs-params">arr, left=<span class="hljs-number">0</span>, right=arr.length<span class="hljs-number">-1</span></span>) </span>&#123;
    <span class="hljs-keyword">if</span> (left &lt; right) &#123;
        <span class="hljs-keyword">let</span> mid = left + <span class="hljs-built_in">Math</span>.floor((right - left) / <span class="hljs-number">2</span>);
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + <span class="hljs-number">1</span>, right);
        merge(arr, left, mid, mid + <span class="hljs-number">1</span>, right);
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">merge</span>(<span class="hljs-params">arr, l1, r1, l2, r2</span>) </span>&#123;
    <span class="hljs-keyword">let</span> res = [];
    <span class="hljs-keyword">let</span> l = l1;
    <span class="hljs-keyword">while</span> (l1 &lt;= r1 &amp;&amp; l2 &lt;= r2) &#123;
        <span class="hljs-keyword">if</span> (arr[l1] &lt; arr[l2]) &#123;
            res.push(arr[l1]);
            l1++;
        &#125; <span class="hljs-keyword">else</span> &#123;
            res.push(arr[l2]);
            l2++;
        &#125;
    &#125;

    <span class="hljs-keyword">while</span> (l1 &lt;= r1) &#123;
        res.push(arr[l1]);
        l1++;
    &#125;
    <span class="hljs-keyword">while</span> (l2 &lt;= r2) &#123;
        res.push(arr[l2]);
        l2++;
    &#125;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = l; i &lt;= r2; i++) &#123;
        arr[i] = res[i - l];
    &#125;
    
    <span class="hljs-comment">// or arr.splice(l, r2 - l + 1, ...res);</span>
&#125;</code></pre>
<h2 id="76-堆排序"><a class="markdownIt-Anchor" href="#76-堆排序"></a> 7.6 堆排序</h2>
<p><a target="_blank" rel="noopener" href="https://github.com/sisterAn/JavaScript-Algorithms/issues/60">https://github.com/sisterAn/JavaScript-Algorithms/issues/60</a></p>
<p>  堆主要是使用数组来存储一棵树，假设有一个数组的第一个有意义的元素索引从 <code>1</code> 开始，对于一个索引 <code>i</code>，那么其父节点的索引就是 <code>i / 2</code>，其左孩子索引是 <code>i * 2</code>，右孩子索引值是 <code>i * 2 + 1</code>。</p>
<p>  若堆索引从 <code>0</code> 开始，那么对于一个索引 <code>i</code>，其父节点索引就是 <code>(i-1)/2</code>，左孩子索引就是 <code>i * 2 - 1</code>，右孩子索引就是 <code>i * 2</code>。</p>
<p>  <strong>下面的算法是按照堆元素索引从 <code>1</code> 开始的。</strong></p>
<p>  因此，首先需要有一个长度为 <code>1</code> 的数组存储堆元素：</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> items = [,];</code></pre>
<p>  首先，给你一个数组，需要将其调整为堆。</p>
<p>  堆的调整有两种方法：</p>
<ul>
<li><strong>自下而上堆化</strong>：将节点值与父节点值比较，若大于父节点值（大顶堆）或小于父节点值（小顶堆），那么就将其交换</li>
<li><strong>自上而下堆化</strong>：对于一个节点，比较其左右孩子的节点值，选出其较大的子节点值（大顶堆）和当前节点值比较，若子节点值大于当前节点值，则交换位置；小顶堆同理</li>
</ul>
<p>  <strong>所以，自下而上式堆是调整节点与父节点（往上走），自上往下式堆化是调整节点与其左右子节点（往下走）。</strong></p>
<h3 id="从前往后自下而上堆化"><a class="markdownIt-Anchor" href="#从前往后自下而上堆化"></a> 从前往后，自下而上堆化</h3>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildHeap</span>(<span class="hljs-params">arr, heapSize</span>) </span>&#123;
    <span class="hljs-keyword">while</span> (heapSize &lt; arr.length - <span class="hljs-number">1</span>) &#123;
        heapSize++;
        heapify(arr, heapSize);
    &#125;
&#125;

<span class="hljs-comment">// 大顶堆</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">heapify</span>(<span class="hljs-params">arr, i</span>) </span>&#123;
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">Math</span>.floor(i / <span class="hljs-number">2</span>) &gt; <span class="hljs-number">0</span> &amp;&amp; arr[i] &gt; arr[<span class="hljs-built_in">Math</span>.floor(i / <span class="hljs-number">2</span>)]) &#123;
        swap(arr, i, <span class="hljs-built_in">Math</span>.floor(i / <span class="hljs-number">2</span>));
        i = <span class="hljs-built_in">Math</span>.floor(i / <span class="hljs-number">2</span>);
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swap</span>(<span class="hljs-params">arr, l, r</span>) </span>&#123;
    [arr[l], arr[r]] = [arr[r], arr[l]];
&#125;

<span class="hljs-keyword">let</span> items = [, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>];

buildHeap(items, <span class="hljs-number">1</span>);

<span class="hljs-built_in">console</span>.log(items)  <span class="hljs-comment">// 5 4 1 2 3</span></code></pre>
<h3 id="从后往前自上而下堆化"><a class="markdownIt-Anchor" href="#从后往前自上而下堆化"></a> 从后往前，自上而下堆化</h3>
<p>  这边说的 <strong>后</strong> 不是数组末尾，而是树中的最后一个非叶子结点，索引值就是 <code>heapSize / 2</code>。</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildHeap</span>(<span class="hljs-params">heap, heapSize</span>) </span>&#123;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-built_in">Math</span>.floor(heapSize / <span class="hljs-number">2</span>); i &gt; <span class="hljs-number">0</span>; --i) &#123;
        heapify(heap, heapSize, i);
    &#125;
&#125;

<span class="hljs-comment">// 大顶堆</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">heapify</span>(<span class="hljs-params">heap, heapSize, i</span>) </span>&#123;
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;
        <span class="hljs-comment">// 使用 maxIndex 记录左右孩子结点的较大结点值索引，当 maxIndex === i 或 当前节点无子节点时，退出循环</span>
        <span class="hljs-keyword">let</span> maxIndex = i;
        <span class="hljs-keyword">if</span> (i * <span class="hljs-number">2</span> &lt;= heapSize &amp;&amp; heap[i * <span class="hljs-number">2</span>] &gt; heap[i]) &#123;
            maxIndex = i * <span class="hljs-number">2</span>;
        &#125;
        <span class="hljs-keyword">if</span> (i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= heapSize &amp;&amp; heap[i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] &gt; heap[maxIndex]) &#123;
            maxIndex = i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;
        &#125;

        <span class="hljs-keyword">if</span> (maxIndex === i) <span class="hljs-keyword">break</span>;
        swap(heap, i, maxIndex);
        i = maxIndex;
    &#125;
&#125;</code></pre>
<h3 id="堆排"><a class="markdownIt-Anchor" href="#堆排"></a> 堆排</h3>
<p>  堆其实就是一棵<strong>完全二叉树</strong>，因此可以使用数组存储，根据索引值来计算其父节点和子节点的位置。</p>
<p>  设根结点的索引值为 <code>1</code>，那么我们若要对其进行排序，我们先创建一个堆，堆顶元素即是最大/最小值。然后我们每次将堆顶元素与堆的最后一个节点交换位置，并将最后一个节点从堆中移除（堆的大小减 1），移除堆尾元素的堆仍是一个完全二叉树，然后重新堆化，这样重复选取值直到堆的大小为 1 为止。</p>
<p>  因此，<strong>大顶堆排序的结果是从小到大排序</strong>，<strong>小顶堆的排序结果是从大到小排序</strong>。</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">heapSort</span>(<span class="hljs-params">heap</span>) </span>&#123;
    <span class="hljs-keyword">let</span> heapSize = heap.length - <span class="hljs-number">1</span>;

    buildHeap(heap, heapSize);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = heapSize; i &gt; <span class="hljs-number">1</span>; --i) &#123;
        swap(heap, <span class="hljs-number">1</span>, i);
        heapify(heap, i - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
    &#125;
&#125;</code></pre>
<h1 id="8-数组去重"><a class="markdownIt-Anchor" href="#8-数组去重"></a> 8. 数组去重</h1>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> inarr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];
<span class="hljs-keyword">let</span> inarr2 = &#123;<span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-attr">b</span>: <span class="hljs-string">&#x27;b&#x27;</span>&#125;;
<span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, inarr1, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, inarr1, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, inarr2, inarr2];
<span class="hljs-keyword">let</span> arr1 = [];

<span class="hljs-comment">// 1.使用 set</span>
arr1 = [...new <span class="hljs-built_in">Set</span>(arr)];

<span class="hljs-comment">// 2.使用 filter</span>
arr1 = arr.filter(<span class="hljs-function">(<span class="hljs-params">val, idx</span>) =&gt;</span> &#123;
    <span class="hljs-keyword">return</span> arr.indexOf(val) === idx;
&#125;);

<span class="hljs-comment">// 3. 使用循环</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> val <span class="hljs-keyword">of</span> arr) &#123;
    <span class="hljs-keyword">if</span> (arr1.indexOf(val) === <span class="hljs-number">-1</span>) &#123;
        arr1.push(val);
    &#125;
&#125;

<span class="hljs-comment">// 4. 排序后去重</span>
arr.sort();
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> val <span class="hljs-keyword">of</span> arr) &#123;
    <span class="hljs-keyword">if</span> (arr1.length === <span class="hljs-number">0</span> || arr1[arr1.length<span class="hljs-number">-1</span>] !== val) &#123;
        arr1.push(val);
    &#125;
&#125;</code></pre>
<h1 id="9-随机字符串"><a class="markdownIt-Anchor" href="#9-随机字符串"></a> 9. 随机字符串</h1>
<p>  主要使用 <code>Random</code> 和 <code>toString(radix)</code> 来生成随机字符串</p>
<p>  <code>toString</code> 方法能接收一个参数作为进制，若进制大于 <code>10</code> ，则会使用字母来进行数字表示，且范围为 <code>2 ~ 36</code>，因此可以使用 <code>toString(36)</code> 来生成一个由数字（0 ~ 9）和字母（a ~ z）表示的字符串。</p>
<p>  不过，这种方法生成的随机字符串并不安全，不能用于实际开发中。</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateRandomString</span>(<span class="hljs-params">len</span>) </span>&#123;
    <span class="hljs-keyword">let</span> randomStr = <span class="hljs-string">&#x27;&#x27;</span>;
    <span class="hljs-keyword">for</span> (; randomStr.length &lt; len; randomStr += <span class="hljs-built_in">Math</span>.random().toString(<span class="hljs-number">36</span>).substr(<span class="hljs-number">2</span>)) &#123;&#125;

    <span class="hljs-keyword">return</span> randomStr.substr(<span class="hljs-number">0</span>, len);
&#125;</code></pre>
<img src="https://gitee.com/ylea/imagehost/raw/master/img/image-20210223173951760.png" srcset="/img/loading.gif" alt="image-20210223173951760" style="zoom:80%;" />
<h1 id="10-解析url"><a class="markdownIt-Anchor" href="#10-解析url"></a> 10. 解析URL</h1>
<p>ref : <a target="_blank" rel="noopener" href="https://juejin.cn/post/6902060047388377095#heading-26">https://juejin.cn/post/6902060047388377095#heading-26</a></p>
<p>  URL 的组成，常见的 url 部分使用虚线包裹：</p>
<p><img src="https://gitee.com/ylea/imagehost/raw/master/img/image-20210224181025162.png" srcset="/img/loading.gif" alt="image-20210224181025162" /></p>
<p>举个 🌰：<code>https://keith:miao@www.foo.com:80/file?test=3&amp;miao=4#heading-0</code></p>
<p>  一个最简单的 url 解析方法：使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL">URL</a> 构造函数解析：</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseURL</span>(<span class="hljs-params">url</span>) </span>&#123;
    <span class="hljs-keyword">const</span> urlObj = <span class="hljs-keyword">new</span> URL(url);
    <span class="hljs-keyword">return</span> &#123;
        protocol: urlObj.protocol,
        username: urlObj.username,
        password: urlObj.password,
        hostname: urlObj.hostname,
        port: urlObj.port,
        pathname: urlObj.pathname,
        search: urlObj.search,
        hash: urlObj.hash
    &#125;;
&#125;</code></pre>
<h1 id="11-jsonp"><a class="markdownIt-Anchor" href="#11-jsonp"></a> 11. jsonp</h1>
<h2 id="jsonp-介绍"><a class="markdownIt-Anchor" href="#jsonp-介绍"></a> JSONP 介绍</h2>
<p>  JSONP 即 JSON with Padding。它是借助了 HTML 中 <code>src</code> 属性可跨域的特点来进行 <code>GET</code> 请求，我们通过 <code>src</code> 中 <code>url</code> 部分的参数传递，给出回调的函数名，如 <code>?callback=cbFunction</code>，然后响应中返回要执行的 <code>JS</code> 代码，使用字符串拼接的方式传递回调函数中的参数，然后浏览器接受响应，就直接执行了返回的代码。</p>
<p>  因此 JSONP 由两部分组成：<strong>回调函数</strong> 和 <strong>数据</strong>。回调函数是当响应到来时要在页面中调用的函数，函数名一般通过请求 url 传递；而数据通过服务器响应请求时通过字符串拼接作为回调函数的参数返回。</p>
<p>JSONP 优点：</p>
<ul>
<li>不受同源策略的限制</li>
<li>兼容性好</li>
<li>实现简单</li>
</ul>
<p>缺点：</p>
<ul>
<li>只支持 <code>GET</code> 请求</li>
<li>不能解决不同域的两个页面之间如何进行 JS 调用的问题（需要调用的 JS 代码在一个域中，而获取的数据在另一个域中？）</li>
<li>属于嵌入式脚本，有一定安全风险</li>
</ul>
<p>简例：</p>
<p>前端：</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>点击我发送get请求<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 写法1： --&gt;</span>
    <span class="hljs-comment">&lt;!-- &lt;script&gt;</span>
<span class="hljs-comment">        function jsonpcallback(response)&#123;</span>
<span class="hljs-comment">        	alert(response.message);</span>
<span class="hljs-comment">        &#125;</span>
<span class="hljs-comment">    &lt;/script&gt;</span>
<span class="hljs-comment">    &lt;script src=&quot;http://127.0.0.1:3000/get?callback=jsonpcallback&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 写法2： --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
<span class="javascript">    <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;button&#x27;</span>)[<span class="hljs-number">0</span>].addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span>
<span class="javascript">        ajax(<span class="hljs-string">&#x27;http://127.0.0.1:3000/get&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>)</span>&#123;</span>
            alert(response.message);
        &#125;);
    &#125;);
<span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ajax</span>(<span class="hljs-params">url, callback</span>)</span>&#123;</span>
<span class="javascript">        <span class="hljs-keyword">var</span> jsonp=<span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>);</span>
<span class="javascript">        jsonp.type = <span class="hljs-string">&#x27;text/javascript&#x27;</span>;</span>
<span class="javascript">        jsonp.src=url+<span class="hljs-string">&#x27;?callback=jsonpcallback&#x27;</span>;</span>
<span class="javascript">        jsonpcallback = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>)</span>&#123;</span>
            callback(response);
        &#125;;
<span class="javascript">        <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;head&#x27;</span>)[<span class="hljs-number">0</span>].appendChild(jsonp);</span>
    &#125;
<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>服务端代码：</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> Koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa&#x27;</span>);
<span class="hljs-keyword">var</span> Router = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa-router&#x27;</span>);
<span class="hljs-keyword">var</span> querystring = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;querystring&#x27;</span>);
<span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Koa();
<span class="hljs-keyword">var</span> router = <span class="hljs-keyword">new</span> Router();

<span class="hljs-comment">//处理get请求</span>
router.get(<span class="hljs-string">&#x27;/get&#x27;</span>, <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ctx</span>)</span>&#123;
    <span class="hljs-keyword">var</span> params = querystring.parse(ctx.request.url.split(<span class="hljs-string">&#x27;?&#x27;</span>)[<span class="hljs-number">1</span>]);
    <span class="hljs-keyword">var</span> data = &#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;我是&quot;</span> + ctx.request.header.host + <span class="hljs-string">&quot;，我收到了你的get请求！！！&quot;</span> &#125;
    ctx.status=<span class="hljs-number">200</span>;
    ctx.body=params[<span class="hljs-string">&#x27;callback&#x27;</span>]+<span class="hljs-string">&#x27;(&#x27;</span>+<span class="hljs-built_in">JSON</span>.stringify(data)+<span class="hljs-string">&#x27;);&#x27;</span>;
&#125;);

app
    .use(router.routes())
    .use(router.allowedMethods())

app.listen(<span class="hljs-number">3000</span>);</code></pre>
<p>简单总结就是：</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonpcallback</span>(<span class="hljs-params">response</span>)</span>&#123;
    alert(response.message);
&#125;
jsonpcallback(&#123;<span class="hljs-string">&quot;message&quot;</span>:<span class="hljs-string">&quot;我是127.0.0.1:3000，我收到了你的get请求！！！&quot;</span>&#125;);</code></pre>
<h2 id="手写-jsonp"><a class="markdownIt-Anchor" href="#手写-jsonp"></a> 手写 JSONP</h2>
<p>  手写 jsonp 也就是通过给定的参数和回调函数名称构造一个 url，然后再创建一个 <code>script</code> 标签来使用这个 url，最后再通过回调函数获取数据：</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> jsonp = <span class="hljs-function">(<span class="hljs-params">&#123;url, params, callbackName&#125;</span>) =&gt;</span> &#123;
    <span class="hljs-keyword">const</span> generateURL = <span class="hljs-function">() =&gt;</span> &#123;
        <span class="hljs-keyword">let</span> dataStr = <span class="hljs-string">&#x27;&#x27;</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> params) &#123;
            dataStr += <span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>=<span class="hljs-subst">$&#123;params[key]&#125;</span>&amp;`</span>;
        &#125;
        dataStr += <span class="hljs-string">`callback=<span class="hljs-subst">$&#123;callbackName&#125;</span>`</span>

        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;url&#125;</span>?<span class="hljs-subst">$&#123;dataStr&#125;</span>`</span>;
    &#125;;

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;
        callbackName = callbackName || <span class="hljs-built_in">Math</span>.random().toString();
        <span class="hljs-keyword">let</span> scriptEle = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>);
        scriptEle.src = generateURL();
        <span class="hljs-built_in">document</span>.body.appendChild(scriptEle);

        <span class="hljs-comment">// 随后，服务器返回字符串 &#x27;callbackName(data)&#x27;，浏览器解析即可执行</span>
        <span class="hljs-comment">// 在全局对象中添加处理回调方法</span>
        <span class="hljs-built_in">window</span>[callbackName] = <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;
            resolve(data);
            <span class="hljs-comment">// 最后再移除不需要的 dom 节点，防止内存泄漏</span>
            <span class="hljs-built_in">document</span>.body.removeChild(scriptEle);
        &#125;;
    &#125;);
&#125;;</code></pre>
<p>简例：</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> jsonp = <span class="hljs-function">(<span class="hljs-params">&#123;url, params, callbackName&#125;</span>) =&gt;</span> &#123;
    <span class="hljs-keyword">const</span> generateURL = <span class="hljs-function">() =&gt;</span> &#123;
        <span class="hljs-keyword">let</span> dataStr = <span class="hljs-string">&#x27;&#x27;</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> params) &#123;
            dataStr += <span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>=<span class="hljs-subst">$&#123;params[key]&#125;</span>&amp;`</span>;
        &#125;
        dataStr += <span class="hljs-string">`jsoncallback=<span class="hljs-subst">$&#123;callbackName&#125;</span>`</span>
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;url&#125;</span>?<span class="hljs-subst">$&#123;dataStr&#125;</span>`</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;url&#125;</span>?<span class="hljs-subst">$&#123;dataStr&#125;</span>`</span>;
    &#125;;

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;
        callbackName = callbackName || <span class="hljs-built_in">Math</span>.random().toString();
        <span class="hljs-keyword">let</span> scriptEle = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>);
        scriptEle.src = generateURL();

        <span class="hljs-built_in">document</span>.body.appendChild(scriptEle);

        <span class="hljs-comment">// 随后，服务器返回字符串 &#x27;callbackName(data)&#x27;，浏览器解析即可执行</span>
        <span class="hljs-comment">// 在全局对象中添加处理回调方法</span>
        <span class="hljs-built_in">window</span>[callbackName] = <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;data: &#x27;</span>, data);
            resolve(data);
            <span class="hljs-comment">// 最后再移除不需要的 dom 节点，防止内存泄漏</span>
            <span class="hljs-built_in">document</span>.body.removeChild(scriptEle);
        &#125;;
    &#125;);
&#125;;

jsonp(&#123;
    url: <span class="hljs-string">&#x27;https://www.runoob.com/try/ajax/jsonp.php&#x27;</span>,
    callbackName: <span class="hljs-string">&#x27;callbackFunction&#x27;</span>
&#125;).then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;
    <span class="hljs-built_in">console</span>.log(data)
&#125;);</code></pre>
<h1 id="12-图片懒加载"><a class="markdownIt-Anchor" href="#12-图片懒加载"></a> 12. 图片懒加载</h1>
<p>  懒加载是一种网页性能优化策略，若一个页面中当前不可见区域有图片需要加载，那么可以延迟该图片的请求，直到达到该图片的可视区域为止。</p>
<h2 id="懒加载的实现原理"><a class="markdownIt-Anchor" href="#懒加载的实现原理"></a> 懒加载的实现原理</h2>
<p>  网页中一般占用较多资源的是图片文件，因此懒加载一般是针对图片而言的。</p>
<p>  而一张图片就是一个 <code>&lt;img&gt;</code> 标签，图片的加载源就是其 <code>src</code> 属性，浏览器发起请求就是根据其是否有 <code>src</code> 属性来决定的。</p>
<p>  因此可以根据 <code>&lt;img&gt;</code> 标签的位置，当标签在可视区域之外时，其 <code>src</code> 属性为空，而当即将进入可视区域时，设置其 <code>src</code> 属性，让浏览器发起图片请求。</p>
<p>  所以说<strong>懒加载的要点就是可视区域的判断</strong></p>
<p>  在页面进行滚动时调用判断函数，因此<strong>需要进行防抖优化</strong></p>
<p>  首先，用一幅图解释浏览器的宽高：</p>
<p><img src="https://gitee.com/ylea/imagehost/raw/master/img/Dimensions-client.png" srcset="/img/loading.gif" alt="Dimensions-client" /></p>
<h2 id="方法1clientheight-scrolltop-和-offsettop"><a class="markdownIt-Anchor" href="#方法1clientheight-scrolltop-和-offsettop"></a> 方法1：clientHeight、scrollTop 和 offsetTop</h2>
<img src="https://gitee.com/ylea/imagehost/raw/master/img/image-20210224181307061.png" srcset="/img/loading.gif" alt="image-20210224181307061" style="zoom: 67%;" />
<p>  由上图可知，页面的高度为 <code>clientHeight</code>，若有滚轮的话，<code>scrollTop</code> 会是当前页面滚动的高度，而 <code>offsetTop</code> 会是元素距离页面顶部的高度。</p>
<p>  因此当 <code>scrollTop + clientHeight = offsetTop</code> 时，就说明元素即将进入可视区域，图片需要进行请求了。</p>
<blockquote>
<p><strong><code>HTMLElement.offsetTop</code></strong> 为只读属性，它返回当前元素相对于其 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/offsetParent"><code>offsetParent</code></a> 元素的顶部内边距的距离。</p>
<p><strong><code>Element.scrollTop</code></strong> 属性可以获取或设置一个元素的内容垂直滚动的像素数。</p>
<p><strong><code>HTMLElement.clientHeight</code></strong> 对于没有定义CSS或者内联布局盒子的元素为0，否则，它是元素内部的高度(单位像素)，包含内边距，但<strong>不包括</strong>水平滚动条、边框和外边距。</p>
<p><code>clientHeight</code> 可以通过 CSS <code>height</code> + CSS <code>padding</code> - 水平滚动条高度 (如果存在)来计算.</p>
<p><code>clientHeight</code> 可以使用 <code>window.innerHeight</code> 来替代 ，不过若有水平滚动条，<code>innerHeight</code> 也会包括滚动条高度</p>
<p><code>document.documentElement</code> 总是会返回一个 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/html"><code>html</code></a> 元素，且它一定是该文档的根元素。</p>
</blockquote>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTop</span>(<span class="hljs-params">e</span>) </span>&#123;
    <span class="hljs-keyword">let</span> T = e.offsetTop;
    <span class="hljs-keyword">while</span> (e = e.offsetParent) &#123;
        T += e.offsetTop;
    &#125;

    <span class="hljs-keyword">return</span> T;
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lazyLoad</span>(<span class="hljs-params">imgs</span>) </span>&#123;
    <span class="hljs-comment">// 视口高度</span>
    <span class="hljs-keyword">let</span> viewHeight = <span class="hljs-built_in">document</span>.documentElement.clientHeight;
    <span class="hljs-comment">// 滚动条拉伸的高度</span>
    <span class="hljs-keyword">let</span> scrollTop = <span class="hljs-built_in">document</span>.documentElement.scrollTop  || <span class="hljs-built_in">document</span>.body.scrollTop ;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = count; i &lt; imgs.length; ++i) &#123;
        <span class="hljs-keyword">if</span> (getTop(imgs[i]) &lt;= viewHeight + scrollTop) &#123;
            <span class="hljs-keyword">if</span> (!imgs[i].getAttribute(<span class="hljs-string">&#x27;src&#x27;</span>)) &#123;
                imgs[i].src = imgs[i].getAttribute(<span class="hljs-string">&#x27;data-src&#x27;</span>);
                count++;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<h2 id="方法2-使用-getboundingclientrect-方法"><a class="markdownIt-Anchor" href="#方法2-使用-getboundingclientrect-方法"></a> 方法2： 使用 getBoundingClientRect 方法</h2>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect">MDN文档</a></p>
<blockquote>
<p><strong><code>Element.getBoundingClientRect()</code></strong>  方法返回元素的大小及其相对于视口的位置。</p>
<p>如果是标准盒子模型，元素的尺寸等于<code>width/height</code> + <code>padding</code> + <code>border-width</code>的总和。如果<code>box-sizing: border-box</code>，元素的的尺寸等于 <code>width/height</code>。</p>
<p>返回的结果是包含完整元素的最小矩形，并且拥有<code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code>, <code>x</code>, <code>y</code>, <code>width</code>, 和 <code>height</code>这几个以像素为单位的只读属性用于描述整个边框。除了<code>width</code> 和 <code>height</code> 以外的属性是相对于<strong>视图窗口的左上角</strong>来计算的。</p>
</blockquote>
<img src="https://gitee.com/ylea/imagehost/raw/master/img/rect.png" srcset="/img/loading.gif" alt="rect" style="zoom: 50%;" />
<p>  因此 DOM 元素的 <code>getBoundingClientReact().top</code> 属性就能直接判断图片是否出现在了当前视口中。</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lazyLoad</span>(<span class="hljs-params">imgs</span>) </span>&#123;
    <span class="hljs-keyword">let</span> viewHeight = <span class="hljs-built_in">document</span>.documentElement.clientHeight;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = count; i &lt; imgs.length; ++i) &#123;
        <span class="hljs-keyword">if</span> (imgs[i].getBoundingClientRect().top &lt;= viewHeight) &#123;
            <span class="hljs-keyword">if</span> (!imgs[i].getAttribute(<span class="hljs-string">&#x27;src&#x27;</span>)) &#123;
                imgs[i].src = imgs[i].getAttribute(<span class="hljs-string">&#x27;data-src&#x27;</span>);
                count++;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<h2 id="方法3intersectionobserver"><a class="markdownIt-Anchor" href="#方法3intersectionobserver"></a> 方法3：IntersectionObserver</h2>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver">MDN文档</a></p>
<p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html">阮一峰 IntersectionObserver 教程</a></p>
<p>  <code>IntersectionObserver</code> 浏览器内置的 API，实现了监听 window 的 <code>scroll</code> 事件、<code>判断是否在视口中</code> 以及 <code>节流</code> 三大功能。该 API 需要 polyfill。</p>
<p>下面的代码中</p>
<ul>
<li>传入的回调函数的 <code>changes</code> 是<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserverEntry"><code>IntersectionObserverEntry</code></a> 对象的数组，数组中的每个对象的 <code>target</code> 是实际可视情况发生改变的 <code>dom</code> 元素</li>
<li><code>getElementsByTagName</code> 返回的是一个 <code>HTMLCollection</code>，因此需要使用 <code>Array.from</code> 来转换一下</li>
</ul>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> imgs = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;img&#x27;</span>);

<span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> IntersectionObserver(<span class="hljs-function"><span class="hljs-params">changes</span> =&gt;</span> &#123;
    changes.forEach(<span class="hljs-function"><span class="hljs-params">dom</span> =&gt;</span> &#123;
        <span class="hljs-keyword">if</span> (dom.isIntersecting) &#123;
            dom.target.src = dom.target.getAttribute(<span class="hljs-string">&#x27;data-src&#x27;</span>);
            <span class="hljs-comment">// 当加载后就从监视器中移除</span>
            observer.unobserve(dom.target);
        &#125;
    &#125;);
&#125;);

<span class="hljs-built_in">Array</span>.from(imgs).forEach(<span class="hljs-function"><span class="hljs-params">dom</span> =&gt;</span> observer.observe(dom));</code></pre>
<h2 id="方法4使用开源库"><a class="markdownIt-Anchor" href="#方法4使用开源库"></a> 方法4：使用开源库</h2>
<p><a target="_blank" rel="noopener" href="https://github.com/aFarkas/lazysizes">https://github.com/aFarkas/lazysizes</a></p>
<h2 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h2>
<p>  上面的前三种方法，前两种方法是有一定缺陷的，它们只比较了距离页面顶端的距离，因此若刷新浏览器时，所处位置的上方所有可见和不可见的图片都会被加载出来，因此并不是完备的懒加载。</p>
<p>  不过最后一种使用 <code>IntersectionObserver</code> 的方法则不会有这个问题，它唯一的弱势是观察器在进程中的优先级会比较低。</p>
<h2 id="实例"><a class="markdownIt-Anchor" href="#实例"></a> 实例</h2>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>
        body &#123;
            height: 3000px;
        &#125;
        img &#123;
            width: 500px;
            height: 500px;
            object-fit: scale-down;
        &#125;
    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;./imgs/1.png&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;./imgs/2.png&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;./imgs/3.png&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;./imgs/4.png&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;./imgs/5.png&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;./imgs/6.png&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;./imgs/7.png&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;./imgs/8.png&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
<span class="javascript">    <span class="hljs-comment">// 方式1：clientHeight、scrollTop、offsetTop</span></span>
<span class="javascript">    <span class="hljs-keyword">let</span> imgs = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;img&#x27;</span>), count = <span class="hljs-number">0</span>;</span>

<span class="javascript">    <span class="hljs-comment">// offsetTop 是元素与 offsetParent 的距离，循环获取直到达到页面顶部</span></span>
<span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTop</span>(<span class="hljs-params">e</span>) </span>&#123;</span>
<span class="javascript">        <span class="hljs-keyword">let</span> T = e.offsetTop;</span>
<span class="javascript">        <span class="hljs-keyword">while</span> (e = e.offsetParent) &#123;</span>
            T += e.offsetTop;
        &#125;

<span class="javascript">        <span class="hljs-keyword">return</span> T;</span>
    &#125;

<span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lazyLoad</span>(<span class="hljs-params">imgs</span>) </span>&#123;</span>
<span class="javascript">        <span class="hljs-comment">// 视口高度</span></span>
<span class="javascript">        <span class="hljs-keyword">let</span> viewHeight = <span class="hljs-built_in">document</span>.documentElement.clientHeight;</span>
<span class="javascript">        <span class="hljs-comment">// 滚动条拉伸的高度</span></span>
<span class="javascript">        <span class="hljs-keyword">let</span> scrollTop = <span class="hljs-built_in">document</span>.documentElement.scrollTop  || <span class="hljs-built_in">document</span>.body.scrollTop ;</span>

<span class="javascript">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = count; i &lt; imgs.length; ++i) &#123;</span>
            if (getTop(imgs[i]) &lt;= viewHeight + scrollTop) &#123;
<span class="javascript">                <span class="hljs-keyword">if</span> (!imgs[i].getAttribute(<span class="hljs-string">&#x27;src&#x27;</span>)) &#123;</span>
<span class="javascript">                    imgs[i].src = imgs[i].getAttribute(<span class="hljs-string">&#x27;data-src&#x27;</span>);</span>
                    count++;
                &#125;
            &#125;
        &#125;
    &#125;

<span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, wait, ...args</span>) </span>&#123;</span>
<span class="javascript">        <span class="hljs-keyword">let</span> activeTime = <span class="hljs-number">0</span>;</span>

<span class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span>
<span class="javascript">            <span class="hljs-keyword">let</span> current = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();</span>
            if (wait &lt;= current - activeTime) &#123;
<span class="javascript">                fn.apply(<span class="hljs-built_in">this</span>, args.concat(...arguments));</span>
                activeTime = current;
            &#125;
        &#125;;
    &#125;
<span class="javascript">    <span class="hljs-comment">// 首次加载</span></span>
<span class="javascript">    <span class="hljs-built_in">window</span>.onload = lazyLoad(imgs);</span>
<span class="javascript">    <span class="hljs-built_in">window</span>.onscroll = throttle(lazyLoad, <span class="hljs-number">100</span>, imgs);</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/">前端面试题</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/JS%E6%89%8B%E6%92%95%E7%B3%BB%E5%88%97/">JS手撕系列</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/12/19/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87-Offer-51-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">剑指 Offer 51. 数组中的逆序对</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/12/09/JS/Set%E3%80%81Map%E3%80%81%E5%92%8CWeakSet%E3%80%81WeakMap/">
                        <span class="hidden-mobile">Set、Map、和WeakSet、WeakMap</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <script type="text/javascript">
    function loadUtterances() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'yleave/yleave.github.io');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    }
    waitElementVisible('comments', loadUtterances)
  </script>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->

  <div class="col-lg-7 mx-auto nopadding-md">
    <div class="container custom post-content mx-auto">
      <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">
    </div>
  </div>


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  
    <!-- APlayer 音乐播放器 -->
    <div id="aplayer"></div>
    <script defer src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.js" ></script>
<link  rel="stylesheet" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" />
<script type="text/javascript">
  var oldLoadAp = window.onload;
  window.onload = function () {
    oldLoadAp && oldLoadAp();

    new APlayer({
      container: document.getElementById('aplayer'),
      fixed: true,
      autoplay: 'false' === 'true',
      loop: 'all',
      order: 'list',
      theme: '#b7daff',
      preload: 'none',
      audio: [{"name":"River Flows in You","artist":"Yiruma","url":"https://cdn.jsdelivr.net/gh/yleave/blogmusic/music/Yiruma - River Flows in You.mp3","cover":"https://gitee.com/ylea/imagehost/raw/master/img/River Flows in You.png"},{"name":"もしもの日","artist":"タニザワトモフミ","url":"https://cdn.jsdelivr.net/gh/yleave/blogmusic/music/タニザワトモフミ - もしもの日.mp3","cover":"https://gitee.com/ylea/imagehost/raw/master/img/もしもの日.png"},{"name":"アイロニ","artist":"4円","url":"https://cdn.jsdelivr.net/gh/yleave/blogmusic/music/4円 - アイロニ.mp3","cover":"https://gitee.com/ylea/imagehost/raw/master/img/アイロニ.jpg"},{"name":"Adagio for Summer Wind","artist":"清水準一","url":"https://cdn.jsdelivr.net/gh/yleave/blogmusic/music/清水準一 - Adagio for Summer Wind.mp3","cover":"https://gitee.com/ylea/imagehost/raw/master/img/Adagio for Summer Wind.jpg"},{"name":"平凡之路","artist":"朴树","url":"https://cdn.jsdelivr.net/gh/yleave/blogmusic/music/朴树 - 平凡之路.mp3","cover":"https://gitee.com/ylea/imagehost/raw/master/img/平凡之路.jpg"}]
    });
  }
</script>

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <p id="hitokoto">:D 获取中...</p>
    <script>
      fetch('https://v1.hitokoto.cn', {'c': 'd'})
        .then(response => response.json())
        .then(data => {
          const hitokoto = document.getElementById('hitokoto')
          hitokoto.innerText = data.hitokoto
          })
          .catch(console.error)
    </script>

    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>

    <div>
      <span id="timeDate">载入天数...</span>
      <span id="times">载入时分秒...</span>
      <script>
      var now = new Date();
      function createtime(){
          var grt= new Date("08/14/2020 00:00:00");//此处修改你的建站时间或者网站上线时间
          now.setTime(now.getTime()+250);
          days = (now - grt ) / 1000 / 60 / 60 / 24;
          dnum = Math.floor(days);
          hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum);
          hnum = Math.floor(hours);
          if(String(hnum).length ==1 ){
              hnum = "0" + hnum;
          }
          minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
          mnum = Math.floor(minutes);
          if(String(mnum).length ==1 ){
                    mnum = "0" + mnum;
          }
          seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
          snum = Math.round(seconds);
          if(String(snum).length ==1 ){
                    snum = "0" + snum;
          }
          document.getElementById("timeDate").innerHTML = "本站安全运行&nbsp"+dnum+"&nbsp天";
          document.getElementById("times").innerHTML = hnum + "&nbsp小时&nbsp" + mnum + "&nbsp分&nbsp" + snum + "&nbsp秒";
      }
      setInterval("createtime()",250);
      </script>
    </div>

    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "手撕JS代码1&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 100,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>





  

  
    <!-- KaTeX -->
    <link  rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.11.1/katex.min.css" />
  



  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  











  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?a36acf7cd4515f99cd4742abbfcf11c3";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





</body>
</html>
