<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ThreeJS快照</title>
    <link href="/2020/09/20/WebGL/ThreeJS/ThreeJS%E6%88%AA%E5%9B%BE/"/>
    <url>/2020/09/20/WebGL/ThreeJS/ThreeJS%E6%88%AA%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;假设有一个需求，需要获取 Three 场景的一张快照，然后再将其显示在屏幕上。</p><h1 id="1-获取快照"><a href="#1-获取快照" class="headerlink" title="1. 获取快照"></a>1. 获取快照</h1><p>&emsp;&emsp;对于这个需求，一种方法是在创建 <code>WebGLRenderer</code> 时设置一个 <code>preserveDrawingBuffer</code> 参数为 <code>true</code>，然后再调用场景中的 <code>canvas</code> 的 <code>toDataURL</code> 方法来获取某一帧的 <code>base64</code> 格式的图像数据：</p><pre><code class="hljs js">renderer = <span class="hljs-keyword">new</span> WebGLRenderer(&#123;    preserveDrawingBuffer :<span class="hljs-literal">true</span> &#125;);<span class="hljs-keyword">const</span> image = <span class="hljs-keyword">new</span> Image();image.src = renderer.domElement.toDataURL();</code></pre><p>&emsp;&emsp;而 <code>preserveDrawingBuffer </code> 参数的含义是：是否保留缓直到手动清除或被覆盖。若设为 <code>true</code>，在任意时刻，前一帧的缓存图像不会被清除，因此可以获取到任意一刻的截图，若未设置的话，获取的截图可能就会是一张空白的图片。不过，这有一个明显的副作用，那就是会更加的消耗性能和占用内存。因此<strong>不推荐</strong>这种方式。</p><p>&emsp;&emsp;<strong>另一种方式</strong>就是在获取截图之前先再渲染一下场景，这样就不会因为缓存清空而导致截屏空白了：</p><pre><code class="hljs js">renderer.clear();renderer.render(scene, camera);<span class="hljs-keyword">const</span> image = <span class="hljs-keyword">new</span> Image();image.src = canvas.toDataURL(<span class="hljs-string">&quot;image/png&quot;</span>);</code></pre><h1 id="2-在屏幕上显示出来"><a href="#2-在屏幕上显示出来" class="headerlink" title="2.在屏幕上显示出来"></a>2.在屏幕上显示出来</h1><p>&emsp;&emsp;既然我们已经能够获取到正确的快照了，那么要将其显示在屏幕上，我们可以再创建一个新的 <code>canvas</code>，然后将获取的快照使用这个新的 <code>canvas</code> 加载出来就行了，代码如下：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> canvas = renderer.domElement;renderer.render(scene, camera);<span class="hljs-keyword">const</span> image = <span class="hljs-keyword">new</span> Image();<span class="hljs-keyword">const</span> base64 = canvas.toDataURL(<span class="hljs-string">&quot;image/png&quot;</span>);image.src = base64;<span class="hljs-keyword">const</span> mycanvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myImageEditCanvas&#x27;</span>);mycanvas.width = canvas.width;mycanvas.height = canvas.height;<span class="hljs-keyword">const</span> ctx = mycanvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);image.onload = <span class="hljs-function">() =&gt;</span> &#123;    ctx.drawImage(image, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);&#125;;</code></pre><p>&emsp;&emsp;使用 <code>canvas</code> 载入图像使用了 <code>drawImage</code> 方法，它的第二第三个参数的意思是从源图像的哪个位置开始载入，要载入整张图像，填入 <code>0</code> 即可。</p><p>&emsp;&emsp;<code>drawImage</code> 详细一些的介绍可看：<a href="https://yleave.top/2020/09/20/HTML/canvas%E6%93%8D%E4%BD%9C%E5%9B%BE%E5%83%8F/">drawImage</a></p>]]></content>
    
    
    <categories>
      
      <category>WebGL</category>
      
      <category>ThreeJS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>canvas</tag>
      
      <tag>threeJS</tag>
      
      <tag>快照</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>canvas操作图像</title>
    <link href="/2020/09/20/HTML/canvas%E6%93%8D%E4%BD%9C%E5%9B%BE%E5%83%8F/"/>
    <url>/2020/09/20/HTML/canvas%E6%93%8D%E4%BD%9C%E5%9B%BE%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="canvas-获取截图"><a href="#canvas-获取截图" class="headerlink" title="canvas 获取截图"></a>canvas 获取截图</h1><p>&emsp;&emsp;具体是使用 <code>canvas </code> 的 <code>toDataURL</code> 方法：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> image = <span class="hljs-keyword">new</span> Image();image.src = canvas.toDataURL(<span class="hljs-string">&quot;image/png&quot;</span>);</code></pre><p>&emsp;&emsp;<code>toDataURL</code> 的第一个参数是图像类型，默认是 <code>image/png</code>，也可设置为 <code>image/jpeg</code> 。</p><p>&emsp;&emsp;详细可看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLCanvasElement/toDataURL">MDN</a> 的介绍。</p><p>&emsp;&emsp;若想将获取的图像下载下来：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> imgUri = canvas.toDataURL(<span class="hljs-string">&quot;image/png&quot;</span>).replace(<span class="hljs-string">&quot;image/png&quot;</span>, <span class="hljs-string">&quot;image/octet-stream&quot;</span>);<span class="hljs-built_in">window</span>.location.href= imgUri; <span class="hljs-comment">// 下载图片</span></code></pre><h1 id="canvas-载入图像"><a href="#canvas-载入图像" class="headerlink" title="canvas 载入图像"></a>canvas 载入图像</h1><p>&emsp;&emsp;<code>canvas</code> 载入图像有两种方式。一种是使用 <code>drawImage</code> 方法载入任何 <code>canvas</code> 支持的图像类型，另一种是使用 <code>putImageData</code> 方法或是通过循环遍历的方式根据像素值加载图像。</p><h2 id="使用-drawImage-载入图像"><a href="#使用-drawImage-载入图像" class="headerlink" title="使用 drawImage 载入图像"></a>使用 drawImage 载入图像</h2><p>&emsp;&emsp;<code>canvas</code> 支持的图像类型有：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CSSImageValue">CSSImageValue</a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLImageElement">HTMLImageElement</a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/SVGImageElement">SVGImageElement</a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLVideoElement">HTMLVideoElement</a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLCanvasElement">HTMLCanvasElement</a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ImageBitmap">ImageBitmap</a> 或者<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/OffscreenCanvas">OffscreenCanvas</a>。</p><p>&emsp;&emsp;以最常见的 <code>HTMLImageElement</code> 类型的图像为例，也就是使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLImageElement/Image">Image</a> 方法或是 <code>&lt;img&gt;</code> 标签创建的对象：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> image = <span class="hljs-keyword">new</span> Image();image.src = <span class="hljs-string">&#x27;picture.jpg&#x27;</span>;<span class="hljs-comment">// or </span><span class="hljs-comment">// &lt;img id=&quot;picture&quot; src=&quot;...&quot; width=&quot;300&quot; height=&quot;227&quot;&gt;</span><span class="hljs-keyword">var</span> image = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;picture&#x27;</span>);</code></pre><p>&emsp;&emsp;然后，就能使用 <code>drawImage</code> 方法载入这个对象：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;canvas&quot;</span>);<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&quot;2d&quot;</span>);ctx.drawImage(image, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);</code></pre><p>&emsp;&emsp;对于 <code>new Image</code> 方式创建的 <code>image</code> ，需要等到图片加载完成后才能载入：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> image = <span class="hljs-keyword">new</span> Image();image.src = <span class="hljs-string">&#x27;picture.jpg&#x27;</span>;image.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    ctx.drawImage(image, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);&#125;;</code></pre><p>&emsp;&emsp;<code>drawImage</code> 方法有多个参数，除了第一个 <code>imageSource</code> 是必须的，其他参数都是可选的，其他参数设置了源图像和目标图像的起始位置和截取范围：</p><p>&emsp;&emsp;<code>drawImage(image, source_x, source_y, source_width, source_height, x, y, width, heigh)</code></p><p>&emsp;&emsp;因此，<code>drawImage</code> 方法不仅能够普通的载入图像，还能够在载入图像的过程中对图像进行裁剪和缩放。</p><p>&emsp;&emsp;具体可参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/drawImage">MDN1</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Using_images">MDN2</a></p><h2 id="使用-putImageData-载入图像"><a href="#使用-putImageData-载入图像" class="headerlink" title="使用 putImageData 载入图像"></a>使用 putImageData 载入图像</h2><p>&emsp;&emsp;首先，使用该方法，我们需要一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ImageData">ImageData</a> 的对象。这个对象中存储着 <code>canvas</code> 对象真实的像素数据。</p><p><code>ImageData</code> 对象包含以下几个<strong>只读</strong>属性：</p><ul><li><code>width</code> : 图片宽度，单位是像素</li><li><code>height</code> : 图片高度，单位是像素</li><li><code>data </code>: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray">Uint8ClampedArray</a>类型的一维数组，包含着 <strong>RGBA</strong> 格式的整型数据，范围在0至255之间（包括255）。</li></ul><p>&emsp;&emsp;<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray">Uint8ClampedArray</a> 包含高度 × 宽度 × 4 bytes 数据，索引值从 <code>0</code> 到 <code>(高度 × 宽度 × 4 ) - 1</code></p><p>&emsp;&emsp;下面将图像从一个 <code>canvas</code> 复制到一个新的 <code>canvas</code>，涉及两个函数：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/getImageData">getImageData</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/putImageData">putImageData</a></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;canvas&quot;</span>);<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&quot;2d&quot;</span>);<span class="hljs-keyword">var</span> imgData = ctx.getImageData(left, top, width, height);<span class="hljs-keyword">var</span> newCvs = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;new_canvas&quot;</span>);<span class="hljs-keyword">var</span> cewCtx = newCvs.getContext(<span class="hljs-string">&quot;2d&quot;</span>);cewCtx.putImageData(imgData, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);</code></pre><p>&emsp;&emsp;若是已知图像的像素值，也可使用循环遍历的方式来载入图像：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;canvas&quot;</span>);<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&quot;2d&quot;</span>);<span class="hljs-comment">// 创建一个空的 ImageData 对象</span><span class="hljs-keyword">var</span> img = context.createImageData(width, height);<span class="hljs-keyword">var</span> data = img.data;<span class="hljs-comment">// 按 RGBA 格式存储数据</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; height; i++) &#123;    <span class="hljs-keyword">var</span> l = height - <span class="hljs-number">1</span> - i;    <span class="hljs-keyword">var</span> s1 = l * width * <span class="hljs-number">4</span>;    <span class="hljs-keyword">var</span> s2 = i * width * <span class="hljs-number">4</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; width * <span class="hljs-number">4</span>; j++) &#123;        data[s1 + j] = imageData[s2 + j]    &#125;&#125;context.putImageData(img, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);</code></pre><p>&emsp;&emsp;更多详细内容可参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas">像素操作</a></p>]]></content>
    
    
    <categories>
      
      <category>HTML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>canvas</tag>
      
      <tag>js截图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 47. 全排列 II</title>
    <link href="/2020/09/19/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/47-%E5%85%A8%E6%8E%92%E5%88%97-II/"/>
    <url>/2020/09/19/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/47-%E5%85%A8%E6%8E%92%E5%88%97-II/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/permutations-ii/">https://leetcode-cn.com/problems/permutations-ii/</a></p><p>难度：中等</p><hr><p>&emsp;&emsp;给定一个可<strong>包含重复数字</strong>的序列，返回所有不重复的全排列。</p><p><strong>示例:</strong></p><p>输入: <code>[1,1,2]</code></p><p>输出:</p><pre><code class="hljs json">[  [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>],  [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]]</code></pre><h2 id="解法1：回溯-剪枝"><a href="#解法1：回溯-剪枝" class="headerlink" title="解法1：回溯 + 剪枝"></a>解法1：回溯 + 剪枝</h2><p>&emsp;&emsp;这题求全排列的步骤与 <a href="https://yleave.top/2020/09/17/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/46-%E5%85%A8%E6%8E%92%E5%88%97/">46.全排列</a> 这题是一样的，区别就是 <code>46.</code> 这题给的数字序列是不含重复的数字，而本题则包含重复数字。</p><p>&emsp;&emsp;这样的话，我们只需要在原先的基础上对其进行剪枝即可，将造成重复组合的情况去除。</p><p>&emsp;&emsp;考虑一组序列：<code>[2, 2, 1, 1]</code>，标记一下以便区分：<code>[2, 2&#39;, 1, 1&#39;]</code>，对于这组序列，按照 <code>46.</code> 的思路，会造成重复的情况有在固定索引 <code>0</code> 处的值时，序列中的两个 <code>2</code> 和两个 <code>1</code> 都会造成固定值重复，即 <code>[2, 2&#39;, 1, 1&#39;]</code> 、<code>[2&#39;, 2, 1, 1&#39;]</code>，<code>[1, 2&#39;, 2, 1&#39;]</code> 和 <code>[1&#39;, 2&#39;, 1, 2]</code> ，这样，由于第一个固定的数字就重复，后面的所有组合也都是重复的。</p><p>&emsp;&emsp;因此，我们要做的就是<strong>让每个索引处固定的值不再重复！</strong></p><p>&emsp;&emsp;要做到这样，我们可以借用一个 <code>map</code>，对于每个固定的索引，当一个值是第一次出现时，将其记录在 <code>map</code> 中，而若是遇到了 <code>map</code> 中已经存的值，则说明这个值已经固定过了，跳过它，这样就完成了全排列过程中的去重要求。</p><p>&emsp;&emsp;当然，还有一个很耿直的做法就是：还是像 <code>46.</code> 一样计算序列的组合，只在保存每个组合结果时，使用一个 <code>map</code> 记录当前组合是否保存过，若未保存过，则记录到结果数组中。。。</p><p>剪枝的 JS 代码：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> permuteUnique = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = [];    <span class="hljs-keyword">let</span> len = nums.length;    <span class="hljs-keyword">const</span> swap = <span class="hljs-function">(<span class="hljs-params">i, j</span>) =&gt;</span> &#123;        <span class="hljs-keyword">let</span> tmp = nums[i];        nums[i] = nums[j];        nums[j] = tmp;    &#125;;    <span class="hljs-keyword">const</span> helper = <span class="hljs-function"><span class="hljs-params">index</span> =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (index === len) &#123;            res.push(nums.slice());            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">let</span> map = [];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = index; i &lt; len; i++) &#123;            <span class="hljs-keyword">if</span> (map[nums[i]]) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            map[nums[i]] = <span class="hljs-number">1</span>;            swap(index, i);            helper(index+<span class="hljs-number">1</span>);            swap(index, i);        &#125;    &#125;;    helper(<span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> res;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>解答</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 46. 全排列</title>
    <link href="/2020/09/19/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/46-%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <url>/2020/09/19/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/46-%E5%85%A8%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/permutations/">https://leetcode-cn.com/problems/permutations/</a></p><p>难度：中等</p><hr><p>&emsp;&emsp;给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p><p><strong>示例:</strong></p><p>输入: <code>[1,2,3]</code></p><p>输出:</p><pre><code class="hljs json">[  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],  [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>],  [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],  [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>],  [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],  [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]]</code></pre><h2 id="解法1：回溯法"><a href="#解法1：回溯法" class="headerlink" title="解法1：回溯法"></a>解法1：回溯法</h2><p>&emsp;&emsp;对于一组<strong>没有重复</strong>数字的序列，要求它的全排列，假设这个序列是 <code>[1, 2, 3]</code>，若用手算，我们是这样算的：</p><ol><li><p>固定索引 <code>0</code> 处的数字 <code>1</code> ，剩下的就是 <code>[2, 3]</code>，两个数字的组合有 <code>[2, 3]</code> 和 <code>[3, 2]</code> ，再加上 <code>1</code> ，就得到了组合 <code>[1, 2, 3]</code> 和 <code>[1, 3, 2]</code>。（其实对于如 <code>[2, 3]</code> 这样的未固定的数字，我们也是像固定 <code>1</code> 一样，先固定住索引 <code>1</code> 处的数字 <code>2</code> ，剩下一个 <code>3</code>，得到组合后再回溯回去，换一个值固定在索引 <code>1</code> 处，即 <code>[3, 2]</code> … ）。</p></li><li><p>现在再改变索引 <code>0</code> 处的数字为 <code>2</code>，即 <code>1 </code> 与 <code>2</code> 互换位置，那么剩下的数字就是 <code>[1, 3]</code> ，组合有 <code>[1, 3]</code> 和 <code>[3, 1]</code>，再加上固定的 <code>2</code> ，就得到了 <code>[2, 1, 3]</code> 和 <code>[2, 3, 1]</code>。</p></li><li><p>同理，恢复到初始的 <code>[1, 2, 3]</code>，再改变索引 <code>0</code> 的值为 <code>3</code>，剩下了 <code>[2, 1]</code> ，组合有 <code>[2, 1]</code> 和 <code>[1, 2]</code>，加上 <code>3</code> ，得到的组合就是 <code>[3, 2, 1]</code> 和 <code>[3, 1, 2]</code>。</p></li></ol><p>&emsp;&emsp;整理一下我们的计算过程，也就是对于每个索引 <code>0, 1,...,n</code> ，我们从索引 <code>0</code>  开始，固定住每一位，对于剩下未固定的数字再进行全排列，这样，每次固定到索引末尾时，我们就获得了一个组合，对每个索引取所有的值都固定一遍，我们就得到了所有数字的全排列了！</p><p>&emsp;&emsp;（可能还是有些没讲清楚，请看代码：</p><p><strong>JS 代码：</strong></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> permute = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = [];    <span class="hljs-keyword">let</span> len = nums.length;    <span class="hljs-keyword">const</span> swap = <span class="hljs-function">(<span class="hljs-params">i, j</span>) =&gt;</span> &#123;        <span class="hljs-keyword">let</span> tmp = nums[i];        nums[i] = nums[j];        nums[j] = tmp;    &#125;;      <span class="hljs-keyword">const</span> helper = <span class="hljs-function"><span class="hljs-params">index</span> =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (index === len) &#123; <span class="hljs-comment">// 当最后一个数字也被固定后，就得到了一个组合</span>            res.push(nums.slice());            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 对于每个索引 index，取所有的值都固定一次，每固定一次后 index+1 ,固定下一位</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = index; i &lt; len; i++) &#123;            swap(index, i);            helper(index+<span class="hljs-number">1</span>);            swap(index, i);        &#125;    &#125;;    helper(<span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> res;&#125;;</code></pre><p><strong>CPP 代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">permute</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt; res;        helper(res,nums,<span class="hljs-number">0</span>,nums.size());        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt; &amp;res,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> n)</span></span>&#123;        <span class="hljs-keyword">if</span>(b == n)&#123;            res.push_back(nums);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = b; i &lt; n; i++)&#123;            swap(nums[i],nums[b]);            helper(res,nums,b + <span class="hljs-number">1</span>,n);            swap(nums[b],nums[i]);        &#125;    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>解答</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>github+picGo+jsDelivr构建图床</title>
    <link href="/2020/09/19/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/github-picGo-jsDelivr%E6%9E%84%E5%BB%BA%E5%9B%BE%E5%BA%8A/"/>
    <url>/2020/09/19/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/github-picGo-jsDelivr%E6%9E%84%E5%BB%BA%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;不论是写博客还是记笔记，图床的选择很重要。且对于一个博客平台来说，网站中的图片、视频以及音频等资源的下载速度直接影响到了整个博客网站的加载和体验，这点我深有体会。</p><p>&emsp;&emsp;就我个人来说，最开始，我在博客中有加入音乐播放器，音频和部分图片是直接存储在博客项目里的，而文章中的一些图片则使用 <strong>SM.MS 图床</strong>存储，然后每次打开网站时都要等很久网站的资源才能加载出来，开始我还认为是因为博客是部署在 githubPages 上导致的网站访问缓慢，也试了一些方法如 <a href="https://yleave.top/2020/09/12/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E4%BD%BF%E7%94%A8Netlify%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/">使用Netlify部署博客</a> 来尝试加速网站的访问，然并卵…</p><p>&emsp;&emsp;直到有一天我受不了图片的上传和加载速度的缓慢，就尝试了下经常在博客搭建教程中看到的 <strong>七牛云图床</strong>。结果确实很香~，我不仅将图片存储在了七牛云上，并且将音频也一并存储了。重新部署后网站的访问速度有了肉眼可见的提升。直到这时，我才直到原来之前<strong>访问速度慢的原因不止是部署服务器的问题，和网站中的静态资源也有很大的关系！</strong> </p><p>&emsp;&emsp;使用 七牛云图床 前后对比：</p><p><img src="https://i.loli.net/2020/09/18/IcYpjFWJnC6Kmft.png" alt="img" style="zoom: 40%;" /> <img src="https://i.loli.net/2020/09/18/1GJKUjIVdBLrTno.png" alt="image-20200918152333510" style="zoom:40%;" /></p><p>&emsp;&emsp;效果确实好了很多。</p><h2 id="七牛云图床吐槽"><a href="#七牛云图床吐槽" class="headerlink" title="七牛云图床吐槽"></a>七牛云图床吐槽</h2><p>&emsp;&emsp;==不过！！！==</p><p>&emsp;&emsp;虽然七牛云有提供免费的 10G 空间，但是如果想要真正使用七牛云图床的完整服务的话，你的网站<strong>需要备案</strong>，也就是说需要自己租一个服务器，在上面部署网站（掏了下口袋，空空的，想想还是算了吧）。</p><img src="https://i.loli.net/2020/09/18/Ei4Smw3g5lD8M2I.jpg" alt="穷" style="zoom:50%;" /><p>&emsp;&emsp;否则，你只能得到一个<strong>临时域名</strong>，也就是你你资源路径的前面部分，如 <code>http://xxxxx.hd-bkt.clouddn.com/1.jpg</code> 。然后这个临时域名会在 30 天之后回收！！这意味着 30 天后你网站中所有使用七牛云存储的静态资源都不能正常访问了！！</p><img src="https://i.loli.net/2020/09/18/meyl9OXUJAZu2xr.png" alt="image-20200918153307205" style="zoom:80%;" /><p>&emsp;&emsp;其次，七牛云上的临时域名还是 <code>HTTP</code> 的，就算使用了备案的域名绑定，想使用 <code>HTTPS</code> 的域名也需要交费（又掏了掏口袋）。</p><p>&emsp;&emsp;你的网站就会变成这样（看着是不是很不爽）</p><img src="https://i.loli.net/2020/09/18/9jygoJbrIdp4q7l.png" alt="image-20200918154227852" style="zoom:80%;" /><p>&emsp;&emsp;因此，果断抛弃七牛云，尝试使用 github 图床 + jsDelivr CDN加速访问！</p><p>&emsp;&emsp;好了，说了这么多废话，下面是配置过程。</p><h1 id="配置-github-图床"><a href="#配置-github-图床" class="headerlink" title="配置 github 图床"></a>配置 github 图床</h1><p>&emsp;&emsp;首先，新建一个 github 仓库：</p><img src="https://i.loli.net/2020/09/18/uk7X3qAhBJTIzNQ.png" alt="image-20200918154812090" style="zoom: 50%;" /><p>&emsp;&emsp;依次点击 Settings -&gt; DeveloperSettings -&gt; Personal access tokens -&gt;  Generate new token</p><p><img src="https://i.loli.net/2020/09/18/ZzsiVL1nSIbkKlH.png" alt="image-20200918155050224" style="zoom: 67%;" /> <img src="https://i.loli.net/2020/09/18/GKp6XhkMWPgnaoT.png" alt="image-20200918155149215" style="zoom:50%;" /> <img src="https://i.loli.net/2020/09/18/A6iyYX3ObQLZraI.png" alt="image-20200918155324860" style="zoom:50%;" /></p><p>&emsp;&emsp;填写描述，再勾选 repo，最后拉到底点击 Generate token。</p><img src="https://i.loli.net/2020/09/18/w2dSAbWyuz6QXF8.png" alt="image-20200918155537060" style="zoom:67%;" /> <img src="https://i.loli.net/2020/09/18/raUQvJ4lgGb7R1y.png" alt="image-20200918155736272" style="zoom:50%;" /> <h1 id="PicGo-配置"><a href="#PicGo-配置" class="headerlink" title="PicGo 配置"></a>PicGo 配置</h1><p>&emsp;&emsp;然后打开 <a href="https://github.com/Molunerfinn/picgo/releases">PicGo</a> 进行配置 （PicGo 是图床管理工具，能配合种图床使用，typora 中也支持使用 PicGo 自动上传图片，使用起来不要太方便了~</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200918174221758.png" alt="image-20200918174221758" style="zoom: 67%;" /><p>&emsp;&emsp;配置如上。</p><ul><li>仓库名：格式是 ：github用户名/图床仓库名</li><li>分支：master</li><li>token：前面生成的 token</li><li>存储路径：自己定义，如 <code>img/</code> 的话就会在仓库下生成一个 <code>img</code> 文件夹来存储图片</li><li>自定义域名：在图片上传后，PicGo会按照<code>自定义域名+储存路径+上传的图片名</code>的方式生成访问链接，放到粘贴板上，因为我们要使用 jsDelivr 加速访问，所以可以设置为<code>https://cdn.jsdelivr.net/gh/用户名/图床仓库名</code> ，上传完毕后，我们就可以通过<code>https://cdn.jsdelivr.net/gh/用户名/图床仓库名/图片路径</code>加速访问我们的图片了。</li></ul><h1 id="jsDelivr"><a href="#jsDelivr" class="headerlink" title="jsDelivr"></a>jsDelivr</h1><p>&emsp;&emsp;关于 jsDelivr 是不需要配置的，对于 github ，只要符合 jsDelivr 规定的路径，且<strong>仓库大小小于 50M ，文件不超过 20M</strong> 的都能直接引用。</p><p>&emsp;&emsp;规定的路径格式就是上面提到的：<code>https://cdn.jsdelivr.net/gh/用户名/图床仓库名/图片路径</code>。</p><p>&emsp;&emsp;如我在 <code>imagehost</code> 仓库的 <code>img</code> 文件夹下有一张图片 <code>default.png</code> ，这样就能通过：<a href="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/default.png">https://cdn.jsdelivr.net/gh/yleave/imagehost/img/default.png</a> 来访问它了。</p><p>&emsp;&emsp;当然，jsDelivr 不止能加速图片的访问，对于视频文件和音频文件也能使用同样的方法访问，不过美中不足的是仓库大小不能超过 50M。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="Imagine"><a href="#Imagine" class="headerlink" title="Imagine"></a>Imagine</h2><p>&emsp;&emsp;jsDelivr 限制了仓库大小，因此图片的压缩很重要，这里再推荐一个图片压缩工具 <a href="https://github.com/meowtec/Imagine">Imagine</a> ，非常好用，压缩效果很好，1M多的图片压缩成不到 100k 的图片也基本上看不出什么差别：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200918175722716.png" alt="image-20200918175722716" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200918175745739.png" alt="image-20200918175745739" style="zoom:67%;" /><h2 id="staticaly-与-githack"><a href="#staticaly-与-githack" class="headerlink" title="staticaly 与 githack"></a>staticaly 与 githack</h2><p>&emsp;&emsp;除了 jsDelivr 外，还有几个免费的且不限流量的CDN， <code>staticaly</code> <code>githack</code> ，它们都是全球通用的。</p><h3 id="staticaly"><a href="#staticaly" class="headerlink" title="staticaly"></a>staticaly</h3><p>&emsp;&emsp;官网地址：<a href="https://statically.io/">https://www.staticaly.com</a></p><p>&emsp;&emsp;轻松地从GitHub / GitLab / Bitbucket等加载您的项目 没有流量限制或限制。</p><p>&emsp;&emsp;文件通过超快速全球CDN提供。 在URL（不是分支）中使用特定标记或提交哈希。</p><p>&emsp;&emsp;根据URL永久缓存文件。 除master分支外，文件在浏览器中缓存1年。 具体用法：</p><p>&emsp;&emsp;<code>staticaly</code> 的用法：进入网站，将你的资源链接贴上去就会有了可用的链接：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200919005010468.png" alt="image-20200919005010468" style="zoom: 50%;" /><h3 id="githack"><a href="#githack" class="headerlink" title="githack"></a>githack</h3><p><strong>该 CDN 亲测需要接外网</strong></p><p>&emsp;&emsp;直接从GitHub，Bitbucket或GitLab提供原始文件</p><p>&emsp;&emsp;官网地址：<a href="https://raw.githack.com/">http://raw.githack.com/</a> 具体用法和上面的<code>staticaly</code>很类似</p><p>&emsp;&emsp;同样，在网站中输入资源链接，如：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200919005149597.png" alt="image-20200919005149597" style="zoom: 80%;" /><p>&emsp;&emsp;有两个 URL 版本：生产模式和开发模式，亲测生产模式速度会更快些，开发模式的 URL 会更“工整” 些，以便测试。不过别看生产模式的 URL 是有一长串字符，这些只要你前面的路径没变，这些字符都是一样的，因此同样比较方便统一路径。</p><p>&emsp;&emsp;当然，最最具有吸引力的就是它没有限制仓库容量，并且是永久免费的！</p><hr><p><a href="https://blog.csdn.net/qq_36759224/article/details/98058240">参考1</a></p><p><a href="https://www.itrhx.com/2019/02/10/A18-free-cdn/">参考2</a></p><p><a href="https://www.cnblogs.com/lfri/p/12212878.html">参考3</a></p>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图床</tag>
      
      <tag>CDN</tag>
      
      <tag>PicGo</tag>
      
      <tag>jsDelivr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2020/09/17/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2020/09/17/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p>并查集就是一个数组 <code>father[]</code> ，<code>father[i]</code> 表示元素 <code>i</code> 的父节点。</p><p>并查集的使用场景主要有：</p><ul><li>寻找节点的公共根结点</li><li>判断图的连通性</li><li>求集合的个数（根据给定的数据，求这些数据能够构成几个不连通的图）</li><li>…</li></ul><p>并查集的几个操作：</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><pre><code class="hljs js"><span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;    father[i] = i;&#125;</code></pre><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>用于快速找到某个节点的根结点</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findFather</span>(<span class="hljs-params">x</span>) </span>&#123;    <span class="hljs-keyword">while</span> (father[x] !== x) &#123;        x = father[x];    &#125;    <span class="hljs-keyword">return</span> x;&#125;<span class="hljs-comment">// or 递归</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">father</span>(<span class="hljs-params">x</span>) </span>&#123;    <span class="hljs-keyword">if</span> (x === father[x]) &#123;        <span class="hljs-keyword">return</span> x;    &#125;    <span class="hljs-keyword">return</span> findFather(father[x]);&#125;</code></pre><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">union</span>(<span class="hljs-params">a, b</span>) </span>&#123;    <span class="hljs-keyword">let</span> fa = findFather(a);    <span class="hljs-keyword">let</span> fb = findFather(b);    <span class="hljs-keyword">if</span> (fa !== fb) &#123;        father[fa] = fb; <span class="hljs-comment">// 将 a 接在 b 之下，即 b 作为 a 的父节点</span>    &#125; <span class="hljs-comment">// 否则，出现了环</span>&#125;</code></pre><h2 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h2><p>若节点很多的情况下，并查集的”高度”会非常高，因此可以使用路径压缩，使所有结点与根节点直接相连。</p><img src="https://i.loli.net/2020/09/17/e6BDlnFxiovp9K1.png" alt="image-20200917164907651" style="zoom: 67%;" /><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findFather</span>(<span class="hljs-params">x</span>) </span>&#123;    <span class="hljs-keyword">let</span> tmp = x;    <span class="hljs-keyword">while</span> (x !== father[x]) &#123; <span class="hljs-comment">// 寻找根结点，根结点是父节点等于当前值的节点</span>        x = father[x];    &#125;    <span class="hljs-keyword">while</span> (tmp !== father[tmp]) &#123;        <span class="hljs-keyword">let</span> a = x;        tmp = father[tmp];        father[a] = x; <span class="hljs-comment">// 将原先节点的父节点直接改为根结点。</span>    &#125;    <span class="hljs-keyword">return</span> x; <span class="hljs-comment">// 返回根结点</span>&#125;<span class="hljs-comment">// 递归写法</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findFather</span>(<span class="hljs-params">x</span>) </span>&#123;    <span class="hljs-keyword">if</span> (x === father[x]) &#123;        <span class="hljs-keyword">return</span> x;    &#125;    <span class="hljs-keyword">let</span> r = findFather(father[x]);    father[x] = r;    <span class="hljs-keyword">return</span> r;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>解题技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>连通性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 685. 冗余连接 II</title>
    <link href="/2020/09/17/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/685-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5-II/"/>
    <url>/2020/09/17/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/685-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5-II/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/redundant-connection-ii/">https://leetcode-cn.com/problems/redundant-connection-ii/</a></p><p>难度：困难</p><hr><p>&emsp;&emsp;在本问题中，有根树指满足以下条件的有向图。该树只有一个根节点，所有其他节点都是该根节点的后继。每一个节点只有一个父节点，除了根节点没有父节点。</p><p>&emsp;&emsp;输入一个有向图，该图由一个有着<code>N</code>个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在<code>1</code>到<code>N</code>中间，这条附加的边不属于树中已存在的边。</p><p>&emsp;&emsp;结果图是一个以边组成的二维数组。 每一个边 的元素是一对 <code>[u, v]</code>，用以表示有向图中连接顶点 <code>u</code> 和顶点 <code>v</code> 的边，其中 <code>u</code> 是 <code>v</code> 的一个父节点。</p><p>&emsp;&emsp;返回一条能删除的边，使得剩下的图是有<code>N</code>个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。</p><p><strong>简化题目：</strong> 根据给定的边集，求出一条多余的边，使得删除这条边后，图会变成一棵树，对于一些情况，这样的边会有多条，删除边集中出现的最后一条满足条件的边。</p><p><strong>示例 1:</strong></p><p>输入: <code>[[1,2], [1,3], [2,3]]</code></p><p>输出: <code>[2,3]</code></p><p>解释: 给定的有向图如下:</p><pre><code class="hljs angelscript">  <span class="hljs-number">1</span> / \v   v<span class="hljs-number">2</span>--&gt;<span class="hljs-number">3</span></code></pre><p><strong>示例 2:</strong></p><p>输入: <code>[[1,2], [2,3], [3,4], [4,1], [1,5]]</code></p><p>输出: <code>[4,1]</code></p><p>解释: 给定的有向图如下:</p><pre><code class="hljs angelscript"><span class="hljs-number">5</span> &lt;- <span class="hljs-number">1</span> -&gt; <span class="hljs-number">2</span>     ^    |     |    v     <span class="hljs-number">4</span> &lt;- <span class="hljs-number">3</span></code></pre><p><strong>注意:</strong></p><ul><li>二维数组大小的在<code>3</code>到<code>1000</code>范围内。</li><li>二维数组中的每个整数在<code>1</code>到<code>N</code>之间，其中 <code>N</code> 是二维数组的大小。</li></ul><h2 id="解法1：并查集"><a href="#解法1：并查集" class="headerlink" title="解法1：并查集"></a>解法1：并查集</h2><p>思路来源：<a href="https://leetcode-cn.com/problems/redundant-connection-ii/comments/70573">Nu11Pointer</a></p><p>&emsp;&emsp;对于一条能使一棵树变成图的边，它有以下几种情况：</p><ol><li><img src="https://i.loli.net/2020/09/17/OJIs4VDuBwAyxSd.png" alt="image-20200917170455420" style="zoom:80%;" />  <p>这条边从任意节点出发，指向了根结点，此时树形成了环，树也就没有根结点了（表现就是所有结点的入度都为 1），而这种情况下，处于这个环中的所有边都能被删除，因为删除任意一条边都能变成一棵正常的树，这也就是题目中提到的“多条边”的情况，但根据题目，需要删除边集中最后一条在环中的边。</p></li><li><img src="https://i.loli.net/2020/09/17/Cazh1PI3D4YecFn.png" alt="image-20200917170905916" style="zoom:80%;" />  <p>这条边从任意节点出发，指向了其祖先节点，树中形成了环，但仍有根结点，不过造成的后果就是有一个节点的入度变成 2了。这种情况下，只能删除环中的且造成 2 个入度的边，即图中橙色的边。</p></li><li><img src="https://i.loli.net/2020/09/17/qnpHve92sCIwOPW.png" alt="image-20200917171311259" style="zoom:80%;" /> <p> 这条边从任意节点出发，指向了一个非祖先节点。这种情况下，有一个节点的入度会为 2，这两条造成入度为 2 的边都能删除，但根据题目，需要删除后出现的那条。</p></li></ol><p>&emsp;&emsp;</p><p>&emsp;&emsp;好了，既然清楚可能的几种情况，就需要想办法找到这些满足条件的边了。</p><p>&emsp;&emsp;对于这种需要判断环的问题，可以考虑使用<a href="https://yleave.top/2020/09/17/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/%E5%B9%B6%E6%9F%A5%E9%9B%86/">并查集</a>来做。在创建并查集的过程中，合并两个节点 <code>a</code> 和 <code>b</code> 时，若这两个节点有着公共的根结点，那么将它们合并的话就会出现环了。</p><p>&emsp;&emsp;好的，首先，我们可以判断图中是否存在入度为 2 的节点，<strong>若存在</strong>，那么就是第 2 和第 3 种情况，将造成入度为 2 的这两条边（<code>edge1，edge2</code>）都先记录下来。</p><p>&emsp;&emsp;然后创建并查集，我们跳过 <code>edge2</code> （<strong>后出现的边</strong>）这条边，若创建并查集的过程一路畅通（即未出现环），那么答案就是 <code>edge2</code>，也就是 <code>2.</code> 中删了正确的边（橙色的边）和 <code>3.</code> 中的情况 。</p><p>&emsp;&emsp;而若创建并查集的过程中出现了环，那么对应的就是 <code>2.</code> 中删除了错误的边，那么答案就是 <code>edge1</code>。</p><p>&emsp;&emsp;<strong>若不存在入度为 2 的节点</strong> ，那么就是 <code>1.</code> 中的情况了。此时，在创建并查集的过程中，记录那条造成环出现的边，这条边会是环中的边（废话），且会是边集中最后出现的满足条件的边，将其记录下来，作为答案返回。</p><p><strong>JS 代码：</strong></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> findRedundantDirectedConnection = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">edges</span>) </span>&#123;    <span class="hljs-keyword">let</span> inDegrees = [];    <span class="hljs-keyword">let</span> res = [];    <span class="hljs-keyword">let</span> meetCircle;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> edge <span class="hljs-keyword">of</span> edges) &#123;        <span class="hljs-keyword">let</span> node = edge[<span class="hljs-number">1</span>];        <span class="hljs-keyword">if</span> (!inDegrees[node]) &#123;            inDegrees[node] = edge;        &#125; <span class="hljs-keyword">else</span> &#123;            res.push(inDegrees[node]);            res.push(edge); <span class="hljs-comment">// 若找到入度为 2 的节点，将其中一条边记录下来</span>            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">let</span> father = [];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= edges.length; i++) &#123;        father[i] = i;    &#125;    <span class="hljs-keyword">const</span> findFather = <span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> &#123;        <span class="hljs-keyword">let</span> tmp = x;        <span class="hljs-keyword">while</span> (x !== father[x]) &#123;            x = father[x];        &#125;        <span class="hljs-keyword">let</span> a = tmp;        tmp = father[tmp];        father[a] = x;        <span class="hljs-keyword">return</span> x;    &#125;;    <span class="hljs-keyword">const</span> union = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;        <span class="hljs-keyword">let</span> fa = findFather(a);        <span class="hljs-keyword">let</span> fb = findFather(b);        <span class="hljs-keyword">if</span> (fa !== fb) &#123;            father[fb] = fa;        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 遇到了环</span>            meetCircle = [a, b];        &#125;    &#125;;    <span class="hljs-comment">// 建立并查集，若存在入度为 2 的节点，跳过后出现的边</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> edge <span class="hljs-keyword">of</span> edges) &#123;        <span class="hljs-keyword">if</span> (res.length &amp;&amp; res[<span class="hljs-number">1</span>] === edge) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        union(edge[<span class="hljs-number">0</span>], edge[<span class="hljs-number">1</span>]);    &#125;    <span class="hljs-comment">// 若没有入度为 2 的点，则说明冗余的边指向了根结点</span>    <span class="hljs-keyword">if</span> (res.length === <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> meetCircle;    &#125;    <span class="hljs-keyword">return</span> meetCircle ? res[<span class="hljs-number">0</span>] : res[<span class="hljs-number">1</span>];&#125;;</code></pre><p>&emsp;&emsp;优化后的代码：只遍历了一次边集</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> findRedundantDirectedConnection = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">edges</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = [], father = [];    <span class="hljs-keyword">let</span> indegrees = [];    <span class="hljs-keyword">let</span> meetCircle;    <span class="hljs-keyword">const</span> findFather = <span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> &#123;        <span class="hljs-keyword">let</span> tmp = x;        <span class="hljs-keyword">while</span> (x !== father[x]) &#123;            x = father[x];        &#125;        <span class="hljs-keyword">let</span> a = tmp;        tmp = father[tmp];        father[a] = x;        <span class="hljs-keyword">return</span> x;    &#125;;    <span class="hljs-comment">// 创建并查集</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> edge <span class="hljs-keyword">of</span> edges) &#123;        <span class="hljs-keyword">let</span> node1 = edge[<span class="hljs-number">0</span>], node2 = edge[<span class="hljs-number">1</span>];        <span class="hljs-comment">// 初始化</span>        <span class="hljs-keyword">if</span> (!father[node1]) &#123;            father[node1] = node1;        &#125;        <span class="hljs-keyword">if</span> (!father[node2]) &#123;            father[node2] = node2;        &#125;        <span class="hljs-keyword">if</span> (indegrees[node2]) &#123; <span class="hljs-comment">// 若其入度已经为 1 了，则加上当前边入度就是 2了</span>            res.push([indegrees[node2], node2]);            res.push(edge);        &#125; <span class="hljs-keyword">else</span> &#123;            indegrees[node2] = node1;            <span class="hljs-keyword">let</span> f1 = findFather(node1);            <span class="hljs-keyword">let</span> f2 = findFather(node2);            <span class="hljs-keyword">if</span> (f1 !== f2) &#123;                father[f2] = f1;            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 遇到了环</span>                meetCircle = edge;            &#125;        &#125;    &#125;    <span class="hljs-comment">// 若没有入度为 2 的点，则说明冗余的边指向了根结点</span>    <span class="hljs-keyword">if</span> (res.length === <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> meetCircle;    &#125;    <span class="hljs-comment">// 否则，根据是否产生环输出答案</span>    <span class="hljs-keyword">return</span> meetCircle ? res[<span class="hljs-number">0</span>] : res[<span class="hljs-number">1</span>];&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>解答</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>并查集</tag>
      
      <tag>图</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Netlify部署博客</title>
    <link href="/2020/09/12/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E4%BD%BF%E7%94%A8Netlify%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/09/12/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E4%BD%BF%E7%94%A8Netlify%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;原先博客是部署在 githubPages 上的，稍微设置一下就能实现自动化部署和启用 https，还是蛮方便的，但是使用国内网络访问 githubPages 上部署的网站速度太慢了，体验很差，因此，搜了下解决方案，发现了 <code>Netlify </code> 这个一站式自动化部署网站的平台，部署网站的过程很简单， githubPages 上的支持和不支持的功能 Netlify 上都有，最重要的是听说使用 Netlify 部署的网站，国内访问深度会比 githubPages 快多了。因此也捣鼓了一番，使用 Netlify 重新部署了网站。</p><p>&emsp;&emsp;但是。。。部署完后使用国内网络访问网站，感觉访问速度没什么变化。。。去站长之家测试了下速度，唉</p><p><strong>我理想中的变化：</strong></p><img src="https://i.loli.net/2020/09/12/QFlGUA7px2aDmMN.png" alt="image-20200912114349985" style="zoom:80%;" /><p><strong>残酷的现实：</strong></p><p><img src="https://i.loli.net/2020/09/12/cUhBsSGPVHZkApW.png" alt="image-20200912114441879" style="zoom:40%;" /> <img src="https://i.loli.net/2020/09/12/aWpBJ7IDlcXvFCx.png" alt="image-20200912114518298" style="zoom:40%;" /></p><p>&emsp;&emsp;总之记录一下部署的过程，不过可能还是会选用 githubPages 了，关于网站加速，后面再看了。</p><h2 id="github-项目部署"><a href="#github-项目部署" class="headerlink" title="github 项目部署"></a>github 项目部署</h2><p>&emsp;&emsp;首先，进入 <a href="https://app.netlify.com/teams/yleave/sites">Netlify</a> 官网，选择 github 账号登陆。</p><p>&emsp;&emsp;然后点击创建新网站：</p><img src="https://i.loli.net/2020/09/12/UNgWzbrBpMFin7E.png" alt="image-20200912024233068" style="zoom:80%;" /><p>&emsp;&emsp;选择 github </p><img src="https://i.loli.net/2020/09/12/KgbkJuPSoFNQaB8.png" alt="image-20200912024310535" style="zoom:80%;" /><p>&emsp;&emsp;然后进入第二步，选择网站的项目仓库：</p><img src="https://i.loli.net/2020/09/12/PGQSKXUyLz2clhF.png" alt="image-20200912024635089" style="zoom:80%;" /><p>&emsp;&emsp;然后选择部署的分支及打包命令与发布目录，我是使用了 hexo ，因此打包命令是 <code>hexo generate</code>：</p><img src="https://i.loli.net/2020/09/12/dvts5UECVeaTRgQ.png" alt="image-20200912024803284" style="zoom: 67%;" /><p>&emsp;&emsp;点击 <code>Deploy</code> 按钮后，会自动进行部署，部署完成后，就能通过它给你的域名访问你的网站了：</p><img src="https://i.loli.net/2020/09/12/oQVNMXCEUmgnSey.png" alt="image-20200912025256424" style="zoom: 67%;" /><p>&emsp;&emsp;网站名称默认会是一连串字符，可以在 <code>Site Setting</code> 里更改：</p><img src="https://i.loli.net/2020/09/12/gLuZcst8EAmrB5D.png" alt="image-20200912025420094" style="zoom:67%;" /><h2 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h2><p>&emsp;&emsp;Netify 的初始域名会是 <code>xxx.netify.app</code></p><p>&emsp;&emsp;需要更改域名的话需要去申请域名，解析 DNS，有了之前的<a href="https://yleave.netlify.app/2020/09/11/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%B9%B6%E6%B7%BB%E5%8A%A0ssl/">经验</a> ，这步就很快了：</p><p>&emsp;&emsp;首先使用 <a href="http://tool.chinaz.com/dns">dns查询工具</a> 查询网站的 ip：</p><img src="https://i.loli.net/2020/09/12/cD7wf495nxWISud.png" alt="image-20200912025833859" style="zoom:67%;" /><p>&emsp;&emsp;然后去阿里云的 dns 解析平台解析这几条IP，并添加 <code>CNAME</code> 记录：</p><img src="https://i.loli.net/2020/09/12/9mdcMTJOi61vRGK.png" alt="image-20200912030148298" style="zoom:80%;" /><p>&emsp;&emsp;操作完成后，回到 Neltify，点击 <code>Add custom domain</code> 添加你的域名：</p><img src="https://i.loli.net/2020/09/12/ftZqQe9b6z5Juxm.png" alt="image-20200912030601733" style="zoom:80%;" /><p>&emsp;&emsp;然后是为网站添加 SSL，我<a href="https://www.yleave.top/2020/09/11/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%B9%B6%E6%B7%BB%E5%8A%A0ssl/#%E7%BB%99%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E6%B7%BB%E5%8A%A0-SSL">之前</a>已经申请过 SSL 证书了，因此点击添加证书按钮，将证书的内容上传：</p><img src="https://i.loli.net/2020/09/12/q1xW8fHOP6VXr2t.png" alt="image-20200912030811357" style="zoom:67%;" /><img src="https://i.loli.net/2020/09/12/5sAOkrjQXTwGNPZ.png" alt="image-20200912030928206" style="zoom: 67%;" /><p>&emsp;&emsp;若没有申请过证书的话，Netlify 也提供了免费证书的发放服务：</p><p>&emsp;&emsp;点击 <code>Let&#39;s Encrypt</code>，完成后如下：</p><img src="https://i.loli.net/2020/09/12/di6oRcH5FhTbsEQ.png" alt="image-20200912031035996" style="zoom: 67%;" /><p>&emsp;&emsp;至此，使用 Netlify 自动部署博客步骤就全部完成了，之后添加新内容提交后， Netlify 会自动打包发布，非常方便:</p><img src="https://i.loli.net/2020/09/12/aVEbmrYw2MJtFQR.png" alt="image-20200912032343535" style="zoom: 80%;" /><hr><p><strong>Ref:</strong></p><p><a href="https://www.cnblogs.com/37Y37/p/12551839.html">https://www.cnblogs.com/37Y37/p/12551839.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/77651304">https://zhuanlan.zhihu.com/p/77651304</a></p>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netlify</tag>
      
      <tag>自动化部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自定义域名并添加SSL</title>
    <link href="/2020/09/11/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%B9%B6%E6%B7%BB%E5%8A%A0SSL/"/>
    <url>/2020/09/11/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%B9%B6%E6%B7%BB%E5%8A%A0SSL/</url>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;本博客是部署在 Github Pages 上的，因此访问时域名为： <code>yleave.github.io</code> ，不过还是感觉太长了，于是乎捣鼓了两天，给博客加了个域名并添加了SSL证书，下面记录了一些捣鼓经验。</p><h1 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h1><p>&emsp;&emsp;前置条件：一个已部署在 github 上的博客</p><p>&emsp;&emsp;首先，需要注册一个域名，我是在<a href="https://wanwang.aliyun.com/domain/?spm=5176.100251.111252.21.72014f15uvzIEz">阿里云</a>上注册的，首年 9 元，续费 27 元，价格还可以接受，步骤也不麻烦。</p><p>&emsp;&emsp;第一次注册的需要实名认证，而名认证审核时间大概半天就能完成。</p><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>&emsp;&emsp;域名注册完成后，进入解析页面，点击添加记录：</p><img src="https://i.loli.net/2020/09/11/izd5jS7e2TVDgM4.png" alt="image-20200911163555583" style="zoom:80%;" /><p>&emsp;&emsp;先获取你的博客 IP 地址，可以使用命令行窗口 <code>ping</code> 一下：<code>ping name.github.io</code>  :</p><img src="https://i.loli.net/2020/09/11/dUDfhNnM5B6xTtL.png" alt="image-20200911163939089" style="zoom:80%;" /><p>&emsp;&emsp;或是去<a href="http://tool.chinaz.com/dns">网站</a>查一下：</p><img src="https://i.loli.net/2020/09/11/rp169ZtWCVNwMfD.png" alt="image-20200911164127950" style="zoom:80%;" /><p>&emsp;&emsp;这几个其实都是 github 的 IP 地址，应该所有在 github 上部署的博客都是这几个地址。</p><p>&emsp;&emsp;可以只选择一个 ip 进行解析，不过我这边将这四个地址都解析了：</p><img src="https://i.loli.net/2020/09/11/iTPvBhr7J8nEmV4.png" alt="image-20200911164331299" style="zoom: 67%;" /><img src="https://i.loli.net/2020/09/11/PGYWM2OEjw7ycRk.png" alt="image-20200911164419343" style="zoom:80%;" /><p>&emsp;&emsp;然后解析一个 <code>CNAME</code> 类型的记录：</p><img src="https://i.loli.net/2020/09/11/zbDgrJtNh7d2uKL.png" alt="image-20200911164528656" style="zoom: 67%;" /><p>&emsp;&emsp;最后，在博客所在项目的 <code>source</code> 文件夹下新建一个 <code>CNAME</code> 文件，写入申请的域名：</p><img src="https://i.loli.net/2020/09/11/buEdOwZFxce8jQz.png" alt="image-20200911164738664" style="zoom:80%;" /><p>&emsp;&emsp;不过这一步不知道它的作用是什么，但看其他教程都有这步，就加上去吧。</p><p>&emsp;&emsp;到这里，域名解析步骤就完成了。</p><h2 id="github-绑定"><a href="#github-绑定" class="headerlink" title="github 绑定"></a>github 绑定</h2><p>&emsp;&emsp;这个步骤中将解析的域名与 github 上的博客项目绑定起来。</p><p>&emsp;&emsp;先进入博客项目的 <code>Settings</code> 中： </p><img src="https://i.loli.net/2020/09/11/rEj2z1pJh76ctsg.png" alt="image-20200911165059055" style="zoom:80%;" /><p>&emsp;&emsp;拉到底部，在 <code>Custom domain</code> 栏中填入申请的域名：</p><img src="https://i.loli.net/2020/09/11/3c5nN9RMHSADZbX.png" alt="image-20200911165140522" style="zoom:67%;" /><p>&emsp;&emsp;到这一步，自定义域名的步骤就完成了，但由于我是第一次注册，还需等待实名认证完成，审核完成后就能通过 <code>www.yleave.top</code> 和 <code>yleave.top</code> 访问了。</p><img src="https://i.loli.net/2020/09/11/tSsPnkwdz59qO4F.png" alt="image-20200911165328548" style="zoom:80%;" /><h1 id="给博客网站添加-SSL"><a href="#给博客网站添加-SSL" class="headerlink" title="给博客网站添加 SSL"></a>给博客网站添加 SSL</h1><img src="https://i.loli.net/2020/09/11/WX46dDuBK8OvMig.png" alt="image-20200911165528080" style="zoom:80%;" /><p>&emsp;&emsp;关于 SSL 和 HTTPS 的介绍这里就不说明了，这篇<a href="https://yq.aliyun.com/articles/721195">文章</a>有一些简介可以看看。</p><h2 id="申请免费SSL证书"><a href="#申请免费SSL证书" class="headerlink" title="申请免费SSL证书"></a>申请免费SSL证书</h2><p>&emsp;&emsp;证书这边我是在 <a href="https://console.qcloud.com/ssl">腾讯云</a>申请免费的 SSL 证书，不过只有一年免费时间。</p><img src="https://i.loli.net/2020/09/11/qwMHnYxtACdPuiW.png" alt="image-20200911170245686" style="zoom:80%;" /><p>&emsp;&emsp;阿里云应该也能申请，不过我没找到，因此去腾讯云申请了，但是证书申请和域名申请不在同一个网站的话，后面上传证书时会稍微麻烦一些，不过也还好。</p><p>&emsp;&emsp;申请步骤很简单，只需要填写一个表格并实名认证就行。</p><img src="https://i.loli.net/2020/09/11/QWJShizDbOuTClr.png" alt="image-20200911170359563" style="zoom:80%;" /><p>&emsp;&emsp;申请完成后需要进行 DNS 验证：</p><img src="https://i.loli.net/2020/09/11/IQqkwEmhx62lcav.png" alt="image-20200911171152620" style="zoom:80%;" /><p>&emsp;&emsp;因此再回到阿里云的 DNS 解析页面，将上表中出现的字段填入解析记录中：</p><img src="https://i.loli.net/2020/09/11/QGcaB6q4i9dOPVL.png" alt="image-20200911171242463" style="zoom:80%;" /><p>然后，等待<a href="https://console.cloud.tencent.com/ssl/detail/gLRDXe3L">腾讯云</a>那边的 DNS 验证</p><img src="https://i.loli.net/2020/09/11/YrRZfFmPxEBCqze.png" alt="image-20200911171319884" style="zoom:80%;" /><p>&emsp;&emsp;过了大概五分钟，腾讯云发来短信，提示 DNS 解析成功。</p><img src="https://i.loli.net/2020/09/11/7MBHXatQUG5Z4A6.png" alt="image-20200911171410380" style="zoom:67%;" /><p>&emsp;&emsp;证书下载下来是一个压缩包，里面是这样子的，我估摸着是不同代理的证书：</p><img src="https://i.loli.net/2020/09/11/X6adrQ8wRF79fU2.png" alt="image-20200911171553060" style="zoom:80%;" /><h2 id="上传SSL证书"><a href="#上传SSL证书" class="headerlink" title="上传SSL证书"></a>上传SSL证书</h2><p>&emsp;&emsp;在腾讯云上申请完 SSL 证书后，需要将其上传到域名申请的地方，也就是阿里云的<a href="https://yundunnext.console.aliyun.com/?p=casnext#/overview/cn-hangzhou">证书管理中心</a>：</p><img src="https://i.loli.net/2020/09/11/e8iPSIDBodCVhlq.png" alt="image-20200911171741501" style="zoom:80%;" /><p>&emsp;&emsp;证书名称可以随便填，证书文件就是 <code>.crt</code> 的文件中的内容，一个证书文件对应了一个私钥，如 Apache 目录下， <code>_www.yleave.top.crt</code> 就是证书文件，<code>.key</code> 就是私钥，填入这两个就好了：</p><img src="https://i.loli.net/2020/09/11/8Ns2I6nyMZFhrAK.png" alt="image-20200911171826131" style="zoom:80%;" /><img src="https://i.loli.net/2020/09/11/DvlAJ6pV9KyXGdf.png" alt="image-20200911171859459" style="zoom:80%;" /><p>&emsp;&emsp;我这边先是上传了两个证书：</p><p><img src="https://i.loli.net/2020/09/11/KFQq7to6xyhvfXC.png" alt="image-20200911171934657"></p><p>&emsp;&emsp;上传完后点击部署按钮：</p><img src="https://i.loli.net/2020/09/11/eJ1HLE5PRY3mhqO.png" alt="image-20200911172010043" style="zoom:80%;" /><p>&emsp;&emsp;全选，点击部署：</p><img src="https://i.loli.net/2020/09/11/rgBiSMDbJIOoNtp.png" alt="image-20200911172049141" style="zoom: 80%;" /><p>&emsp;&emsp;不过刚部署完后访问网站还是 <code>http</code> 类型的，当时感觉是不是自己哪错了（后来发现应该是要等一会儿才能生效），于是看<a href="https://www.cnblogs.com/sslwork/p/5984167.html">一个博文</a> 里说还需要部署中间证书，于是按照上面的方法又上传部署了一个带中间证书内容的证书，但刚部署完仍未生效。</p><p>&emsp;&emsp;不过过了一会儿，正当我沮丧找其他博文参考时，又访问了一下发现证书好像生效了：</p><img src="https://i.loli.net/2020/09/11/LlnEkSad2G4eMVP.png" alt="image-20200911172535154" style="zoom:80%;" /><p>&emsp;&emsp;最后，在浏览其他博文时，发现 github 上还有一个 <code>Enforce HTTPS</code> 选项，暂时不清楚作用，总之先勾选上：</p><img src="https://i.loli.net/2020/09/11/MWEApjaytkvcVCT.png" alt="image-20200911172829156" style="zoom:67%;" /><p>&emsp;&emsp;捣鼓了两天，虽然过程中对一些步骤的作用还不太清楚，但最后成功完成，时间还是没白费的</p>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自定义域名</tag>
      
      <tag>SSL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Python 编写 MapReduce -- Hadoop Streaming</title>
    <link href="/2020/08/18/%E5%A4%A7%E6%95%B0%E6%8D%AE/hadoop%20streaming/"/>
    <url>/2020/08/18/%E5%A4%A7%E6%95%B0%E6%8D%AE/hadoop%20streaming/</url>
    
    <content type="html"><![CDATA[<p>要使用其他语言编写 MR 任务，首先要了解一下 Hadoop Streaming</p><h2 id="hadoop-streaming-简介"><a href="#hadoop-streaming-简介" class="headerlink" title="hadoop streaming 简介"></a>hadoop streaming 简介</h2><p>&emsp;&emsp;Hadoop streaming 是 Hadoop的一个工具， 它帮助用户创建和运行一类特殊的 map/reduce 作业， 这些特殊的map/reduce 作业是由一些可执行文件或脚本文件充当 mapper 或者 reducer。</p><p>&emsp;&emsp;也就是 hadoop streaming 可以帮助我们使用其他语言（非 java) 来编写 mapper 和 reducer。</p><p><strong>下面使用 python 来编写 MR 脚本</strong></p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>&emsp;&emsp;在 hadoop streaming 中，mapper 和 reducer 都是可执行文件，它们从标准输入流读取数据，使用标准输出流输出数据。</p><p>&emsp;&emsp;在 python 中就是：<code>sys.stdin</code> 和 <code>print</code></p><p>&emsp;&emsp;mapper 和 reducer 会一行一行的读取数据，根据分隔符（默认为 <code>tab</code>）将读入的数据切分为 <code>key</code> 和 <code>value</code>，同时，输出的数据也需要是一个 <code>key,value</code> 对，在第一个 <code>tab</code> 分隔符前的会被认为是 <code>key</code>，后面的都作为 <code>value</code>。</p><p>&emsp;&emsp;如，输出时 <code>print(&quot;%s\t%s&quot;, %(key, value))</code></p><h2 id="MR-编写示例"><a href="#MR-编写示例" class="headerlink" title="MR 编写示例"></a>MR 编写示例</h2><p>&emsp;&emsp;假设有数据如下，下面编写 MR 实现 “倒排”。</p><pre><code class="hljs scheme"><span class="hljs-number">1</span>    <span class="hljs-symbol">&#x27;bread</span>&#x27; <span class="hljs-symbol">&#x27;milk</span>&#x27; <span class="hljs-symbol">&#x27;vegetable</span>&#x27; <span class="hljs-symbol">&#x27;fruit</span>&#x27; <span class="hljs-symbol">&#x27;eggs</span>&#x27;<span class="hljs-number">2</span>    <span class="hljs-symbol">&#x27;noodle</span>&#x27; <span class="hljs-symbol">&#x27;beef</span>&#x27; <span class="hljs-symbol">&#x27;pork</span>&#x27; <span class="hljs-symbol">&#x27;water</span>&#x27; <span class="hljs-symbol">&#x27;socks</span>&#x27; <span class="hljs-symbol">&#x27;gloves</span>&#x27; <span class="hljs-symbol">&#x27;shoes</span>&#x27; <span class="hljs-symbol">&#x27;rice</span>&#x27;<span class="hljs-number">3</span>    <span class="hljs-symbol">&#x27;socks</span>&#x27; <span class="hljs-symbol">&#x27;gloves</span>&#x27;<span class="hljs-number">4</span>    <span class="hljs-symbol">&#x27;bread</span>&#x27; <span class="hljs-symbol">&#x27;milk</span>&#x27; <span class="hljs-symbol">&#x27;shoes</span>&#x27; <span class="hljs-symbol">&#x27;socks</span>&#x27; <span class="hljs-symbol">&#x27;eggs</span>&#x27;<span class="hljs-number">5</span>    <span class="hljs-symbol">&#x27;socks</span>&#x27; <span class="hljs-symbol">&#x27;shoes</span>&#x27; <span class="hljs-symbol">&#x27;sweater</span>&#x27; <span class="hljs-symbol">&#x27;cap</span>&#x27; <span class="hljs-symbol">&#x27;milk</span>&#x27; <span class="hljs-symbol">&#x27;vegetable</span>&#x27; <span class="hljs-symbol">&#x27;gloves</span>&#x27;<span class="hljs-number">6</span>    <span class="hljs-symbol">&#x27;eggs</span>&#x27; <span class="hljs-symbol">&#x27;bread</span>&#x27; <span class="hljs-symbol">&#x27;milk</span>&#x27; <span class="hljs-symbol">&#x27;fish</span>&#x27; <span class="hljs-symbol">&#x27;crab</span>&#x27; <span class="hljs-symbol">&#x27;shrimp</span>&#x27; <span class="hljs-symbol">&#x27;rice</span>&#x27;</code></pre><p>&emsp;&emsp;所谓 “倒排” 就是将数据中的每一个字符 <code>word</code> 与其前面的编号 <code>num</code> 对应起来，如 <code>bread</code>，它在编号 <code>1</code>、<code>4</code>、<code>6</code> 中都有出现，因此 倒排 的结果就是：<code>bread 1 4 6</code>。</p><p>&emsp;&emsp;首先，编写一个 <code>mapper</code> 来将数据拆分为一个个的 <code>word, num</code> 对：</p><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment"># coding=utf-8</span><span class="hljs-keyword">import</span> sys<span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> sys.stdin:    line = line.strip()    words = line.split()    num = words[<span class="hljs-number">0</span>]    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(words)):        word = words[i]        print(<span class="hljs-string">&#x27;%s\t%s&#x27;</span> % (word, num))</code></pre><p>&emsp;&emsp;接着，编写 <code>reducer </code>，将同一个 <code>word</code> 的所属编号收集到一起：</p><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><span class="hljs-comment">#coding:utf-8</span><span class="hljs-keyword">import</span> sysoutput = &#123;&#125;curWord = <span class="hljs-string">&#x27;&#x27;</span>wordCount = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> sys.stdin:    line = line.strip()    word,tid = line.split()    <span class="hljs-keyword">if</span> output.get(word) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:        output[word] = []    output[word].append(tid)    <span class="hljs-keyword">if</span> curWord == <span class="hljs-string">&#x27;&#x27;</span>:        curWord = word    <span class="hljs-keyword">if</span> curWord == word:        wordCount += <span class="hljs-number">1</span>    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">if</span> wordCount &gt;= <span class="hljs-number">3</span>: <span class="hljs-comment"># 若一个单词对应的编号数量不少于 3，则输出</span>            print(<span class="hljs-string">&#x27;%s\t%r&#x27;</span> % (curWord, output[curWord]))        wordCount = <span class="hljs-number">1</span>        curWord = word</code></pre><h2 id="执行-MR-脚本"><a href="#执行-MR-脚本" class="headerlink" title="执行 MR 脚本"></a>执行 MR 脚本</h2><p>&emsp;&emsp;通常执行 MR 脚本需要在 hadoop 系统上工作，但是为了防止出错， <code>mapper</code> 脚本可以在本地测试，而 <code>reducer</code> 脚本通常涉及排序，在本地测试可能会得到错误结果。</p><h3 id="本地测试"><a href="#本地测试" class="headerlink" title="本地测试"></a>本地测试</h3><p>&emsp;&emsp;在当前路径下有 <code>t1.txt</code> 存放数据，<code>mapper/mapper1.py</code> 为 mapper 脚本，在 <code>shell</code> 上运行命令：</p><p><code>cat t1.txt | python mapper/mapper1.py</code> ，这样 mapper 运行的结果就会打印在屏幕上了，若想要输出到文件中，可以使用 <code>&gt;</code> ，即 <code>cat t1.txt | python mapper/mapper1.py &gt; out1.txt</code></p><img src="https://i.loli.net/2020/09/11/iXvlZ6Tx2MoReJs.png" alt="image-20200828222203501" style="zoom:80%;" /><p>&emsp;&emsp;若想要读取一个文件夹下的所有文件的话，则改为：<code>cat data/*.txt | python mapper/mapper1.py</code> </p><h3 id="分布式系统上执行"><a href="#分布式系统上执行" class="headerlink" title="分布式系统上执行"></a>分布式系统上执行</h3><p>&emsp;&emsp;首先，将数据上传到 HDFS 的 <code>/pj</code> 目录下：<code>hadoop fs -put t1.txt /pj</code></p><p>&emsp;&emsp;然后使用 hadoop streaming 执行 MapReduce，hadoop streaming 需要提供一些设置参数，可以在命令行中直接输入，也可以编写 <code>shell</code> 脚本来执行（推荐）</p><p>&emsp;&emsp;来看 <code>shell</code> 脚本的编写，文件命名后缀是 <code>.sh</code></p><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span>hadoop jar /usr/<span class="hljs-built_in">local</span>/hadoop/share/hadoop/tools/lib/hadoop-streaming-2.7.7.jar \-jobconf mapreduce.reduce.shuffle.memory.limit.percent=0.1 \-jobconf mapreduce.reduce.shuffle.input.buffer.percent=0.3 \-jobconf mapreduce.map.memory.mb=512 \-jobconf mapreduce.reduce.memory.mb=512 \-jobconf mapred.map.capacity=100 \-jobconf mapred.reduce.capacity=100 \-jobconf mapred.job.name=reverse_sort \-file mapper/mapper1.py -mapper mapper/mapper1.py  \-file reducer/reducer1.py -reducer reducer/reducer1.py  \-input /pj/t1.txt -output /pj/output/</code></pre><p>&emsp;&emsp;简单说明一下这个 <code>shell</code> 脚本：</p><p>&emsp;&emsp;第一行 <code>#!/bin/bash</code> 说明这个是一个 <code>shell</code> 脚本</p><p>&emsp;&emsp;第二行中的 <code>hadoop-streaming-2.7.7.jar</code> jar 包路径是在自己安装 hadoop 的路径下，应该都会有的</p><p>&emsp;&emsp;再下面，<code>-jobconfig</code> 的那些参数根据自己的需要来设置，具体可以参照<a href="https://cwiki.apache.org/confluence/display/HADOOP2/JobConfFile">官网</a> 和这篇<a href="https://www.jianshu.com/p/1b69df99d949">博客</a>的介绍</p><p>&emsp;&emsp;而 <code>file</code>、<code>mapper</code>、<code>reducer</code>、<code>input</code> 和 <code>output</code> 是必须的。</p><p>&emsp;&emsp;其中 <code>file</code> 选项是让f ramework 把可执行文件作为作业的一部分，一起打包提交。</p><p>&emsp;&emsp;接下来，运行这个 <code>shell </code> 脚本，假设这个 <code>shell</code> 脚本的文件名是 <code>run.sh</code>。</p><p>&emsp;&emsp;<code>shell</code> 脚本有三种运行方式：</p><ol><li><p>先输入 <code>chmod +x run.sh</code> 赋予可执行权限，然后在命令行中输入 <code>./run.sh</code> 即可运行</p><img src="https://i.loli.net/2020/09/11/1SlUOAciyk4GLhK.png" alt="image-20200828224508743" style="zoom:80%;" /></li><li><p>使用 <code>sh run.sh</code> 运行</p></li><li><p>使用 <code>source run.sh</code> 运行</p></li></ol><p>&emsp;&emsp;脚本若正确执行完毕，拉取 HDFS 上的结果：<code>hadoop fs -get /pj/output</code></p>   <img src="https://i.loli.net/2020/09/11/kIN7CSXZxvsniMp.png" alt="image-20200828224740795" style="zoom:80%;" /><p>&emsp;&emsp;顺便一提，若不是使用编写 <code>shell</code> 脚本的方式运行，则上面的 hadoop streaming 运行方式为：</p><img src="https://i.loli.net/2020/09/11/G4fhzH6aeVMjX8E.png" alt="image-20200828225015917" style="zoom:80%;" /><p>&emsp;&emsp;即将脚本里的内容全写在命令行中。</p><h2 id="关于-hadoop-streaming-配置的一些参考学习文章"><a href="#关于-hadoop-streaming-配置的一些参考学习文章" class="headerlink" title="关于 hadoop streaming 配置的一些参考学习文章"></a>关于 hadoop streaming 配置的一些参考学习文章</h2><p><a href="http://hadoop.apache.org/docs/r1.0.4/cn/streaming.html">Hadoop Streaming</a></p><p><a href="https://help.aliyun.com/document_detail/44024.html?spm=a2c4g.11186623.6.914.162d19d6A0ZelV">阿里云Hadoop Streaming</a></p><p><a href="https://www.cnblogs.com/shay-zhangjin/p/7714868.html">Hadoop Streaming详解</a></p><p><a href="https://blog.csdn.net/Alanyungz/article/details/106767668">Hadoop Streaming介绍与实战</a></p><p><a href="https://cwiki.apache.org/confluence/display/HADOOP2/JobConfFile">JobConfFile</a> </p><p><a href="http://www.uml.org.cn/zjjs/201205303.asp">hadoop作业调优参数整理及原理</a></p><p><a href="https://blog.csdn.net/loveblair1990/article/details/53608293">hadoop streaming参数配置</a></p><p><a href="https://www.jianshu.com/p/1b69df99d949">Hadoop-Streaming参考一</a></p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>big data</tag>
      
      <tag>hadoop streaming</tag>
      
      <tag>MapReduce</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>写在前面</title>
    <link href="/2020/08/17/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/"/>
    <url>/2020/08/17/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;2019 年 3 月，我开始了我的第一篇博客，说是写作，但更多的是 「做笔记」「转载」 等没有深度的文章。</p><p>&emsp;&emsp;开始是在 <a href="https://blog.csdn.net/qq_38701868">CSDN</a> 上写博客，一些不想让别人看的笔记就使用网易云笔记写。慢慢的，看着一些大牛的博客，有深度、有干货，也有自己的理解，再看看我的 “博客”，通篇弥漫着一股 蒟蒻 的味道…写博客的激情也就逐渐淡下来了。最终，零零散散的发了快一年的博客后，我停止了 CSDN 上的 “写作”。</p><p>&emsp;&emsp;但是，做笔记、总结对程序员来说是非常重要的，在 CSDN 上写作后期，我主要在网易云笔记里写笔记，不过，用的时间久了，网易云笔记的一些缺点就发现的越多，于是乎，在网上一顿乱搜，找到了现在的写作软件 <code>Typora</code>，蛮合我胃口的，轻量级，页面简洁，对 <code>MarkDown</code> 的支持也很强大…不过有一个缺点就是在一篇笔记里的内容很多的时候，页面就会有些卡顿，但是还行，还能接受~</p><p>&emsp;&emsp;后来，面向浏览器编程的我，看了许多大佬的博客和他们炫酷的博客网站后，萌生了搭网站写博客的想法，也想着能在搭博客的过程中学习一些前端的知识，不过由于对自己的信心不足，写的博客也没深度，没干货，这个想法也因此搁置了很久，直到一次逛B站时看到了 <strong>Up 主 CodeSheep</strong>  的 <a href="https://www.bilibili.com/video/BV1Px411d74c">为什么程序员必须写技术博客?…</a> 这个视频后才坚定了我搭建自己的博客网站并再次开始写博客的想法。</p><p>&emsp;&emsp;视频中分享了自己写博客的感想，以及写博客的重要性和必要性，但对我说服力最大的还是视频中提到的<strong>写博客误区</strong> </p><blockquote><p>&emsp;&emsp;<strong>误区一</strong>：初学者写博客没技术含量怎么办（感同身受</p><p>&emsp;&emsp;<strong>误区二</strong>：初学者写博客会不会被喷   </p><p>​&emsp;&emsp;对于误区二，虽然只是不到一年的写博客经历，但基本上没遇到喷我博客的人（可能是我博客的流量太小hh），并且偶尔遇到一些感谢的留言和点赞还是会有点小成就感的~</p></blockquote><p>&emsp;&emsp;诚然，写博客能够在以后找工作，面试时加分，但我觉得更重要的是在写作过程中锻炼自己的表达、总结能力。知识需要沉淀，每学的一些知识，每做的一件事，都需要总结、输出，能够用自己的话说出来，能够有自己的理解，才能说你学过了这个知识。即使是一个小的技术点、一个小的 idea，甚至一些简单的笔记，都可以写到博客中，我相信积累的力量。</p><p>就这样，我再次开始了我的写博客之旅，或许博客内容会有些青涩，有些错误，请见谅~</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
