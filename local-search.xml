<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>牛顿迭代法</title>
    <link href="/2020/10/18/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95/"/>
    <url>/2020/10/18/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>转自 <a href="https://leetcode-cn.com/problems/sqrtx/solution/x-de-ping-fang-gen-by-leetcode-solution/">LeetCode 解答</a></p><hr><p>&emsp;&emsp;<a href="https://baike.baidu.com/item/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95">牛顿迭代法</a>是一种可以用来快速求解函数零点的方法。</p><p>&emsp;&emsp;以 <a href="https://leetcode-cn.com/problems/sqrtx/">LeetCode</a> 上的一题为例：模拟 <code>int sqrt(x)</code> 函数，返回的开方值向下取整。</p><p>&emsp;&emsp;为了叙述方便，我们用 <code>C</code> 表示待求出平方根的那个整数。显然，<code>C</code> 的平方根就是函数<br>$$<br>y = f(x) = x^2 - C<br>$$<br>&emsp;&emsp;的零点。</p><p>&emsp;&emsp;牛顿迭代法的本质是借助泰勒级数，从初始值开始快速向零点逼近。我们任取一个 $x_0$ 作为初始值，在每一步的迭代中，我们找到图像上的点 $(x_i,f(x_i))$ ，过该点做一条斜率为该点导数 $f’(x_i)$ 的直线，直线与 <code>x</code> 轴的交点记为 $x_{i+1}$，$x_{i+1}$ 相对于 $x_i$ 而言距离零点更加接近。进过多次迭代后，就能得到一个非常接近零点的与 <code>x</code> 轴的交点。</p><p>&emsp;&emsp;下图给出了从 $x_0$ 开始迭代两次，得到 $x_1$ 和 $x_2$ 的过程：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201018114250949.png" alt="image-20201018114250949" style="zoom:80%;" /><p>&emsp;&emsp;首先，我们选择 $x_0 = C$ 作为初始值。</p><p>&emsp;&emsp;在每一步的迭代中，通过当前与 <code>x</code> 轴的交点 $x_i$ ，得到函数图像上的一点 $(x_i, x^2 - C)$ ，做一条斜率为 $f’(x_i) = 2x_i$ 的直线，直线方程为：<br>$$<br>y - y_0 = k(x - x_0)<br>$$</p><p>$$<br>y = 2x_i(x - x_i) + x_i^2 - C<br>$$</p><p>&emsp;&emsp;因此，与 <code>x</code> 轴的交点为方程 $2x_ix - (x_i^2 + C) = 0$ 的解，即为新的迭代结果 $x_{i+1}$ ：<br>$$<br>x_{i+1} = \frac{1}{2}(x_i + \frac{C}{x_i})<br>$$<br>&emsp;&emsp;在进行 <code>k</code> 次迭代之后，$x_k$ 与真实值 $\sqrt{C}$ 足够接近，即可作为答案。</p><p>&emsp;&emsp;<strong>选择 $x_0 = C$ 作为初始值的原因：</strong></p><p>&emsp;&emsp;因为函数 $y = x^2 - C$ 有两个零点 $-\sqrt{C}$ 和 $\sqrt{C}$。而我们想找的是 $\sqrt{C}$，如果初始值比较小的话，有可能迭代到 $-\sqrt{C}$ 这个零点，因此选择 $x_0 = C$ 作为初始值。且每次迭代均有 $x_{i+1} &lt; x_i$，零点 $\sqrt{C}$ 在其左侧，因此我们一定会迭代到这个零点。</p><p>&emsp;&emsp;<strong>迭代终止条件：</strong></p><p>&emsp;&emsp;每一次迭代，我们都会离零点更近一步，所以当两次迭代的距离非常近时，就可以认为是已经非常逼近零点了，也就能将其作为答案。判断接近程度可以使用一个非常小的值来做比较，如 $x_{i+1} - x_i &lt; 10^{-6}$ 。</p><p>&emsp;&emsp;<strong>C 代码如下：</strong></p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;    <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">double</span> x0 = x, c = x;    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;        <span class="hljs-keyword">double</span> xi = <span class="hljs-number">0.5</span> * (x0 + c / x0);        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(x0 - xi) &lt; <span class="hljs-number">1e-6</span>) &#123;            <span class="hljs-keyword">break</span>;        &#125;        x0 = xi;    &#125;    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)x0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>算法知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/2020/10/18/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2020/10/18/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;所谓二分查找，就是从一个查找范围中每次取中间值，然后根据中间值来判断是否满足条件或是缩小查找范围的过程，且这个范围内的值需要是有规律的，比如是有序的。</p><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>&emsp;&emsp;以 <a href="https://leetcode-cn.com/problems/search-insert-position/">LeetCode</a> 的一道简单题为例：给定一个排序数组和一个目标值，返回目标值的索引，若不存在，则返回能够插入该目标值的索引。</p><p>&emsp;&emsp;如 ：<code>array = [1,5,7,10,12], target = 6</code></p><p>&emsp;&emsp;则返回值为 <code>2</code></p><p>&emsp;&emsp;这题就是经典的使用二分查找的场景，最开始的查找范围是 <code>[0, 4]</code>，中间值 <code>array[2] = 7</code>，根据这个中间值，我们知道 <code>6</code> 是小于中间值的，因此能够缩小查找范围，即 <code>[0, 1]</code>，继续判断中间值 <code>array[0] = 1</code>，缩小查找范围 <code>[1, 1]</code>，最后发现查找范围内只剩下一个值 <code>5</code>，且小于目标值 <code>6</code> ，因此最后就能知道需要插入的索引是 <code>2</code>。</p><p>代码如下：</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> r[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right,<span class="hljs-keyword">int</span> x)</span></span>&#123;    <span class="hljs-keyword">int</span> mid;    <span class="hljs-keyword">while</span>(left &lt;= right)&#123;        mid = (left + right) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(r[mid] == x)&#123;            <span class="hljs-keyword">return</span> mid;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(r[mid] &gt; x)&#123;            right = mid - <span class="hljs-number">1</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            left = mid + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> left;&#125;</code></pre><p>&emsp;&emsp;其中， <code>(left + right) / 2</code> 有必要的话可以替换成 <code>left + (right - left) / 2</code>，以避免 <code>left + right</code> 超出整型范围的情况。</p><h1 id="二分查找变形"><a href="#二分查找变形" class="headerlink" title="二分查找变形"></a>二分查找变形</h1><p>&emsp;&emsp;根据使用场景的不同，二分查找有一些变形算法。</p><h2 id="返回第一个大于等于-x-的位置"><a href="#返回第一个大于等于-x-的位置" class="headerlink" title="返回第一个大于等于 x 的位置"></a>返回第一个大于等于 x 的位置</h2><p>&emsp;&emsp;在下面代码中，循环结束时，<code>left</code> 是会刚好等于 <code>right</code> 的，<code>right</code> 总是会在大于等于 <code>x</code> 的地方停下来，一直压缩区间，<code>left</code> 最后的位置会是恰好大于等于 <code>x</code> 的位置。</p><p>&emsp;&emsp;所以说，下面的代码作用和上面例子中的代码是完全一样的。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lowerBound</span>(<span class="hljs-params">arr, tar</span>) </span>&#123;    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>, right = arr.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">let</span> mid = <span class="hljs-built_in">Math</span>.floor((left + right) / <span class="hljs-number">2</span>);        <span class="hljs-keyword">let</span> num = arr[mid];        <span class="hljs-keyword">if</span> (tar &lt;= num) &#123;            right = mid;        &#125; <span class="hljs-keyword">else</span> &#123;            left = mid + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> left;&#125;</code></pre><p>&emsp;&emsp;如 <code>arr = [1, 3, 4, 6, 7]</code> ，<code>target = 5</code>，返回 <code>3</code></p><h2 id="返回第一个大于-x-的位置"><a href="#返回第一个大于-x-的位置" class="headerlink" title="返回第一个大于 x 的位置"></a>返回第一个大于 x 的位置</h2><p>&emsp;&emsp;这个函数与上面一个函数的变化只是将 <code>if</code> 判断中的 <code>&lt;=</code> 改为 <code>&lt;</code>。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lowerBound</span>(<span class="hljs-params">arr, tar</span>) </span>&#123;    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>, right = arr.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">let</span> mid = <span class="hljs-built_in">Math</span>.floor((left + right) / <span class="hljs-number">2</span>);        <span class="hljs-keyword">let</span> num = arr[mid];        <span class="hljs-keyword">if</span> (tar &lt; num) &#123;            right = mid;        &#125; <span class="hljs-keyword">else</span> &#123;            left = mid + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> left;&#125;</code></pre><p>&emsp;&emsp;如 <code>arr = [1, 3, 4, 6, 7]</code> ，<code>target = 3</code>，返回 <code>3</code></p><h2 id="返回第一个小于等于-x-的位置"><a href="#返回第一个小于等于-x-的位置" class="headerlink" title="返回第一个小于等于 x 的位置"></a>返回第一个小于等于 x 的位置</h2><p>&emsp;&emsp;同理，在循环中稍加变动，就能实现另一个功能，不过这时候计算 <code>mid</code> 需要向上取整了（之前都是向上取整的），不然可能会出现无限循环，因为每次都向下取整的话可能会出现 <code>left</code> 不变的情况：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lowerBound</span>(<span class="hljs-params">arr, tar</span>) </span>&#123;    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>, right = arr.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">let</span> mid = <span class="hljs-built_in">Math</span>.ceil((left + right) / <span class="hljs-number">2</span>);        <span class="hljs-keyword">let</span> num = arr[mid];        <span class="hljs-keyword">if</span> (tar &gt;= num) &#123;            left = mid;        &#125; <span class="hljs-keyword">else</span> &#123;            right = mid - <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> right;&#125;</code></pre><p>&emsp;&emsp;同理，第一个<strong>小于</strong> <code>x</code> 的位置：</p><pre><code class="hljs js"><span class="hljs-keyword">while</span> (left &lt; right) &#123;    <span class="hljs-keyword">let</span> mid = <span class="hljs-built_in">Math</span>.ceil((left + right) / <span class="hljs-number">2</span>);    <span class="hljs-keyword">let</span> num = arr[mid];    <span class="hljs-keyword">if</span> (tar &gt; num) &#123;        left = mid;    &#125; <span class="hljs-keyword">else</span> &#123;        right = mid - <span class="hljs-number">1</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>算法知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThreeJS 坐标转换</title>
    <link href="/2020/10/17/WebGL/ThreeJS/ThreeJS-%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2/"/>
    <url>/2020/10/17/WebGL/ThreeJS/ThreeJS-%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="物体坐标转屏幕坐标"><a href="#物体坐标转屏幕坐标" class="headerlink" title="物体坐标转屏幕坐标"></a>物体坐标转屏幕坐标</h1><p>&emsp;&emsp;在 ThreeJS 中，一个物体可看作一个 <code>Mesh</code>，<code>Mesh</code> 的坐标是用一个 <code>Vector3</code> 来表示的，<code>Vector3</code> 中包含了 <code>x</code>、<code>y</code>、<code>z</code> 坐标。</p><h2 id="project-方法"><a href="#project-方法" class="headerlink" title="project 方法"></a>project 方法</h2><p>&emsp;&emsp;通过 <code>Vector3 </code>对象的方法 <code>project</code>，方法的参数是相机对象，语句 <code>worldVector.project(camera);</code>返回的结果是世界坐标 <code>worldVector </code>在 <code>camera </code>相机对象矩阵变化下对应的标准设备坐标， 标准设备坐标 <code>xyz</code> 的范围是<code> [-1,1]</code>。</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201015163144727.png" alt="image-20201015163144727" style="zoom:80%;" /><p>&emsp;&emsp;Three 的场景是建立在 <code>canvas</code> 之上的，<code>canvas</code> 画布的宽高是：<code>canvas.offsetWidth</code> 和 <code>canvas.offsetHeight</code>，从<strong>屏幕坐标系</strong>来看，画布的中心就是：<code>(canvas.offsetWidth / 2，canvas.offsetHeight / 2)</code>，从 WebGL <strong>标准设备坐标系</strong>的角度来看画布中心是坐标原点 <code>(0, 0)</code>。</p><p>&emsp;&emsp;因此，从标准设备坐标系转换到屏幕坐标系我们可以这样做：</p><p>&emsp;&emsp;首先计算出屏幕坐标系中心：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> centerX = canvas.offsetWidth / <span class="hljs-number">2</span>;<span class="hljs-keyword">const</span> centerY = canvas.offsetHeight / <span class="hljs-number">2</span>;</code></pre><p>&emsp;&emsp;计算出的 <code>centerX</code> 和 <code>centerY</code> 同时也表示了坐标轴的一半大小。</p><p>&emsp;&emsp;然后，由于<strong>屏幕坐标系的原点是在左上角</strong>，因此转换公式如下：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> standardVec = worldVector.project(camera);<span class="hljs-keyword">const</span> screenX = <span class="hljs-built_in">Math</span>.round(centerX * standardVec.x + centerX);<span class="hljs-keyword">const</span> screenY = <span class="hljs-built_in">Math</span>.round(-centerY * standardVec.y + centerY);</code></pre><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://www.yanhuangxueyuan.com/Three.js_course/screen.html">http://www.yanhuangxueyuan.com/Three.js_course/screen.html</a></p>]]></content>
    
    
    <categories>
      
      <category>WebGL</category>
      
      <category>ThreeJS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>threeJS</tag>
      
      <tag>坐标转换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 52. N皇后 II</title>
    <link href="/2020/10/17/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/52-N%E7%9A%87%E5%90%8E-II/"/>
    <url>/2020/10/17/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/52-N%E7%9A%87%E5%90%8E-II/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/n-queens-ii/">https://leetcode-cn.com/problems/n-queens-ii/</a></p><p>难度：困难</p><hr><p>&emsp;&emsp;<em>n</em> 皇后问题研究的是如何将 <em>n</em> 个皇后放置在 <em>n</em>×<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201017095826142.png" alt="image-20201017095826142" style="zoom:80%;" /><p>&emsp;&emsp;上图为 8 皇后问题的一种解法。</p><p>&emsp;&emsp;给定一个整数 <em>n</em>，返回 <em>n</em> 皇后<strong>不同的解决方案的数量</strong>。</p><p><strong>示例:</strong></p><p>输入: 4</p><p>输出: 2</p><p>解释: 4 皇后问题存在如下两个不同的解法。</p><pre><code class="hljs json">[ [<span class="hljs-string">&quot;.Q..&quot;</span>,  <span class="hljs-comment">// 解法 1</span>  <span class="hljs-string">&quot;...Q&quot;</span>,  <span class="hljs-string">&quot;Q...&quot;</span>,  <span class="hljs-string">&quot;..Q.&quot;</span>], [<span class="hljs-string">&quot;..Q.&quot;</span>,  <span class="hljs-comment">// 解法 2</span>  <span class="hljs-string">&quot;Q...&quot;</span>,  <span class="hljs-string">&quot;...Q&quot;</span>,  <span class="hljs-string">&quot;.Q..&quot;</span>]]</code></pre><h2 id="解法1：回溯"><a href="#解法1：回溯" class="headerlink" title="解法1：回溯"></a>解法1：回溯</h2><p>&emsp;&emsp;解法和 <a href="http://yleave.top/2020/10/17/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/51-N%E7%9A%87%E5%90%8E/">N皇后1</a> 是一样的，区别就是本题求的是解法个数， N皇后1 求的是所有的解法棋盘布局。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> totalNQueens = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>&#123;    <span class="hljs-keyword">let</span> dirs = [[<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>], [<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>]];    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> board = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n).fill(<span class="hljs-number">0</span>).map(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n).fill(<span class="hljs-number">0</span>);    &#125;);    <span class="hljs-keyword">const</span> helper = <span class="hljs-function">(<span class="hljs-params">row</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (row === n) &#123;            res++;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> col = <span class="hljs-number">0</span>; col &lt; n; col++) &#123;            <span class="hljs-keyword">let</span> flag;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> dir <span class="hljs-keyword">of</span> dirs) &#123;                <span class="hljs-keyword">let</span> r = row, c = col;                flag = <span class="hljs-literal">true</span>;                <span class="hljs-keyword">while</span> (r &gt;= <span class="hljs-number">0</span> &amp;&amp; c &gt;= <span class="hljs-number">0</span> &amp;&amp; c &lt; n) &#123;                    <span class="hljs-keyword">if</span> (board[r][c] === <span class="hljs-number">1</span>) &#123;                        flag = <span class="hljs-literal">false</span>;                        <span class="hljs-keyword">break</span>;                    &#125;                    r += dir[<span class="hljs-number">0</span>], c += dir[<span class="hljs-number">1</span>];                &#125;                <span class="hljs-keyword">if</span> (!flag) &#123;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;            <span class="hljs-keyword">if</span> (flag) &#123;                board[row][col] = <span class="hljs-number">1</span>;                helper(row + <span class="hljs-number">1</span>);                board[row][col] = <span class="hljs-number">0</span>;            &#125;        &#125;    &#125;;    helper(<span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> res;&#125;;</code></pre><h2 id="解法2：空间优化"><a href="#解法2：空间优化" class="headerlink" title="解法2：空间优化"></a>解法2：空间优化</h2><p>&emsp;&emsp;对于解法1，使用了 <code>n * n</code> 的棋盘来帮助判断某个位置是否满足安置皇后的要求，但是，对于每种 N皇后的安置策略，我们仅使用了棋盘中的一部分来帮助判断（即每个位置的两条斜线和直线），因此，我们可以缩小空间，仅使用三个列表来分别表示直行、和两条斜行上是否有皇后。</p><p>&emsp;&emsp;例如，对于直行，若第三列上有皇后，则 <code>cols[3] = 1</code>，否则，<code>cols[3] = 0</code></p><p>&emsp;&emsp;直行判断是否有皇后很简单，只要使用列下标即可。</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201017104019691.png" alt="image-20201017104019691" style="zoom:67%;" /><p>&emsp;&emsp;对于其中一个方向的斜线，棋盘中的每条这个方向的斜线都能使用一个下标来表示，即 <strong>行下标 - 列下标</strong>：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201017110155747.png" alt="image-20201017110155747" style="zoom:67%;" /><p>&emsp;&emsp;另一个方向的斜线能使用 <strong>行下标 + 列下标</strong> 来表示：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201017110328469.png" alt="image-20201017110328469" style="zoom:67%;" /><p>&emsp;&emsp;因此，对于棋盘中的一个位置，只需借助这三个列表来判断位置是否合法即可（三个列表中都不含当前位置）</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> totalNQueens = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> cols = [], diagonal1 = [], diagonal2 = [];    <span class="hljs-keyword">const</span> helper = <span class="hljs-function">(<span class="hljs-params">row</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (row === n) &#123;            res++;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            <span class="hljs-keyword">if</span> (cols[i] === <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">let</span> d1 = row - i;            <span class="hljs-keyword">if</span> (diagonal1[d1] === <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">let</span> d2 = row + i;            <span class="hljs-keyword">if</span> (diagonal2[d2] === <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            cols[i] = <span class="hljs-number">1</span>;            diagonal1[d1] = <span class="hljs-number">1</span>;            diagonal2[d2] = <span class="hljs-number">1</span>;            helper(row+<span class="hljs-number">1</span>);            cols[i] = <span class="hljs-number">0</span>;            diagonal1[d1] = <span class="hljs-number">0</span>;            diagonal2[d2] = <span class="hljs-number">0</span>;        &#125;    &#125;;    helper(<span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> res;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>解答</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 51. N皇后</title>
    <link href="/2020/10/17/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/51-N%E7%9A%87%E5%90%8E/"/>
    <url>/2020/10/17/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/51-N%E7%9A%87%E5%90%8E/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/n-queens/">https://leetcode-cn.com/problems/n-queens/</a></p><p>难度：困难</p><hr><p>&emsp;&emsp;<em>n</em> 皇后问题研究的是如何将 <em>n</em> 个皇后放置在 <em>n</em>×<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201017095826142.png" alt="image-20201017095826142" style="zoom:80%;" /><p>&emsp;&emsp;图为 8 皇后问题的一种解法。</p><p>&emsp;&emsp;给定一个整数 <code>n</code>，返回所有不同的 <code>n</code> 皇后问题的解决方案。</p><p>&emsp;&emsp;每一种解法包含一个明确的 <code>n</code> 皇后问题的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p><p><strong>示例：</strong></p><p>输入：<code>4</code></p><pre><code class="hljs awk">输出：[ [<span class="hljs-string">&quot;.Q..&quot;</span>,  <span class="hljs-regexp">//</span> 解法 <span class="hljs-number">1</span>  <span class="hljs-string">&quot;...Q&quot;</span>,  <span class="hljs-string">&quot;Q...&quot;</span>,  <span class="hljs-string">&quot;..Q.&quot;</span>],</code></pre><pre><code class="hljs awk"> [<span class="hljs-string">&quot;..Q.&quot;</span>,  <span class="hljs-regexp">//</span> 解法 <span class="hljs-number">2</span>  <span class="hljs-string">&quot;Q...&quot;</span>,  <span class="hljs-string">&quot;...Q&quot;</span>,  <span class="hljs-string">&quot;.Q..&quot;</span>]]</code></pre><p>解释: 4 皇后问题存在两个不同的解法。</p><p><strong>提示：</strong></p><ul><li>皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</li></ul><h2 id="解法1：回溯"><a href="#解法1：回溯" class="headerlink" title="解法1：回溯"></a>解法1：回溯</h2><p>&emsp;&emsp;对每个位置都进行尝试。</p><p>&emsp;&emsp;<code>n</code> 行，每行从头开始遍历，对当前位置，判断这个位置是否满足皇后位置的要求，即横、纵、斜线上都没有其他皇后存在，因为我们是从头开始遍历的，因此，对当前位置只需要判断处于一条竖线的上方、处于左斜线的上方和处于右斜线的上方是否有皇后存在即可。若当前位置满足，则开始寻找下一行的皇后的位置。直到第 <code>n</code> 行找到最后一个皇后。</p><p>&emsp;&emsp;如下图，假设遍历到 Q3 位置，它只需要判断三条蓝线的方向是否有皇后即可。</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201017101137969.png" alt="image-20201017101137969" style="zoom:80%;" /><pre><code class="hljs js"><span class="hljs-keyword">var</span> solveNQueens = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = [];    <span class="hljs-keyword">let</span> board = [];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        board[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n).fill(<span class="hljs-string">&#x27;.&#x27;</span>);    &#125;    <span class="hljs-keyword">const</span> deepCopy = <span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-keyword">let</span> arr = [];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            arr[i] = [];            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;                arr[i][j] = board[i][j];            &#125;        &#125;        <span class="hljs-keyword">return</span> arr;    &#125;;    <span class="hljs-keyword">const</span> dirs = [[<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>]];  <span class="hljs-comment">// 只需要查找 上方的、斜左上方的 和 斜右上方的 方向是否有 Q 即可</span>    <span class="hljs-keyword">const</span> helper = <span class="hljs-function">(<span class="hljs-params">row</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (row === n) &#123;            res.push(deepCopy());        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> dir <span class="hljs-keyword">of</span> dirs) &#123;                <span class="hljs-keyword">let</span> r = row + dir[<span class="hljs-number">0</span>], c = i + dir[<span class="hljs-number">1</span>];                <span class="hljs-keyword">while</span>(r &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; n &amp;&amp; c &gt;= <span class="hljs-number">0</span> &amp;&amp; c &lt; n) &#123;                    <span class="hljs-keyword">if</span> (board[r][c] === <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;                        flag = <span class="hljs-literal">false</span>;                        <span class="hljs-keyword">break</span>;                    &#125;                    r += dir[<span class="hljs-number">0</span>], c += dir[<span class="hljs-number">1</span>];                &#125;                <span class="hljs-keyword">if</span> (!flag) &#123;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;            <span class="hljs-keyword">if</span> (flag) &#123;                board[row][i] = <span class="hljs-string">&#x27;Q&#x27;</span>;                helper(row+<span class="hljs-number">1</span>);                board[row][i] = <span class="hljs-string">&#x27;.&#x27;</span>;            &#125;        &#125;    &#125;;    helper(<span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; res.length; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;            res[i][j] = res[i][j].join(<span class="hljs-string">&#x27;&#x27;</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>解答</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 116. 填充每个节点的下一个右侧节点指针</title>
    <link href="/2020/10/15/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/"/>
    <url>/2020/10/15/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/</a></p><p>难度：中等</p><hr><p>&emsp;&emsp;给定一个<strong>完美二叉树</strong>，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span>  <span class="hljs-keyword">int</span> val;  Node *left;  Node *right;  Node *next;&#125;</code></pre><p>&emsp;&emsp;填充它的每个 <code>next </code>指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 <code>next </code>指针设置为 <code>NULL</code>。</p><p>&emsp;&emsp;初始状态下，所有 <code>next </code>指针都被设置为 <code>NULL</code>。</p><p><strong>示例：</strong></p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201015114937533.png" alt="image-20201015114937533" style="zoom:80%;" /><hr><p>&emsp;&emsp;首先，给定的树是一棵<strong>完美二叉树</strong>，因此对于所有非叶子节点的节点，都会有左右孩子。</p><h2 id="解法1：层次优先遍历"><a href="#解法1：层次优先遍历" class="headerlink" title="解法1：层次优先遍历"></a>解法1：层次优先遍历</h2><p>&emsp;&emsp;由于每个节点的 <code>next</code> 指针都是指向当前层次的右边节点，因此很容易想到使用层次优先遍历，且由于是完美二叉树，每层的节点个数也很容易计算出来（即都是 <code>2</code> 的倍数）。</p><p>&emsp;&emsp;具体做法是使用一个队列，从右到左往队列中添加节点，这样，除了最右侧节点，其他节点在出队时将其 <code>next</code> 指向上一个出队节点即可。</p><p><strong>JS 代码如下：</strong></p><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * // Definition for a Node.</span><span class="hljs-comment"> * function Node(val, left, right, next) &#123;</span><span class="hljs-comment"> *    this.val = val === undefined ? null : val;</span><span class="hljs-comment"> *    this.left = left === undefined ? null : left;</span><span class="hljs-comment"> *    this.right = right === undefined ? null : right;</span><span class="hljs-comment"> *    this.next = next === undefined ? null : next;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Node&#125;</span> <span class="hljs-variable">root</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;Node&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> connect = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">if</span> (!root) &#123;        <span class="hljs-keyword">return</span> root;    &#125;    <span class="hljs-keyword">let</span> queue = [];    <span class="hljs-keyword">let</span> last, cur;    <span class="hljs-keyword">let</span> n = <span class="hljs-number">0</span>, nums = <span class="hljs-number">1</span>;    queue.push(root);    <span class="hljs-keyword">while</span> (queue.length) &#123;        cur = queue.shift();        n++;        <span class="hljs-keyword">if</span> (last) &#123;            cur.next = last;        &#125;        <span class="hljs-keyword">if</span> (cur.right) &#123;            queue.push(cur.right);        &#125;        <span class="hljs-keyword">if</span> (cur.left) &#123;            queue.push(cur.left);        &#125;        last = cur;        <span class="hljs-keyword">if</span> (n === nums) &#123;            nums *= <span class="hljs-number">2</span>;            n = <span class="hljs-number">0</span>;            last = <span class="hljs-literal">null</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> root;&#125;;</code></pre><h2 id="解法2：使用父节点-next-指针"><a href="#解法2：使用父节点-next-指针" class="headerlink" title="解法2：使用父节点 next 指针"></a>解法2：使用父节点 next 指针</h2><p>&emsp;&emsp;首先，如下图，对于当前遍历到的节点 <code>2</code>，我们能够很容易的找到其左孩子的 <code>next</code> 指针所指向的节点（即其右孩子）：<code>root.left.next = root.right;</code></p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201015122151393.png" alt="image-20201015122151393" style="zoom: 67%;" /><p>&emsp;&emsp;而对于其右孩子 <code>5</code>，由于我们在遍历根结点 <code>1</code> 时就设置了节点 <code>2</code> 的 <code>next</code> 指针，因此我们能够使用节点 <code>2</code> 的 <code>next</code> 来找到节点 <code>5</code> 的 <code>next</code> 所要指向的右侧节点：<code>root.right.next = root.next.left;</code></p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201015122450657.png" alt="image-20201015122450657" style="zoom: 67%;" /><p>&emsp;&emsp;根据这种思路，我们能够写出递归版本和迭代版本的代码：</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>&emsp;&emsp;递归版本很直观，就是按照上面的两种情况来的：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> connect = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">if</span> (!root) &#123;        <span class="hljs-keyword">return</span> root;    &#125;    <span class="hljs-keyword">const</span> dfs = <span class="hljs-function">(<span class="hljs-params">root</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (!root) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (root.left) &#123;            root.left.next = root.right;            <span class="hljs-comment">// 若当前节点不是最右侧节点，那么可以通过 next 指针找到其右侧节点</span>            <span class="hljs-keyword">if</span> (root.next) &#123;                root.right.next = root.next.left;            &#125;        &#125;        dfs(root.left);        dfs(root.right);    &#125;;    dfs(root);    <span class="hljs-keyword">return</span> root;&#125;;</code></pre><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>&emsp;&emsp;对于迭代法，我们可以从每一层最左边的节点出发，对每一个遍历到的节点的左右孩子，按照上面的两种情况来获取 <code>next</code> 的指向：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201015143519577.png" alt="image-20201015143519577" style="zoom: 67%;" /><pre><code class="hljs js"><span class="hljs-keyword">var</span> connect = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">if</span> (!root) &#123;        <span class="hljs-keyword">return</span> root;    &#125;    <span class="hljs-keyword">let</span> leftSide = root;    <span class="hljs-keyword">while</span> (leftSide.left) &#123;        <span class="hljs-keyword">let</span> node = leftSide;        <span class="hljs-keyword">while</span> (node) &#123;            node.left.next = node.right;            <span class="hljs-keyword">if</span> (node.next) &#123;                node.right.next = node.next.left;            &#125;            node = node.next;        &#125;        leftSide = leftSide.left;    &#125;    <span class="hljs-keyword">return</span> root;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>解答</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.URL与资源</title>
    <link href="/2020/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/HTTP/2.URL%E4%B8%8E%E8%B5%84%E6%BA%90/"/>
    <url>/2020/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/HTTP/2.URL%E4%B8%8E%E8%B5%84%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;<br><strong>统一资源定位符</strong>（URL）描述了一台特定服务器上某资源的特定位置。</p><h1 id="1-URL-语法"><a href="#1-URL-语法" class="headerlink" title="1. URL 语法"></a>1. URL 语法</h1><p>&emsp;&emsp;大多数 URL 方案的 URL 语法都建立在这个由 9 个部分构成的通用格式上：</p><p><code>&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt;</code></p><p>&emsp;&emsp;URL 最重要的三个部分是：<strong>方案（scheme）</strong>、<strong>主机（host）</strong>和<strong>路径（path）</strong>。下表对这些组件进行了总结：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200923105305698.png" alt="image-20200923105305698" style="zoom:80%;" /><p>&emsp;&emsp;如一个 URL ：<code>http://www.joes-hardware.com:80/index.html</code>，其方案是 <code>http</code>，主机为 <code>www.joes-hardware.com</code>，端口是 <code>80</code>，路径为 <code>/index.html</code>。</p><h2 id="1-1-方案"><a href="#1-1-方案" class="headerlink" title="1.1 方案"></a>1.1 方案</h2><p>&emsp;&emsp;方案是规定如何访问指定资源的主要标识符，它告诉负责解析 URL 的应用程序应该使用什么协议。</p><p><strong>方案是大小写无关的</strong></p><h2 id="1-2-参数"><a href="#1-2-参数" class="headerlink" title="1.2 参数"></a>1.2 参数</h2><p>&emsp;&emsp;HTTP URL 的路径组件可以分为若干路径段，<strong>每段路径都可以有自己的参数</strong>，比如：</p><p><code>http://www.joes-hardware.com/hammers;sale=false/index.html/graphics=true</code></p><p>&emsp;&emsp;这个例子就有两个路径段，且它们都有各自的参数。</p><h2 id="1-3-查询字符串"><a href="#1-3-查询字符串" class="headerlink" title="1.3 查询字符串"></a>1.3 查询字符串</h2><p>&emsp;&emsp;查询字符串是用来缩小所请求资源类型范围的。</p><p>&emsp;&emsp;查询字符串会以一系列 <code>key/value</code> 对的形式出现，中间使用  <code>&amp;</code> 字符分隔。</p><p>&emsp;&emsp;如：<code>http://www.xxx.com/inventory-check?item=12731&amp;color=blue</code></p><p>&emsp;&emsp;这个例子中，查询组件有两个键值对：<code>item=12731</code> 和 <code>color=blue</code>，查询目的是为了查找清单中是否有颜色为 <code>blue</code> 的条目 <code>12731</code>。</p><h2 id="1-4-片段"><a href="#1-4-片段" class="headerlink" title="1.4  片段"></a>1.4  片段</h2><p>&emsp;&emsp;片段主要用于对一个资源内部做进一步的划分。</p><p>&emsp;&emsp;如，一个 URL 可以加上片段来指向一个文档中一个特定的章节或图片。</p><p>&emsp;&emsp;片段挂载 URL 的右边，前面有一个 <code>#</code> 分隔，如：<code>http://www.xxx.com/tools.html#drills</code></p><p>&emsp;&emsp;这个例子中 <code>drills</code> 是 <code>tools.index</code> 这个页面中的一个标题，输入这个 URL 就会自动定位到这个标题开始的位置。</p><p>&emsp;&emsp;HTTP 处理的是整个对象（如 <code>tools.html</code>），而这个对象的片段（<code>#drills</code>）是交给浏览器来处理的。</p><h1 id="2-方案"><a href="#2-方案" class="headerlink" title="2. 方案"></a>2. 方案</h1><p>&emsp;&emsp;下表总结了一些常用的方案：</p><p>&emsp;&emsp;<code>http</code> 默认端口为 <code>80</code> ，<code>https </code> 默认端口为 <code>443</code> </p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201005153537876.png" alt="image-20201005153537876" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201005153643487.png" alt="image-20201005153643487" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201005153709444.png" alt="image-20201005153709444" style="zoom:80%;" />]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>URL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机中的浮点数表示</title>
    <link href="/2020/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E8%A1%A8%E7%A4%BA/"/>
    <url>/2020/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E8%A1%A8%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="IEEE-754-标准"><a href="#IEEE-754-标准" class="headerlink" title="IEEE 754 标准"></a>IEEE 754 标准</h1><p>&emsp;&emsp;在这个标准中，任意一个二进制浮点数 <code>V</code> 可以表示成下面这样的形式：</p><p>&emsp;&emsp;1. <code>(-1)^s</code> 表示符号位，当 <code>s = 0</code> 时， <code>V</code> 为正， <code>s = 1</code> 时，<code>V</code> 为负<br>&emsp;&emsp;2. <code>M</code> 表示有效数字，<code>1 &lt;= M &lt; 2</code><br>&emsp;&emsp;3. <code>E</code> 表示指数，如 <code>2^E</code></p><p>&emsp;&emsp;举个例子，对于十进制的 <code>5.0</code>，写成<strong>二进制</strong>就是 <code>101.0</code>，相当于 <code>1.01 x 2^2</code>。</p><p>&emsp;&emsp;按照上面的标准，可以得出： <code>s = 0</code>，<code>M = 1.01</code> ， <code>E = 2</code></p><p>&emsp;&emsp;IEEE 754 规定，对于 <strong>32 位</strong>的浮点数，最高的 <code>1</code> 位是符号位 <code>s</code>，接着的 <code>8</code> 位是指数 <code>E</code>，剩下的 <code>23</code> 位为有效数字 <code>M</code>:</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/bg2010060601.png" alt="img"  /><p>&emsp;&emsp;对于 <strong>64位</strong> 的浮点数，最高的 <code>1</code>位是符号位 <code>S</code> ，接着的 <code>11</code> 位是指数 <code>E</code>，剩下的 <code>52</code> 位为有效数字 <code>M</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/bg2010060602.png" alt="img"></p><p>&emsp;&emsp;在 IEEE 754 标准中，对 <code>M</code> 和 <code>E</code> 还有一些特别的规定，用于应对一些极端情况。</p><p>&emsp;&emsp;<strong>对于<code>M</code></strong>,前面有提到， <code>1 &lt;= M &lt; 2</code>，也就是说， <code>M</code> 可以写成 <code>1.xxxx</code> 的形式，其中 <code>xxxx</code> 表示小数部分。既然我们知道<strong>计算机在保存 <code>M</code> 时第一位默认总是 <code>1</code></strong>,那么我们可以先省略这个数，只保存 <code>xxxx</code> 这样的小数部分，然后在最后的结果前再加上 <code>1</code>，这样，我们就能多出一位来保存小数 <code>xxxx</code> 了。IEEE 754 中就是这样规定的。  </p><p>&emsp;&emsp;<strong>对于<code>E</code></strong>,情况会复杂些：</p><p>&emsp;&emsp;首先，<code>E</code> 是一个无符号整数，若 <code>E</code> 为 <code>8</code> 位，它的取值范围就是 <code>0 - 255</code>，若 <code>E</code> 为 <code>11</code> 位，它的取值范围就是 <code>0 - 2047</code>，但是，在科学计数法中，指数位 <code>E</code> 是能取负值的，因此 IEEE 754 中规定,<strong><code>E</code> 的真实值需要再减去一个中间数</strong>,相当于是一个偏置（bias），<strong>对于 <code>8</code> 位的 <code>E</code>，这个偏置是 <code>127</code>，对于 <code>11</code> 位的 <code>E</code>，这个偏置是 <code>1023</code>。</strong></p><p>&emsp;&emsp;比如，<code>2^10</code> 的 <code>E</code> 是 <code>10</code>，因此在保存为 <code>32</code> 位浮点数时，需要保存为 <code>10 + 127 = 137</code>，即 <code>10001001</code>（因为 <code>E</code> 在变成 <code>10</code> 之前，减去了一个偏置 <code>127</code>）</p><p>&emsp;&emsp;<code>E</code> 还能分成三种情况讨论：</p><ol><li><p><strong>规格化：当 <code>E</code> 的二进制位不全为 <code>0</code>,也不全为 <code>1</code> 时，二进制浮点数 <code>V</code> 为规格化形式。</strong> </p><p>这时 <code>E</code> 的计算就按上面的规则，减去 <code>127</code> 或 <code>1023</code>。如 <code>E</code> 为 <code>10000100</code>，则 <code>E = 132</code> ，<code>E</code> 的真实值 <code>e = 132 - 127 = 5</code> 。</p><p><code>M</code> 也是如之前所述，在左侧加上隐含位 <code>1</code>，也就是  <code>1.M</code>  ，如 <code>M</code> 为 <code>1010...0</code>（ <code>101</code> 后面共 20 个 0），则 <code>1.M = 1.101 = 1.625</code></p></li><li><p><strong>非规格化：当 <code>E</code> 的二进制位全部为 <code>0</code> 时，<code>V</code> 为非规格化形式。</strong> </p><p>这时，<code>E</code> 的计算就是 <code>1 - 127</code> （或 <code>1 - 1023</code>），这样做的目的主要是为了规格化数值和非规格化数值之间的平滑过渡。并且，有效数字 <code>M</code> 不再加上第一位的 <code>1</code>，而是按原样输出：<code>0.xxxx</code>。这样，我们就能表示 <code>±0</code> （具体看符号位 <code>s</code>）和一些非常逼近 <code>0</code> 的小数了。</p></li><li><p><strong>特殊数值： 当E的二进制位全为 <code>1</code> 时为特殊数值。</strong> </p><p>此时，若 <code>M</code> 的二进制位全为 <code>0</code> 则表示 <code>±无穷大</code>（具体看符号位 <code>s</code>），而若 <code>M</code> 的二进制位不全为 <code>0</code>  的话，则表示 <code>NaN</code>（Not a Number），表示这不是一个合法实数或者该数未经初始化。　　</p></li></ol><h1 id="浮点数例子"><a href="#浮点数例子" class="headerlink" title="浮点数例子"></a>浮点数例子</h1><p>&emsp;&emsp;有一段 C 代码是这样的：</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">9</span>;    <span class="hljs-keyword">float</span>* pFloat = (<span class="hljs-keyword">float</span>*)&amp;a;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\n&quot;</span>, a);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, a);    *pFloat = <span class="hljs-number">9.0</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\n&quot;</span>, *pFloat);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, a);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>&emsp;&emsp;程序的打印结果：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201005230741731.png" alt="image-20201005230741731" style="zoom:80%;" /><p>&emsp;&emsp;在上面的代码中，我们先申明了一个整型 <code>a = 9</code>，然后申明了一个浮点指针 <code>pFloat</code> 指向 <code>a</code> 的地址。</p><p>&emsp;&emsp;<strong>1）</strong> 使用浮点数格式打印 <code>a</code> 时，发现为 <code>0.000000</code>；</p><p>&emsp;&emsp;<strong>2）</strong> 然后我们根据 <code>a</code> 的地址 <code>pFloat</code> 修改它的值为 <code>9.0</code>，此时再以整型来打印 <code>a</code>，输出的却是 <code>1091567616</code>。</p><p>&emsp;&emsp;<strong>首先来看 <code>1)</code></strong> ，为什么整型的 <code>9</code> 以浮点格式输出时打印出来的是 <code>0.000000</code>。</p><p>&emsp;&emsp;将 32 位的整型 <code>9</code> 转化为二进制形式，得到： <code>0 0000 0000 000 0000 0000 0000 0000 1001</code> </p><p>&emsp;&emsp;根据前面的知识，可以知道 <code>s = 0</code>，<code>E = 0</code>，<code>M = 0...1001</code>，指数 <code>E</code> 的二进制位全为 <code>0</code>，因此是第二种非规格化的情况，因此浮点数 <code>V</code> 就写成：</p><p><code>V = (-1)^0 x 0.00000000000000000001001 x 2^(-126) = 1.001 x 2^(-146)</code></p><p>&emsp;&emsp;显然，<code>V</code> 是一个非常小的接近 <code>0</code> 的数，因此用十进制小数表示就是 <code>0.000000</code>。</p><p> &emsp;&emsp;<strong>再来看看 <code>2)</code></strong> ，为什么内存中的 <code>9</code> 变成 <code>9.0</code> 后，以整型格式打印，结果会是 <code>1091567616</code>。</p><p>&emsp;&emsp;将浮点数 <code>9.0</code> 转换为二进制小数形式：<code>1001.0</code> 即 <code>1.001 x 2^3</code> ，那么，我们可以知道 <code>s = 0</code>，<code>E = 3 + 127 = 130</code>，二进制表示的话就是 <code>10000010</code> ，<code>M = 100 1000 0000 0000 0000 0000</code>  ，因此，<code>9.0</code> 的二进制形式表示就是：<code>s + E + M</code> ，也就是：<code>0 1000 0010 100 1000 0000 0000 0000 0000</code> ，这个 32 位的二进制，用十进制表示就是：<code>1,091,567,616</code></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>&emsp;&emsp;<strong>很多小数不能准确表示成二进制形式</strong>。比如 <code>0.4</code>，你就无法写出它的精确二进制形式（即 <code>0.5</code>的各次幂的累加），我们只能不断接近 <code>0.4</code>，而不能达到它。</p><p>&emsp;&emsp;因为 <code>0.4</code> 的二进制表示是：<code>0.01100110011....</code> 无限循环，因此我们只能逼近而不能精确表示。</p><hr><p>REF：</p><ul><li><p><a href="https://ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html">https://ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html</a></p></li><li><p><a href="https://blog.csdn.net/linven1911/article/details/2596038">https://blog.csdn.net/linven1911/article/details/2596038</a></p></li><li><p><a href="https://www.zhoulujun.cn/html/theory/ComputerScienceTechnology/Constitution/2016_0714_7860.html">https://www.zhoulujun.cn/html/theory/ComputerScienceTechnology/Constitution/2016_0714_7860.html</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浮点数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 406. 根据身高重建队列</title>
    <link href="/2020/10/04/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/406-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/"/>
    <url>/2020/10/04/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/406-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">https://leetcode-cn.com/problems/queue-reconstruction-by-height/</a></p><p>难度：中等</p><hr><p>&emsp;&emsp;假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对<code>(h, k)</code>表示，其中h是这个人的身高，<code>k</code>是排在这个人前面且身高大于或等于<code>h</code>的人数。 编写一个算法来重建这个队列。</p><p><strong>注意：</strong></p><p>&emsp;&emsp;总人数少于<code>1100</code>人。</p><p><strong>示例</strong></p><p>输入: <code>[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]</code></p><p>输出: <code>[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]</code></p><hr><h2 id="解法1：排序-调整"><a href="#解法1：排序-调整" class="headerlink" title="解法1：排序+调整"></a>解法1：排序+调整</h2><p>&emsp;&emsp;通过观察，我们可以知道，对于一组数据，如示例中的 <code>(7,0)</code> 和 <code>(7,1)</code>，无论它们所处的位置在哪，在最终结果中，它们的相对位置是不会发生变化的：<code>(7,1)</code> 一定会在 <code>(7,0)</code> 的后面，可能中间隔了一个、可能隔了 <code>n</code> 个。</p><p>&emsp;&emsp;因此，我们可以先对这组数据排序，先保证它们的相对位置，具体做法是根据 <code>(h, k)</code> 来排序：我们先按 <code>h</code> 从大到小进行排序，这样保证了对于每一个数 <code>i</code>，它前面的数字都不会小于自身，然后对于 <code>h</code> 相同的数字，按 <code>k</code> 从小到大排序，这样，对于 <code>h</code> 相同的数据，它们的相对位置开始就是正确的。</p><p>&emsp;&emsp;之后，遍历这组排序过的数据，我们使用 <code>tuple</code> 来表示一个 <code>(h, k)</code> 对，遍历过程中，数组索引 <code>i</code> 能够表示不小于当前 <code>tuple</code> 的所有 <code>tuple</code> 的个数（因为我们提前按 <code>h</code> 进行排序了），这样，我们只要根据每个 <code>tuple</code> 的 <code>k</code> 来进行调整即可。</p><p>&emsp;&emsp;具体调整方法是：对于当前的 <code>tuple</code> ，若 <code>k &lt; i</code> ，说明在当前 <code>tuple</code> 前面的位置，比它高的 <code>tuple</code> 个数太多了，需要将这个 <code>tuple</code> 向前调整 <code>i-k</code> 个位置，让其前面的 <code>tuple</code> 个数刚好等于 <code>k</code>，也就是移动到第 <code>k</code> 个位置。且这样调整并不会影响到已调整的序列，因为那些数据的相对位置并不会发生改变。</p><p><strong>JS 代码：</strong></p><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">people</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> reconstructQueue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">people</span>) </span>&#123;    <span class="hljs-keyword">if</span> (people.length &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> people;    &#125;    <span class="hljs-keyword">let</span> res = [];    <span class="hljs-comment">// 先根据 h 和 k 排序，主 h 副 k , h 从大到小排序，k 从小到大排序</span>    people.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] === b[<span class="hljs-number">0</span>]) &#123;            <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>];        &#125;        <span class="hljs-keyword">return</span> b[<span class="hljs-number">0</span>] - a[<span class="hljs-number">0</span>];    &#125;);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; people.length; i++) &#123;        <span class="hljs-keyword">let</span> k = people[i][<span class="hljs-number">1</span>];        <span class="hljs-keyword">if</span> (k &lt; i) &#123;            res.splice(k, <span class="hljs-number">0</span>, people[i]);        &#125; <span class="hljs-keyword">else</span> &#123;            res[i] = people[i];        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;;</code></pre><h2 id="解法2：逐个插入、调整"><a href="#解法2：逐个插入、调整" class="headerlink" title="解法2：逐个插入、调整"></a>解法2：逐个插入、调整</h2><p><strong>（第 27/37 个 case 会超时）</strong></p><p>&emsp;&emsp;主要思路是先找到序列的第一个 <code>tuple</code> ，然后根据每个 <code>tuple</code> 的 <code>h</code> 和 <code>k</code> 找到插入的位置，所有数据都插入完成之后，有些 <code>tuple</code> 会因为插入操作而导致站位错误，因此需要逐个检查判断是否站错，若站错，则将这个 <code>tuple</code> 重新插入，反复执行此操作，直到所有数据都满足站位要求：</p><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">people</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> reconstructQueue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">people</span>) </span>&#123;    <span class="hljs-keyword">if</span> (people.length &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> people;    &#125;    <span class="hljs-keyword">let</span> res = [];    <span class="hljs-keyword">let</span> n = people.length;    <span class="hljs-keyword">let</span> first;    <span class="hljs-keyword">let</span> tuple, k, height, insertIndex;    <span class="hljs-comment">// 先进行第一次排序</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        tuple = people[i];        k = tuple[<span class="hljs-number">1</span>];        height = tuple[<span class="hljs-number">0</span>];        insertIndex = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (k === <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">while</span>(insertIndex &lt; res.length &amp;&amp; res[insertIndex][<span class="hljs-number">0</span>] &lt; height) &#123;                insertIndex++;            &#125;            res.splice(insertIndex, <span class="hljs-number">0</span>, tuple);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">while</span>(insertIndex &lt; res.length &amp;&amp; k &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">if</span> (res[insertIndex++][<span class="hljs-number">0</span>] &gt;= height) &#123;                    k--;                &#125;            &#125;            res.splice(insertIndex, <span class="hljs-number">0</span>, tuple);        &#125;    &#125;    <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span>;    <span class="hljs-keyword">while</span>(flag) &#123;        flag = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            tuple = res[i];            k = tuple[<span class="hljs-number">1</span>];            height = tuple[<span class="hljs-number">0</span>];            <span class="hljs-keyword">if</span> (k !== <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">// 遍历当前 tuple 前面的人，看是否满足 k 的要求</span>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;                    <span class="hljs-keyword">let</span> tuple1 = res[j];                    <span class="hljs-keyword">if</span> (tuple1[<span class="hljs-number">0</span>] &gt;= height) &#123;                        k--;                    &#125;                &#125;                <span class="hljs-keyword">if</span> (k !== <span class="hljs-number">0</span>) &#123;                    k = tuple[<span class="hljs-number">1</span>]; <span class="hljs-comment">// k 要重新赋值，用于下面的重新插入</span>                    res.splice(i, <span class="hljs-number">1</span>); <span class="hljs-comment">// 将错误的 tuple 从结果中移除</span>                    flag = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 需要再次判断</span>                    <span class="hljs-keyword">break</span>;                &#125;            &#125;        &#125;        <span class="hljs-comment">// 若存在错误的站位，则重新插入，且 k 、height 和 tuple 可以就使用之前的</span>        <span class="hljs-keyword">if</span> (flag) &#123;            insertIndex = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span>(insertIndex &lt; n<span class="hljs-number">-1</span> &amp;&amp; k &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">if</span> (res[insertIndex++][<span class="hljs-number">0</span>] &gt;= height) &#123;                    k--;                &#125;            &#125;            res.splice(insertIndex, <span class="hljs-number">0</span>, tuple);        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>解答</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 145. 二叉树的后序遍历</title>
    <link href="/2020/09/30/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2020/09/30/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;给定一个二叉树，返回它的 <strong>后序</strong> 遍历。</p><p><strong>示例:</strong></p><p>输入: <code>[1,null,2,3]  </code></p><pre><code class="hljs angelscript"><span class="hljs-number">1</span> \  <span class="hljs-number">2</span> /<span class="hljs-number">3</span></code></pre><p>输出: <code>[3,2,1]</code></p><p><strong>进阶</strong>: 递归算法很简单，你可以通过迭代算法完成吗？</p><h2 id="解法1：借助栈进行后序非递归遍历"><a href="#解法1：借助栈进行后序非递归遍历" class="headerlink" title="解法1：借助栈进行后序非递归遍历"></a>解法1：借助栈进行后序非递归遍历</h2><p>&emsp;&emsp;后序非递归遍历的<strong>关键点</strong>在于判断遍历过程中什么时候该往右走，什么时候该访问节点内容。</p><p>&emsp;&emsp;我们使用一个栈来保存遍历路径上的节点，步骤如下：</p><ol><li>一直往左孩子遍历，遍历过程中保存遍历的节点</li><li>当左孩子为空时，我们访问右孩子</li><li>当左右孩子都为空时，我们访问这个节点内容，并返回到父节点</li><li>每当从孩子节点返回父节点时，需要判断是从左孩子返回的还是从右孩子返回的，若是从左孩子返回的，我们需要继续访问右孩子，而若是从右孩子返回的，我们则访问当前节点，并返回到其父节点。</li></ol><p>&emsp;&emsp;判断一次返回是否是从右孩子返回，我们可以使用一个变量 <code>t</code>，当一个节点返回时，我们使用 <code>t</code> 记录这个节点，在父节点处判断 <code>t</code> 是否与这个节点的右孩子相等，若相等，则说明是从右孩子返回的，否则就是从左孩子返回的。</p><p><strong>C 代码：</strong></p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(struct TreeNode* root, <span class="hljs-keyword">int</span>* returnSize)</span></span>&#123;    <span class="hljs-keyword">int</span>* res = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * <span class="hljs-number">2001</span>);    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>** <span class="hljs-title">stack</span> = <span class="hljs-title">malloc</span>(<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">TreeNode</span>*) * 2001);</span>    <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;    *returnSize = <span class="hljs-number">0</span>;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">r</span>;</span> <span class="hljs-comment">// r 为辅助节点，用于判断当节点返回时，是从哪个方向返回到父节点的。</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">p</span> = <span class="hljs-title">root</span>;</span>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span> || size &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// 先从左走到底</span>        <span class="hljs-keyword">if</span> (p) &#123;            <span class="hljs-built_in">stack</span>[size++] = p;            p = p-&gt;left;        &#125; <span class="hljs-keyword">else</span> &#123;            p = <span class="hljs-built_in">stack</span>[size<span class="hljs-number">-1</span>];            <span class="hljs-comment">// 若右孩子还未遍历，遍历右孩子</span>            <span class="hljs-keyword">if</span> (p-&gt;right &amp;&amp; p-&gt;right != r) &#123;                p = p-&gt;right;            &#125; <span class="hljs-keyword">else</span> &#123;                p = <span class="hljs-built_in">stack</span>[--size];                res[(*returnSize)++] = p-&gt;val;                r = p;                p = <span class="hljs-literal">NULL</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h2 id="解法2：morris-算法"><a href="#解法2：morris-算法" class="headerlink" title="解法2：morris 算法"></a>解法2：morris 算法</h2><p>&emsp;&emsp;Morris 算法一般是用于解决中序遍历的问题，不过若只是需要进行普通的后续遍历， morris 算法也能做到。</p><p>&emsp;&emsp;Morris 算法的步骤可看：<a href="https://yleave.top/2020/09/24/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/Morris%E7%AE%97%E6%B3%95/">Morris 算法</a></p><p>&emsp;&emsp;根据 Morris 算法的思想，<strong>对于每个节点，当它是借助左子树的最右下结点的空指针返回的时候，我们就倒序输出从当前节点到其左子树最右下节点的路径</strong>，就能得到后续遍历的结果了（想不通的一定要手动模拟一下 morris 算法），最后，在 morris 算法结束后，需要加上从根结点到其右子树最右节点的逆序路径，因为 morris 算法在遍历完成后不会再回到根结点。</p><p><strong>JS 代码：</strong></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> postorderTraversal = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = [];    <span class="hljs-keyword">let</span> len = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (!root) &#123;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-keyword">let</span> pre, tmp = root;    <span class="hljs-comment">// 对每个新添加的路径逆序排列</span>    <span class="hljs-keyword">const</span> addPath = <span class="hljs-function">(<span class="hljs-params">root</span>) =&gt;</span> &#123;        <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(root) &#123;            res[len++] = root.val;            root = root.right;            count++;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = len-count, j = len<span class="hljs-number">-1</span>; i &lt; j; i++, j--) &#123;            <span class="hljs-keyword">let</span> tmp = res[i];            res[i] = res[j];            res[j] = tmp;        &#125;    &#125;;    <span class="hljs-keyword">while</span>(root) &#123;        <span class="hljs-keyword">if</span> (root.left) &#123;            pre = root.left;            <span class="hljs-keyword">while</span>(pre.right &amp;&amp; pre.right !== root) &#123;                pre = pre.right;            &#125;            <span class="hljs-keyword">if</span> (!pre.right) &#123;                pre.right = root;                root = root.left;            &#125; <span class="hljs-keyword">else</span> &#123;                pre.right = <span class="hljs-literal">null</span>;                addPath(root.left);                root = root.right;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            root = root.right;        &#125;    &#125;    addPath(tmp);    <span class="hljs-keyword">return</span> res;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>解答</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>后序遍历</tag>
      
      <tag>morris</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>后序非递归遍历</title>
    <link href="/2020/09/30/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/%E5%90%8E%E5%BA%8F%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86/"/>
    <url>/2020/09/30/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/%E5%90%8E%E5%BA%8F%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;对树进行后序非递归遍历一般会借助栈来保存路径上的节点。</p><p>&emsp;&emsp;后序非递归遍历的一个<strong>特点</strong>就是：当访问到一个节点时，栈中所保存的节点正好是这个节点的所有祖先节点，因此后续非递归遍历可用来解决以下问题：</p><ol><li><strong>当给定一个节点时，输出该节点的所有祖先</strong></li><li><strong>输出根结点到叶子节点的所有路径</strong></li><li><strong>求每条路径上的节点值之和</strong></li></ol><p>&emsp;&emsp;后序非递归遍历的<strong>关键点</strong>在于判断遍历过程中什么时候该往右走，什么时候该访问节点内容。</p><p>&emsp;&emsp;我们使用一个栈来保存遍历路径上的节点，步骤如下：</p><ol><li>一直往左孩子遍历，遍历过程中保存遍历的节点</li><li>当左孩子为空时，我们访问右孩子</li><li>当左右孩子都为空时，我们访问这个节点内容，并返回到父节点</li><li>每当从孩子节点返回父节点时，需要判断是从左孩子返回的还是从右孩子返回的，若是从左孩子返回的，我们需要继续访问右孩子，而若是从右孩子返回的，我们则访问当前节点，并返回到其父节点。</li></ol><p>&emsp;&emsp;判断一次返回是否是从右孩子返回，我们可以使用一个变量 <code>t</code>，当一个节点返回时，我们使用 <code>t</code> 记录这个节点，在父节点处判断 <code>t</code> 是否与这个节点的右孩子相等，若相等，则说明是从右孩子返回的，否则就是从左孩子返回的。</p><p><strong>C 代码：</strong></p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(struct TreeNode* root, <span class="hljs-keyword">int</span>* returnSize)</span></span>&#123;    <span class="hljs-keyword">int</span>* res = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * <span class="hljs-number">2001</span>);    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>** <span class="hljs-title">stack</span> = <span class="hljs-title">malloc</span>(<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">TreeNode</span>*) * 2001);</span>    <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;    *returnSize = <span class="hljs-number">0</span>;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">r</span>;</span> <span class="hljs-comment">// r 为辅助节点，用于判断当节点返回时，是从哪个方向返回到父节点的。</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">p</span> = <span class="hljs-title">root</span>;</span>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span> || size &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// 先从左走到底</span>        <span class="hljs-keyword">if</span> (p) &#123;            <span class="hljs-built_in">stack</span>[size++] = p;            p = p-&gt;left;        &#125; <span class="hljs-keyword">else</span> &#123;            p = <span class="hljs-built_in">stack</span>[size<span class="hljs-number">-1</span>];            <span class="hljs-comment">// 若右孩子还未遍历，遍历右孩子</span>            <span class="hljs-keyword">if</span> (p-&gt;right &amp;&amp; p-&gt;right != r) &#123;                p = p-&gt;right;            &#125; <span class="hljs-keyword">else</span> &#123;                p = <span class="hljs-built_in">stack</span>[--size];                res[(*returnSize)++] = p-&gt;val;                r = p;                p = <span class="hljs-literal">NULL</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h2 id="morris-算法遍历节点值"><a href="#morris-算法遍历节点值" class="headerlink" title="morris 算法遍历节点值"></a>morris 算法遍历节点值</h2><p>&emsp;&emsp;若需要使用非递归算法后序遍历节点值，那么可使用 morris 算法实现 <code>O(1)</code> 复杂度的遍历。</p><p>具体可看：<a href="https://yleave.top/2020/09/30/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/#%E8%A7%A3%E6%B3%952%EF%BC%9Amorris-%E7%AE%97%E6%B3%95">使用Morris算法进行后序非递归遍历</a></p>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>算法知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后序非递归遍历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 501. 二叉搜索树中的众数</title>
    <link href="/2020/09/24/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/501-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0/"/>
    <url>/2020/09/24/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/501-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/">https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/</a></p><p>难度：简单</p><hr><p>&emsp;&emsp;给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p><p>假定 BST 有如下定义：</p><ul><li><p>结点左子树中所含结点的值小于等于当前结点的值</p></li><li><p>结点右子树中所含结点的值大于等于当前结点的值</p></li><li><p>左子树和右子树都是二叉搜索树</p></li></ul><p><strong>例如：</strong></p><p>&emsp;&emsp;给定 BST <code>[1,null,2,2]</code>,</p><pre><code class="hljs angelscript"><span class="hljs-number">1</span> \  <span class="hljs-number">2</span> /<span class="hljs-number">2</span></code></pre><p>&emsp;&emsp;返回 <code>[2]</code></p><p><strong>提示</strong>：如果众数超过1个，不需考虑输出顺序</p><p><strong>进阶：</strong> 你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p><hr><h2 id="解法1：中序遍历"><a href="#解法1：中序遍历" class="headerlink" title="解法1：中序遍历"></a>解法1：中序遍历</h2><p>&emsp;&emsp;对于一棵二叉搜索树，若对其进行中序遍历并在遍历过程中顺序记录节点值，那么记录的值会是一个单调递增序列（在本题中是单调不减序列）。</p><p>&emsp;&emsp;这样的话，若要求众数，我们可以先对其进行中序遍历，众数在序列中的位置一定是连续的，如 <code>[1, 2, 2, 2, 3]</code>。这样，我们对这个序列进行遍历并计数，就能够得到它的众数。</p><p>&emsp;&emsp;不过，为了避免使用额外空间，我们可以在遍历过程中就求出众数，具体做法是维护一个 <code>max</code> ，表示当前所遇到的最多的连续数字的个数，然后在遍历过程中累计每个数字出现的次数，若比 <code>max</code> 大，则使用当前数字覆盖结果数组，并更新 <code>max</code> 值。</p><p>&emsp;&emsp;在中序遍历完成之后，我们还需要最后进行一次众数判断，因为最后的连续数字不会在遍历过程中判断是否是众数。</p><p><strong>JS 代码：</strong></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> findMode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = [];    <span class="hljs-keyword">if</span> (!root) &#123;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-keyword">let</span> n;    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> max = <span class="hljs-number">-1</span>;    <span class="hljs-keyword">const</span> dfs = <span class="hljs-function">(<span class="hljs-params">node</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (!node) &#123;            <span class="hljs-keyword">return</span>;        &#125;        dfs(node.left);        <span class="hljs-keyword">if</span> (n === <span class="hljs-literal">undefined</span>) &#123;            n = node.val;            count = <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n === node.val) &#123;            count++;        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 遇到新的数字</span>            <span class="hljs-keyword">if</span> (count &gt; max) &#123;                max = count;                res = [n];            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count === max) &#123;                res.push(n);            &#125;            n = node.val;            count = <span class="hljs-number">1</span>;        &#125;            dfs(node.right);    &#125;;    dfs(root);    <span class="hljs-keyword">if</span> (count &gt; max) &#123;        max = count;        res = [n];    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count === max) &#123;        res.push(n);    &#125;    <span class="hljs-keyword">return</span> res;&#125;;</code></pre><p>C 版本：</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> max;<span class="hljs-keyword">int</span> count;<span class="hljs-keyword">int</span> cur;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(struct TreeNode* root, <span class="hljs-keyword">int</span>* res, <span class="hljs-keyword">int</span>* returnSize)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!root) &#123;        <span class="hljs-keyword">return</span>;    &#125;    dfs(root-&gt;left, res, returnSize);    <span class="hljs-keyword">if</span> (count == <span class="hljs-number">-1</span>) &#123;        cur = root-&gt;val;        count = <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur == root-&gt;val) &#123;        count++;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">if</span> (max &lt; count) &#123;            max = count;            *returnSize = <span class="hljs-number">0</span>;            res[(*returnSize)++] = cur;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (max == count) &#123;            res[(*returnSize)++] = cur;        &#125;        cur = root-&gt;val;        count = <span class="hljs-number">1</span>;    &#125;    dfs(root-&gt;right, res, returnSize);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">findMode</span><span class="hljs-params">(struct TreeNode* root, <span class="hljs-keyword">int</span>* returnSize)</span></span>&#123;    *returnSize = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> *res = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * <span class="hljs-number">4001</span>);    count = <span class="hljs-number">-1</span>;    max = <span class="hljs-number">-1</span>;    <span class="hljs-keyword">if</span> (!root) &#123;        <span class="hljs-keyword">return</span> res;    &#125;    dfs(root, res, returnSize);    <span class="hljs-keyword">if</span> (max &lt; count) &#123;        max = count;        *returnSize = <span class="hljs-number">0</span>;        res[(*returnSize)++] = cur;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (max == count) &#123;        res[(*returnSize)++] = cur;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h2 id="解法2：Morris-算法"><a href="#解法2：Morris-算法" class="headerlink" title="解法2：Morris 算法"></a>解法2：Morris 算法</h2><p>&emsp;&emsp;所有能使用中序遍历解决的问题都能使用 Morris 算法来优化其空间复杂度。</p><p>&emsp;&emsp;<a href="https://yleave.top/2020/09/24/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/Morris%E7%AE%97%E6%B3%95/">Morris 算法详情可看</a></p><p>&emsp;&emsp;在使用 Morris 算法时最重要的是要把握好节点遍历的时机。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> findMode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = [];    <span class="hljs-keyword">if</span> (!root) &#123;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-keyword">let</span> n;    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> max = <span class="hljs-number">-1</span>;    <span class="hljs-keyword">let</span> pre;    <span class="hljs-keyword">const</span> check = <span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (max &lt; count) &#123;            max = count;            res = [n];        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (max === count) &#123;            res.push(n);        &#125;    &#125;;    <span class="hljs-keyword">while</span> (root) &#123;        <span class="hljs-keyword">if</span> (root.left) &#123;            pre = root.left;            <span class="hljs-keyword">while</span> (pre.right &amp;&amp; pre.right !== root) &#123;                pre = pre.right;            &#125;            <span class="hljs-keyword">if</span> (!pre.right) &#123;                pre.right = root;                root = root.left;            &#125; <span class="hljs-keyword">else</span> &#123;                 <span class="hljs-comment">// 此时是刚从左孩子节点返回之后，往右孩子遍历</span>                <span class="hljs-keyword">if</span> (n === <span class="hljs-literal">undefined</span>) &#123;                    n = root.val;                    count = <span class="hljs-number">1</span>;                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n === root.val) &#123;                    count++;                &#125; <span class="hljs-keyword">else</span> &#123;                    check();                    n = root.val;                    count = <span class="hljs-number">1</span>;                &#125;                pre.right = <span class="hljs-literal">null</span>;                root = root.right;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// 节点此时可能是借助前面设置的空闲指针返回父节点，也可能是从父节点到右节点遍历的过程</span>            <span class="hljs-keyword">if</span> (n === <span class="hljs-literal">undefined</span>) &#123;                n = root.val;                count = <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n === root.val) &#123;                count++;            &#125; <span class="hljs-keyword">else</span> &#123;                check();                n = root.val;                count = <span class="hljs-number">1</span>;            &#125;            root = root.right;        &#125;    &#125;    check();    <span class="hljs-keyword">return</span> res;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>解答</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中序遍历</tag>
      
      <tag>LeetCode</tag>
      
      <tag>二叉搜索树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Morris算法</title>
    <link href="/2020/09/24/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/Morris%E7%AE%97%E6%B3%95/"/>
    <url>/2020/09/24/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/Morris%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Morris-算法介绍"><a href="#Morris-算法介绍" class="headerlink" title="Morris 算法介绍"></a>Morris 算法介绍</h1><p>&emsp;&emsp;Morris 算法是一种中序遍历算法，它能够将中序遍历的空间复杂度优化到 <code>O(1)</code>！</p><p>&emsp;&emsp;正常的中序遍历算法，无论是递归还是迭代，都需要使用到栈来保存节点，因此空间复杂度一般和树的节点数有关，而 Morris 算法是使用了树中子结点的空闲的指针来完成遍历过程。具体是通过底层节点指向<code>NULL</code>的空闲指针返回上层的某个节点，从而完成下层到上层的移动。</p><p><strong>Morris 遍历算法</strong>整体步骤如下（假设当前遍历到的节点为 <code>x</code>）：</p><ol><li>如果 <code>x</code> 无左孩子，则访问 <code>x</code> 的右孩子，即 <code>x = x.right</code></li><li>如果 <code>x</code> 有左孩子，则<strong>找到 <code>x</code> 左子树上最右的节点</strong>（即左子树中序遍历的最后一个节点，是 <code>x</code> 在中序遍历中的前驱节点），记为 <code>predecessor</code> 。<ul><li>如果 <code>predecessor</code> 的右孩子为空，则将其右孩子指向 <code>x</code>，然后访问 <code>x</code> 的左孩子，即 <code>x = x.left</code></li><li>如果 <code>predecessor</code> 的右孩子不为空，则此时右孩子是指向 <code>x</code> 的，说明我们已经遍历完了左孩子；这时将 <code>predecessor</code> 的右孩子置空，然后访问 <code>x</code> 的右孩子，即 <code>x = x.right</code></li></ul></li><li>重复上述步骤，直到访问完整棵树，即 <code>x = null</code> 时。</li></ol><p>&emsp;&emsp;(没搞清楚的话可以自己模拟一个简单的二叉树试试)</p><p>&emsp;&emsp;感觉这个有点像是线索二叉树，不过这边的线索只是帮助遍历二叉树，用完一次就会清除。</p><p><strong>下面是 Morris 中序遍历算法的模板：</strong></p><p><strong>JS 版本：</strong></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> inOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">let</span> predecessor;    <span class="hljs-keyword">while</span>(root) &#123;        <span class="hljs-keyword">if</span> (root.left) &#123;            <span class="hljs-keyword">let</span> predecessor = root.left;            <span class="hljs-comment">// 找到左子树的最右节点</span>            <span class="hljs-keyword">while</span>(predecessor.right &amp;&amp; predecessor.right !== root) &#123;                predecessor = predecessor.right;            &#125;            <span class="hljs-comment">// 若右孩子为空，表示第一次遍历到这个节点，将其右孩子设为root</span>            <span class="hljs-keyword">if</span> (!predecessor.right) &#123;                predecessor.right = root;                root = root.left;            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 否则， root 的左子树已经遍历完了，这时相当于中序遍历从左子树回到父节点</span>                <span class="hljs-comment">// 此时是刚从左孩子节点返回之后，往右孩子遍历</span>                root = root.right;                predecessor.right = <span class="hljs-literal">null</span>;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 节点此时可能是借助前面设置的空闲指针返回父节点，也可能是从父节点到右节点遍历的过程</span>            root = root.right;        &#125;    &#125;&#125;;</code></pre><p><strong>C++ 版本：</strong></p><pre><code class="hljs c++">TreeNode *cur = root, *pre = <span class="hljs-literal">nullptr</span>;<span class="hljs-keyword">while</span> (cur) &#123;    <span class="hljs-keyword">if</span> (!cur-&gt;left) &#123;        <span class="hljs-comment">// ...遍历 cur</span>        cur = cur-&gt;right;        <span class="hljs-keyword">continue</span>;    &#125;    pre = cur-&gt;left;    <span class="hljs-keyword">while</span> (pre-&gt;right &amp;&amp; pre-&gt;right != cur) &#123;        pre = pre-&gt;right;    &#125;    <span class="hljs-keyword">if</span> (!pre-&gt;right) &#123;        pre-&gt;right = cur;        cur = cur-&gt;left;    &#125; <span class="hljs-keyword">else</span> &#123;        pre-&gt;right = <span class="hljs-literal">nullptr</span>;        <span class="hljs-comment">// ...遍历 cur</span>        cur = cur-&gt;right;    &#125;&#125;</code></pre><h1 id="Morris-算法实际应用"><a href="#Morris-算法实际应用" class="headerlink" title="Morris 算法实际应用"></a>Morris 算法实际应用</h1><p><a href="https://yleave.top/2020/09/24/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/501-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0/">LeetCode 501. 二叉搜索树中的众数</a></p>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>算法知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中序遍历</tag>
      
      <tag>Morris</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 968.监控二叉树</title>
    <link href="/2020/09/23/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/LeetCode-968-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/09/23/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/LeetCode-968-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-tree-cameras/">https://leetcode-cn.com/problems/binary-tree-cameras/</a></p><p>难度：困难</p><hr><p>&emsp;&emsp;给定一个二叉树，我们在树的节点上安装摄像头。</p><p>&emsp;&emsp;节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象。</strong></p><p>&emsp;&emsp;计算监控树的所有节点所需的最小摄像头数量。</p><p><strong>示例 1：</strong></p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200922220425128.png" alt="image-20200922220425128" style="zoom:80%;" /> <p>&emsp;&emsp;输入：<code>[0,0,null,0,0]</code></p><p>&emsp;&emsp;输出：<code>1</code></p><p>&emsp;&emsp;解释：如图所示，一台摄像头足以监控所有节点。</p><p><strong>示例 2：</strong></p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200922220447483.png" alt="image-20200922220447483" style="zoom:67%;" /> <p>&emsp;&emsp;输入：<code>[0,0,null,0,null,0,null,null,0]</code></p><p>&emsp;&emsp;输出：<code>2</code></p><p>&emsp;&emsp;解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。</p><p><strong>提示：</strong></p><ol><li>给定树的节点数的范围是 <code>[1, 1000]</code>。</li><li>每个节点的值都是 0。</li></ol><h2 id="解法1：递归-状态判断"><a href="#解法1：递归-状态判断" class="headerlink" title="解法1：递归+状态判断"></a>解法1：递归+状态判断</h2><p>&emsp;&emsp;仔细思考，根据题目，我们可以知道，对于一个节点 <code>node</code>，它只可能会存在三种状态（下图中<strong>红色</strong>代表安装监控器，<strong>蓝色</strong>代表被监控到，<strong>绿色</strong>代表未被监控到，或是监控与未监控两者都可）：</p><ul><li><p><code>node</code> 任意一个孩子结点已安装监视器，那么当前 <code>node</code> 节点也会被监控到，这种状态记为 <code>1</code>；</p><p>关于下面<strong>右孩子的蓝色</strong>，这边解释一下，因为我们是从下往上遍历的，且因为一些条件判断，我们会保证遇到这种情况时，孩子结点会处于监控状态，具体可看代码。</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200922213305179.png" alt="image-20200922213305179" style="zoom:80%;" /></li><li><p><code>node</code> 任意一个孩子节点未安装监视器，且该孩子节点也未被监控到，那么当前节点必须安装监视器，这种状态我们记为 <code>2</code>；</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200922214339811.png" alt="image-20200922214339811" style="zoom:80%;" /></li><li><p><code>node</code> 的孩子节点都没安装监视器，但是都被监控到了，那么当前节点可以安装监视器，也可以不安装监视器，但是本着节省资源的目的，需要将这种情况返回给父节点，让父节点做裁断（到底是父节点安装，还是当前节点安装）。</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200922214438620.png" alt="image-20200922214438620" style="zoom:80%;" /><p>​    <strong>JS 代码：</strong></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> minCameraCover = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;  <span class="hljs-keyword">const</span> dfs = <span class="hljs-function">(<span class="hljs-params">node</span>) =&gt;</span> &#123;      <span class="hljs-keyword">if</span> (!node) &#123; <span class="hljs-comment">// 对于空节点，默认其是未安装监视器且被监控到的状态</span>          <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;      &#125;      <span class="hljs-keyword">let</span> left = dfs(node.left), right = dfs(node.right);      <span class="hljs-comment">// 若有一个孩子结点未被监控到，那么当前节点需要安装监控器，造成的结果就是返回父节点时，表现是安装了监控器</span>      <span class="hljs-keyword">if</span> (left === <span class="hljs-number">2</span> || right === <span class="hljs-number">2</span>) &#123;          res++;          <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;      &#125;      <span class="hljs-comment">// 否则，若有一个孩子结点安装了监控器，当前节点会处于被监控的状态，且上面的判断语句已经排除了有孩子结点未被监控到的情况，因此当前节点返回到其父节点的表现就是没装监控器但是被监控到的情况</span>      <span class="hljs-keyword">if</span> (left === <span class="hljs-number">1</span> || right === <span class="hljs-number">1</span>) &#123;          <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;      &#125;      <span class="hljs-comment">// 否则，当前节点会处于未装监控器且未被监控到的情况，也就是状态 2.</span>      <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;  &#125;;  <span class="hljs-keyword">if</span> (dfs(root) === <span class="hljs-number">2</span>) &#123;      res++;  &#125;  <span class="hljs-keyword">return</span> res;&#125;;</code></pre></li></ul><h2 id="解法2：递归"><a href="#解法2：递归" class="headerlink" title="解法2：递归"></a>解法2：递归</h2><p>&emsp;&emsp;<strong>解法2是官方的解题思路，看了几遍才看懂…..因此附上一些自己的理解。</strong></p><p>&emsp;&emsp;<strong>约定</strong>：若某棵树的所有节点都被监控，则称这棵树被<strong>覆盖</strong>。</p><p>&emsp;&emsp;设当前节点为 <code>root</code>，其左右孩子为 <code>left</code> 和 <code>right</code> 。若想要覆盖以 <code>root</code> 为根的树，那么有两种情况：</p><ul><li>情况1：若给 <code>root</code> 设置了摄像头，那么其孩子节点 <code>left</code>、<code>right</code> 也会被监控到。此时只需要保证 <code>left</code> 和 <code>right</code> <strong>的</strong>两棵子树也被覆盖即可。</li><li>情况2：若 <code>root</code> 没有设置摄像头，那么除了要保证以<code>left</code>为根结点的树 和 以<code>right</code>为根结点的树被覆盖之外，还需要保证 <code>left</code> 和 <code>right</code> 之中至少有一个节点安装了摄像头，这样 <code>root</code> 才能被监控到。</li></ul><p>&emsp;&emsp;根据这两种情况，我们可以分析出，对于每个 <code>root</code> ，需要维护三种类型的状态：</p><ul><li>状态 <code>a</code> ：<code>root</code> 必须安装摄像头的情况下（即情况1），覆盖整棵树需要的摄像头数量；</li><li>状态 <code>b</code> ：不论 <code>root</code> 是否安装摄像头，覆盖整棵树需要的摄像头数量；（也就是若 <code>root</code> 安置摄像头的话最好，不然 <code>left</code> 或 <code>right</code> 两个节点中需要至少一个有安置摄像头来保证 <code>root</code> 被监控）</li><li>状态 <code>c</code> ：不论 <code>root</code> 是否被<strong>监控</strong>到，覆盖两棵子树需要的摄像头数量；（对应着情况 1 和情况 2 中， <code>left</code>树 和 <code>right</code>树被覆盖，而<code>root</code> 是否被监控表示 <code>left</code> 或 <code>right</code> 节点可能有安置摄像头，也可能未安置摄像头）</li></ul><p>&emsp;&emsp;根据以上定义，一定有 <code>a &gt;= b &gt;= c</code></p><p>&emsp;&emsp;设 <code>root</code> 节点的左右孩子节点<code>left</code>、<code>right</code>维护的状态变量为：$(l_a,l_b,l_c)$ 和 $(r_a,r_b,r_c)$ ，那么：</p><ul><li>$a = l_c + r_c + 1$ ：即左右子树被覆盖所需的摄像头数量加上 <code>root</code> 安置的 1 个摄像头</li><li>$b = min(a, min(l_a + r_b, l_b + r_a))$ ：即两种情况中的最小值，情况 2 中需要 <code>left</code> 和 <code>right</code> 中至少一个节点设置摄像头来保证 <code>root</code> 被监控，因此是 <strong><code>left</code> 设置 + <code>right</code> 未设置</strong> 与 <strong><code>left</code> 未设置 + <code>right</code> 设置</strong> 这两种取值中的最小值。</li></ul><p>&emsp;&emsp;对于状态 <code>c</code> 而言，只需要保证 <code>left</code> 和 <code>right</code> 两棵子树被覆盖即可（包括 <code>left</code> 和 <code>right</code>）。</p><p>&emsp;&emsp;那么，要么 <code>root</code> 处设置一个摄像头（保证 <code>left</code> 和 <code>right</code> 这两个节点被监控）的情况下<code>left</code> 和 <code>right</code> <strong>的</strong>两棵子树刚好也被覆盖，那么就是状态<code>a</code> 的摄像头数量；</p><p>&emsp;&emsp;要么 <code>root</code> 处不放置摄像头，<code>left</code> 和 <code>right</code> 两棵子树保证自己被覆盖，所需的摄像头数量就是 $l_b + r_b$。</p><p>&emsp;&emsp;需要额外注意的是，对于 <code>root</code> 而言，如果其某个孩子为空，则不能通过在该孩子处放置摄像头的方式，监控到当前节点。因此，该孩子对应的变量 <code>a</code> 应当返回一个大整数，用于标识不可能的情形。</p><p>&emsp;&emsp;最终，根节点的状态变量 <code>b</code> 即为要求出的答案。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> minCameraCover = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">const</span> dfs = <span class="hljs-function">(<span class="hljs-params">root</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (!root) &#123;            <span class="hljs-keyword">return</span> [<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Number</span>.MAX_SAFE_INTEGER / <span class="hljs-number">2</span>), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>];        &#125;        <span class="hljs-keyword">const</span> [la, lb, lc] = dfs(root.left);        <span class="hljs-keyword">const</span> [ra, rb, rc] = dfs(root.right);        <span class="hljs-keyword">const</span> a = lc + rc + <span class="hljs-number">1</span>;        <span class="hljs-keyword">const</span> b = <span class="hljs-built_in">Math</span>.min(a, <span class="hljs-built_in">Math</span>.min(la + rb, ra + lb));        <span class="hljs-keyword">const</span> c = <span class="hljs-built_in">Math</span>.min(a, lb + rb);        <span class="hljs-keyword">return</span> [a, b, c];    &#125;    <span class="hljs-keyword">return</span> dfs(root)[<span class="hljs-number">1</span>];&#125;;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1. HTTP概述</title>
    <link href="/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/HTTP/1.HTTP%E6%A6%82%E8%BF%B0/"/>
    <url>/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/HTTP/1.HTTP%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-WEB资源"><a href="#1-WEB资源" class="headerlink" title="1. WEB资源"></a>1. WEB资源</h1><h2 id="1-1-媒体类型"><a href="#1-1-媒体类型" class="headerlink" title="1.1 媒体类型"></a>1.1 媒体类型</h2><p>&emsp;&emsp;MIME（Multipurpose Internet Mail Extention，多用途因特网邮件拓展）。</p><p>&emsp;&emsp;MIME类型 （MIME type）是一种文本标记，表示一种主要的对象类型和一个特定的子类型，中间由一条斜杠来分隔。</p><p>&emsp;&emsp;WEB 服务器会为所有的 HTTP 对象数据附加一个 MIME 类型，当 WEB 浏览器从服务器中取回一个对象时，会检查相关的 MIME 类型，看看它是否知道如何处理这个对象。</p><p>常见的 MIME 类型有数百个，部分如下所示：</p><ul><li>HTML 格式的文本文档由 <code>text/html</code> 类型来标记</li><li>普通的 ASCII 文本文档由 <code>text/plain</code> 类型来标记</li><li>JPEG 格式的图片为 <code>image/jpeg</code> 类型</li><li>GIF 格式的图片为 <code>image/jif</code> 类型</li><li>Apple 的 QuickTime 电影为 <code>video/quicktime</code> 类型</li><li>……</li></ul><h2 id="1-2-URI"><a href="#1-2-URI" class="headerlink" title="1.2 URI"></a>1.2 URI</h2><p>&emsp;&emsp;每个 WEB 服务器资源都有一个名字，这些名字被统称为 <strong>统一资源标识符</strong>（Uniform Resource Identifier, URI）。</p><p>&emsp;&emsp;URI 有两种形式，分别称为 URL 和 URN，不过 URN 见的较少，现在几乎所有的 URI 都是 URL，这边没有记录 URN。</p><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>&emsp;&emsp;<strong>统一资源定位符</strong>（URL）描述了一台特定服务器上某资源的特定位置。</p><p><strong>URL 说明了协议、服务器和本地资源</strong> ：</p><p>​    <img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200920183803074.png" alt="image-20200920183803074" style="zoom:80%;" /></p><p>大部分 URL 都遵循着一种标准格式，这个格式包含三个部分：</p><ul><li>URL 的第一部分被称为方案（scheme），说明了访问资源所使用的协议类型。如 <code>http://</code> 。</li><li>第二部分个给出了服务器的因特网地址，如 <code>www.joes-hardware.com</code>。</li><li>其余部分指定了 WEB 服务器上的某个资源，如 <code>/specials/saw-blade.gif</code>。</li></ul><h2 id="1-3-事务"><a href="#1-3-事务" class="headerlink" title="1.3 事务"></a>1.3 事务</h2><p>&emsp;&emsp;一个 HTTP 事务是由一条（客户端发往服务器）请求命令和一个（服务器发回客户端）响应结果组成。</p><p>&emsp;&emsp;这种通信是通过名为 HTTP 报文（HTTP message）的格式化数据块进行的。如下图所示：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200921090503302.png" alt="image-20200921090503302" style="zoom: 67%;" /><h2 id="1-4-方法"><a href="#1-4-方法" class="headerlink" title="1.4 方法"></a>1.4 方法</h2><p>&emsp;&emsp;每条 HTTP 请求报文都包含一个方法（HTTP method），这个方法会告诉服务器需要执行什么动作（获取一个 Web 页面、运行一个网关程序、删除一个程序等）。下表列出了五种常见的 HTTP 方法：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200921090837035.png" alt="image-20200921090837035" style="zoom:75%;" /><h2 id="1-5-状态码"><a href="#1-5-状态码" class="headerlink" title="1.5 状态码"></a>1.5 状态码</h2><p>&emsp;&emsp;每条 HTTP 响应报文返回时都会携带一个状态码。状态码是一个三位数字的代码，它会告知客户端这条请求的状态，下表显示了几种常见的状态码：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200921091213730.png" alt="image-20200921091213730" style="zoom:80%;" /><h1 id="2-报文"><a href="#2-报文" class="headerlink" title="2. 报文"></a>2. 报文</h1><p>&emsp;&emsp;HTTP 报文是由一行一行的简单字符串组成的。HTTP 报文是纯文本，不是二进制代码。</p><p>&emsp;&emsp;下图是一个简单事务所使用的报文：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200921093721791.png" alt="image-20200921093721791" style="zoom: 80%;" /><p>&emsp;&emsp;HTTP 报文只包含两种类型：<strong>请求报文</strong> (request message) 和<strong>响应报文</strong> (response message) 。</p><p>HTTP 报文包括以下三个部分：</p><ul><li>起始行：报文的第一行是起始行，在<strong>请求报文</strong>中用于说明要做些说明，在<strong>响应报文</strong>中说明出现了什么情况。</li><li>首部字段：起始行后有零或多个首部字段。一个首部字段包含一个字段名和值，两者使用 <code>:</code> 分隔。首部字段以一个空行结束。</li><li>主体：首部字段的空行之后就是可选的报文主体。<strong>请求主体</strong>中包含了要发送给 Web 服务器的数据；<strong>响应主体</strong>中装载了要返回给客户端的数据。与起始行和首部不同，主体中可以包含文本或任意的二进制数据（如图片、视频、音频、软件程序等）。</li></ul><h1 id="3-连接"><a href="#3-连接" class="headerlink" title="3. 连接"></a>3. 连接</h1><p>&emsp;&emsp;报文是通过<strong>传输控制协议</strong>（Transmission Control Protocol，<strong>TCP</strong>）连接从一个地方传递到另一个地方。</p><h2 id="3-1-TCP-IP"><a href="#3-1-TCP-IP" class="headerlink" title="3.1 TCP/IP"></a>3.1 TCP/IP</h2><p>&emsp;&emsp;HTTP 是个应用层协议，其内部的通信细节都由 TCP/IP 来完成。</p><p>TCP 提供了：</p><ul><li>无差错的数据传输</li><li>按序传输（数据总是会按照发送的顺序到达）</li><li>未分段的数据流（可以在任意时刻以任意尺寸将数据发送出去）</li></ul><p>&emsp;&emsp;HTTP 位于 TCP 的上层，下图是 HTTP 网络协议栈：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200921095353410.png" alt="image-20200921095353410" style="zoom: 80%;" /><h2 id="3-2-连接、IP-地址及端口号"><a href="#3-2-连接、IP-地址及端口号" class="headerlink" title="3.2 连接、IP 地址及端口号"></a>3.2 连接、IP 地址及端口号</h2><p>&emsp;&emsp;在 HTTP 客户端向服务器发送报文之前，需要使用网际协议（Internet Protocol，IP）地址和端口号在客户端和服务器之间建立一条 TCP/IP 连接。</p><p>&emsp;&emsp;建立 TCP 连接的过程类似于给公司办公室的某个人打电话的过程；首先，需要拨打正确的公司的电话号码，然后再拨打那个人的公司分机号。</p><p>&emsp;&emsp;HTTP 服务器的 IP 和端口号是通过 URL 获取的。</p><p>如 </p><ul><li><code>http://207.200.83.29:80/index.html</code></li><li><code>http://www.netscape.com:80/index.html</code></li><li><code>http://www.metscape.com/index.html</code></li></ul><p>&emsp;&emsp;第三条 URL 中没有指定端口号则会使用默认的端口号，如 <code>80</code></p><p>&emsp;&emsp;下图是一个基本的浏览器连接处理过程：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200921100649034.png" alt="image-20200921100649034" style="zoom: 80%;" /><p>步骤如下：</p><ol><li>浏览器从 URL 中解析出服务器的主机名；</li><li>浏览器将服务器的主机名转换成服务器的 IP 地址；</li><li>浏览器将端口号（若有指定）从 URL 中解析出来；</li><li>浏览器建立一条与 WEB 服务器的 TCP 连接；</li><li>浏览器向服务器发送一条 HTTP 请求报文；</li><li>服务器向浏览器会送一条 HTTP 响应报文；</li><li>关闭连接，浏览器显示文档。</li></ol><h1 id="4-协议版本"><a href="#4-协议版本" class="headerlink" title="4. 协议版本"></a>4. 协议版本</h1><p>HTTP 有多个协议版本：</p><ul><li>HTTP/0.9</li><li>HTTP/1.0</li><li>HTTP/1.0+</li><li>HTTP/1.1</li><li>HTTP-NG (又名 HTTP/2.0)</li></ul><p>&emsp;&emsp;不过目前在广泛使用的仍是 HTTP/1.1 版本</p><h1 id="5-Web-的结构组件"><a href="#5-Web-的结构组件" class="headerlink" title="5. Web 的结构组件"></a>5. Web 的结构组件</h1><h2 id="5-1-代理"><a href="#5-1-代理" class="headerlink" title="5.1 代理"></a>5.1 代理</h2><p>&emsp;&emsp;代理是位于客户端和服务器之间的 HTTP 中间实体，它是 Web 安全、应用集成以及性能优化的重要组成模块。</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-2020092110112604125.png" alt="image-2020092110260412511" style="zoom:80%;" /><p>&emsp;&emsp;代理接收所有客户端的 HTTP 请求，并将这些请求转发给服务器（可能会对请求进行修改）。代理还能对请求和响应进行过滤，比如对下载的应用程序进行病毒检测、或对小学生屏蔽一些成年人才能看的内容。</p><h2 id="5-2-缓存"><a href="#5-2-缓存" class="headerlink" title="5.2 缓存"></a>5.2 缓存</h2><p>&emsp;&emsp;缓存是 HTTP 的仓库，常用的页面副本可以保存在离客户端更近的地方。</p><p>&emsp;&emsp;Web 缓存（Web cache）或代理缓存（proxy cache）是一种特殊的 HTTP 代理服务器，可将经过代理的常用文档的副本保存下来，下次再访问这个资源时就能直接在代理服务器上下载，加快了下载速度。</p><h2 id="5-3-网关"><a href="#5-3-网关" class="headerlink" title="5.3 网关"></a>5.3 网关</h2><p>&emsp;&emsp;网关（gateway）是一种特殊的服务器，作为其他服务器的中间实体使用。</p><p>&emsp;&emsp;通常用于将 HTTP 流量转换成其他的协议。</p><p>&emsp;&emsp;例如，一个 HTTP/FTP 网关会通过 HTTP 请求接收对 FTP URI 的请求，但通过 FTP 协议来获取文档。得到的文档会封装成一条 HTTP 报文，发送给客户端。</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200921104641330.png" alt="image-20200921104641330" style="zoom:80%;" /><h2 id="5-4-隧道"><a href="#5-4-隧道" class="headerlink" title="5.4 隧道"></a>5.4 隧道</h2><p>&emsp;&emsp;隧道（tunnel）是建立起来之后，就会在两条连接之间对原始数据进行盲转发的 HTTP 应用程序。</p><p>&emsp;&emsp;HTTP 隧道通常用来在一条或多条 HTTP 连接上转发非 HTTP 数据，转发时不会窥探数据。</p><p>&emsp;&emsp;HTTP 隧道的一种常见的用途就是通过 HTTP 连接承载加密的安全套接字层（SSL，Secure Sockets Layer）流量，这样 SSL 流量就可以穿过只允许 Web 流量通过的防火墙了。</p><p>&emsp;&emsp;如下图所示，HTTP/SSL 隧道收到一条 HTTP 请求，要求建立一条到目的地址和端口的输出连接，然后在 HTTP 信道上通过隧道 传输 加密的 SSL 流量，这样就能将其盲转发到目的服务器上去了。</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200921105518446.png" alt="image-20200921105518446" style="zoom:80%;" /><h2 id="5-5-Agent-代理"><a href="#5-5-Agent-代理" class="headerlink" title="5.5 Agent 代理"></a>5.5 Agent 代理</h2><p>&emsp;&emsp;用户 Agent 代理是代表用户发起 HTTP 请求的客户端程序。</p><p>&emsp;&emsp;我们常用的一种 Agent 代理就是 Web 浏览器。</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThreeJS快照</title>
    <link href="/2020/09/20/WebGL/ThreeJS/ThreeJS%E6%88%AA%E5%9B%BE/"/>
    <url>/2020/09/20/WebGL/ThreeJS/ThreeJS%E6%88%AA%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;假设有一个需求，需要获取 Three 场景的一张快照，然后再将其显示在屏幕上。</p><h1 id="1-获取快照"><a href="#1-获取快照" class="headerlink" title="1. 获取快照"></a>1. 获取快照</h1><p>&emsp;&emsp;对于这个需求，一种方法是在创建 <code>WebGLRenderer</code> 时设置一个 <code>preserveDrawingBuffer</code> 参数为 <code>true</code>，然后再调用场景中的 <code>canvas</code> 的 <code>toDataURL</code> 方法来获取某一帧的 <code>base64</code> 格式的图像数据：</p><pre><code class="hljs js">renderer = <span class="hljs-keyword">new</span> WebGLRenderer(&#123;    preserveDrawingBuffer :<span class="hljs-literal">true</span> &#125;);<span class="hljs-keyword">const</span> image = <span class="hljs-keyword">new</span> Image();image.src = renderer.domElement.toDataURL();</code></pre><p>&emsp;&emsp;而 <code>preserveDrawingBuffer </code> 参数的含义是：是否保留缓直到手动清除或被覆盖。若设为 <code>true</code>，在任意时刻，前一帧的缓存图像不会被清除，因此可以获取到任意一刻的截图，若未设置的话，获取的截图可能就会是一张空白的图片。不过，这有一个明显的副作用，那就是会更加的消耗性能和占用内存。因此<strong>不推荐</strong>这种方式。</p><p>&emsp;&emsp;<strong>另一种方式</strong>就是在获取截图之前先再渲染一下场景，这样就不会因为缓存清空而导致截屏空白了：</p><pre><code class="hljs js">renderer.clear();renderer.render(scene, camera);<span class="hljs-keyword">const</span> image = <span class="hljs-keyword">new</span> Image();image.src = canvas.toDataURL(<span class="hljs-string">&quot;image/png&quot;</span>);</code></pre><h1 id="2-在屏幕上显示出来"><a href="#2-在屏幕上显示出来" class="headerlink" title="2.在屏幕上显示出来"></a>2.在屏幕上显示出来</h1><p>&emsp;&emsp;既然我们已经能够获取到正确的快照了，那么要将其显示在屏幕上，我们可以再创建一个新的 <code>canvas</code>，然后将获取的快照使用这个新的 <code>canvas</code> 加载出来就行了，代码如下：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> canvas = renderer.domElement;renderer.render(scene, camera);<span class="hljs-keyword">const</span> image = <span class="hljs-keyword">new</span> Image();<span class="hljs-keyword">const</span> base64 = canvas.toDataURL(<span class="hljs-string">&quot;image/png&quot;</span>);image.src = base64;<span class="hljs-keyword">const</span> mycanvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myImageEditCanvas&#x27;</span>);mycanvas.width = canvas.width;mycanvas.height = canvas.height;<span class="hljs-keyword">const</span> ctx = mycanvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);image.onload = <span class="hljs-function">() =&gt;</span> &#123;    ctx.drawImage(image, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);&#125;;</code></pre><p>&emsp;&emsp;使用 <code>canvas</code> 载入图像使用了 <code>drawImage</code> 方法，它的第二第三个参数的意思是从源图像的哪个位置开始载入，要载入整张图像，填入 <code>0</code> 即可。</p><p>&emsp;&emsp;<code>drawImage</code> 详细一些的介绍可看：<a href="https://yleave.top/2020/09/20/HTML/canvas%E6%93%8D%E4%BD%9C%E5%9B%BE%E5%83%8F/">drawImage</a></p>]]></content>
    
    
    <categories>
      
      <category>WebGL</category>
      
      <category>ThreeJS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>canvas</tag>
      
      <tag>threeJS</tag>
      
      <tag>快照</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>canvas操作图像</title>
    <link href="/2020/09/20/HTML/canvas%E6%93%8D%E4%BD%9C%E5%9B%BE%E5%83%8F/"/>
    <url>/2020/09/20/HTML/canvas%E6%93%8D%E4%BD%9C%E5%9B%BE%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="canvas-获取截图"><a href="#canvas-获取截图" class="headerlink" title="canvas 获取截图"></a>canvas 获取截图</h1><p>&emsp;&emsp;具体是使用 <code>canvas </code> 的 <code>toDataURL</code> 方法：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> image = <span class="hljs-keyword">new</span> Image();image.src = canvas.toDataURL(<span class="hljs-string">&quot;image/png&quot;</span>);</code></pre><p>&emsp;&emsp;<code>toDataURL</code> 的第一个参数是图像类型，默认是 <code>image/png</code>，也可设置为 <code>image/jpeg</code> 。</p><p>&emsp;&emsp;详细可看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLCanvasElement/toDataURL">MDN</a> 的介绍。</p><p>&emsp;&emsp;若想将获取的图像下载下来：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> imgUri = canvas.toDataURL(<span class="hljs-string">&quot;image/png&quot;</span>).replace(<span class="hljs-string">&quot;image/png&quot;</span>, <span class="hljs-string">&quot;image/octet-stream&quot;</span>);<span class="hljs-built_in">window</span>.location.href= imgUri; <span class="hljs-comment">// 下载图片</span></code></pre><h1 id="canvas-载入图像"><a href="#canvas-载入图像" class="headerlink" title="canvas 载入图像"></a>canvas 载入图像</h1><p>&emsp;&emsp;<code>canvas</code> 载入图像有两种方式。一种是使用 <code>drawImage</code> 方法载入任何 <code>canvas</code> 支持的图像类型，另一种是使用 <code>putImageData</code> 方法或是通过循环遍历的方式根据像素值加载图像。</p><h2 id="使用-drawImage-载入图像"><a href="#使用-drawImage-载入图像" class="headerlink" title="使用 drawImage 载入图像"></a>使用 drawImage 载入图像</h2><p>&emsp;&emsp;<code>canvas</code> 支持的图像类型有：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CSSImageValue">CSSImageValue</a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLImageElement">HTMLImageElement</a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/SVGImageElement">SVGImageElement</a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLVideoElement">HTMLVideoElement</a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLCanvasElement">HTMLCanvasElement</a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ImageBitmap">ImageBitmap</a> 或者<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/OffscreenCanvas">OffscreenCanvas</a>。</p><p>&emsp;&emsp;以最常见的 <code>HTMLImageElement</code> 类型的图像为例，也就是使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLImageElement/Image">Image</a> 方法或是 <code>&lt;img&gt;</code> 标签创建的对象：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> image = <span class="hljs-keyword">new</span> Image();image.src = <span class="hljs-string">&#x27;picture.jpg&#x27;</span>;<span class="hljs-comment">// or </span><span class="hljs-comment">// &lt;img id=&quot;picture&quot; src=&quot;...&quot; width=&quot;300&quot; height=&quot;227&quot;&gt;</span><span class="hljs-keyword">var</span> image = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;picture&#x27;</span>);</code></pre><p>&emsp;&emsp;然后，就能使用 <code>drawImage</code> 方法载入这个对象：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;canvas&quot;</span>);<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&quot;2d&quot;</span>);ctx.drawImage(image, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);</code></pre><p>&emsp;&emsp;对于 <code>new Image</code> 方式创建的 <code>image</code> ，需要等到图片加载完成后才能载入：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> image = <span class="hljs-keyword">new</span> Image();image.src = <span class="hljs-string">&#x27;picture.jpg&#x27;</span>;image.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    ctx.drawImage(image, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);&#125;;</code></pre><p>&emsp;&emsp;<code>drawImage</code> 方法有多个参数，除了第一个 <code>imageSource</code> 是必须的，其他参数都是可选的，其他参数设置了源图像和目标图像的起始位置和截取范围：</p><p>&emsp;&emsp;<code>drawImage(image, source_x, source_y, source_width, source_height, x, y, width, heigh)</code></p><p>&emsp;&emsp;因此，<code>drawImage</code> 方法不仅能够普通的载入图像，还能够在载入图像的过程中对图像进行裁剪和缩放。</p><p>&emsp;&emsp;具体可参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/drawImage">MDN1</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Using_images">MDN2</a></p><h2 id="使用-putImageData-载入图像"><a href="#使用-putImageData-载入图像" class="headerlink" title="使用 putImageData 载入图像"></a>使用 putImageData 载入图像</h2><p>&emsp;&emsp;首先，使用该方法，我们需要一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ImageData">ImageData</a> 的对象。这个对象中存储着 <code>canvas</code> 对象真实的像素数据。</p><p><code>ImageData</code> 对象包含以下几个<strong>只读</strong>属性：</p><ul><li><code>width</code> : 图片宽度，单位是像素</li><li><code>height</code> : 图片高度，单位是像素</li><li><code>data </code>: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray">Uint8ClampedArray</a>类型的一维数组，包含着 <strong>RGBA</strong> 格式的整型数据，范围在0至255之间（包括255）。</li></ul><p>&emsp;&emsp;<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray">Uint8ClampedArray</a> 包含高度 × 宽度 × 4 bytes 数据，索引值从 <code>0</code> 到 <code>(高度 × 宽度 × 4 ) - 1</code></p><p>&emsp;&emsp;下面将图像从一个 <code>canvas</code> 复制到一个新的 <code>canvas</code>，涉及两个函数：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/getImageData">getImageData</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/putImageData">putImageData</a></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;canvas&quot;</span>);<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&quot;2d&quot;</span>);<span class="hljs-keyword">var</span> imgData = ctx.getImageData(left, top, width, height);<span class="hljs-keyword">var</span> newCvs = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;new_canvas&quot;</span>);<span class="hljs-keyword">var</span> cewCtx = newCvs.getContext(<span class="hljs-string">&quot;2d&quot;</span>);cewCtx.putImageData(imgData, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);</code></pre><p>&emsp;&emsp;若是已知图像的像素值，也可使用循环遍历的方式来载入图像：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;canvas&quot;</span>);<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&quot;2d&quot;</span>);<span class="hljs-comment">// 创建一个空的 ImageData 对象</span><span class="hljs-keyword">var</span> img = context.createImageData(width, height);<span class="hljs-keyword">var</span> data = img.data;<span class="hljs-comment">// 按 RGBA 格式存储数据</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; height; i++) &#123;    <span class="hljs-keyword">var</span> l = height - <span class="hljs-number">1</span> - i;    <span class="hljs-keyword">var</span> s1 = l * width * <span class="hljs-number">4</span>;    <span class="hljs-keyword">var</span> s2 = i * width * <span class="hljs-number">4</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; width * <span class="hljs-number">4</span>; j++) &#123;        data[s1 + j] = imageData[s2 + j]    &#125;&#125;context.putImageData(img, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);</code></pre><p>&emsp;&emsp;更多详细内容可参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas">像素操作</a></p>]]></content>
    
    
    <categories>
      
      <category>HTML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>canvas</tag>
      
      <tag>js截图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 47. 全排列 II</title>
    <link href="/2020/09/19/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/47-%E5%85%A8%E6%8E%92%E5%88%97-II/"/>
    <url>/2020/09/19/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/47-%E5%85%A8%E6%8E%92%E5%88%97-II/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/permutations-ii/">https://leetcode-cn.com/problems/permutations-ii/</a></p><p>难度：中等</p><hr><p>&emsp;&emsp;给定一个可<strong>包含重复数字</strong>的序列，返回所有不重复的全排列。</p><p><strong>示例:</strong></p><p>输入: <code>[1,1,2]</code></p><p>输出:</p><pre><code class="hljs json">[  [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>],  [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]]</code></pre><h2 id="解法1：回溯-剪枝"><a href="#解法1：回溯-剪枝" class="headerlink" title="解法1：回溯 + 剪枝"></a>解法1：回溯 + 剪枝</h2><p>&emsp;&emsp;这题求全排列的步骤与 <a href="https://yleave.top/2020/09/17/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/46-%E5%85%A8%E6%8E%92%E5%88%97/">46.全排列</a> 这题是一样的，区别就是 <code>46.</code> 这题给的数字序列是不含重复的数字，而本题则包含重复数字。</p><p>&emsp;&emsp;这样的话，我们只需要在原先的基础上对其进行剪枝即可，将造成重复组合的情况去除。</p><p>&emsp;&emsp;考虑一组序列：<code>[2, 2, 1, 1]</code>，标记一下以便区分：<code>[2, 2&#39;, 1, 1&#39;]</code>，对于这组序列，按照 <code>46.</code> 的思路，会造成重复的情况有在固定索引 <code>0</code> 处的值时，序列中的两个 <code>2</code> 和两个 <code>1</code> 都会造成固定值重复，即 <code>[2, 2&#39;, 1, 1&#39;]</code> 、<code>[2&#39;, 2, 1, 1&#39;]</code>，<code>[1, 2&#39;, 2, 1&#39;]</code> 和 <code>[1&#39;, 2&#39;, 1, 2]</code> ，这样，由于第一个固定的数字就重复，后面的所有组合也都是重复的。</p><p>&emsp;&emsp;因此，我们要做的就是<strong>让每个索引处固定的值不再重复！</strong></p><p>&emsp;&emsp;要做到这样，我们可以借用一个 <code>map</code>，对于每个固定的索引，当一个值是第一次出现时，将其记录在 <code>map</code> 中，而若是遇到了 <code>map</code> 中已经存的值，则说明这个值已经固定过了，跳过它，这样就完成了全排列过程中的去重要求。</p><p>&emsp;&emsp;当然，还有一个很耿直的做法就是：还是像 <code>46.</code> 一样计算序列的组合，只在保存每个组合结果时，使用一个 <code>map</code> 记录当前组合是否保存过，若未保存过，则记录到结果数组中。。。</p><p>剪枝的 JS 代码：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> permuteUnique = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = [];    <span class="hljs-keyword">let</span> len = nums.length;    <span class="hljs-keyword">const</span> swap = <span class="hljs-function">(<span class="hljs-params">i, j</span>) =&gt;</span> &#123;        <span class="hljs-keyword">let</span> tmp = nums[i];        nums[i] = nums[j];        nums[j] = tmp;    &#125;;    <span class="hljs-keyword">const</span> helper = <span class="hljs-function"><span class="hljs-params">index</span> =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (index === len) &#123;            res.push(nums.slice());            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">let</span> map = [];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = index; i &lt; len; i++) &#123;            <span class="hljs-keyword">if</span> (map[nums[i]]) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            map[nums[i]] = <span class="hljs-number">1</span>;            swap(index, i);            helper(index+<span class="hljs-number">1</span>);            swap(index, i);        &#125;    &#125;;    helper(<span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> res;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>解答</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 46. 全排列</title>
    <link href="/2020/09/19/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/46-%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <url>/2020/09/19/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/46-%E5%85%A8%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/permutations/">https://leetcode-cn.com/problems/permutations/</a></p><p>难度：中等</p><hr><p>&emsp;&emsp;给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p><p><strong>示例:</strong></p><p>输入: <code>[1,2,3]</code></p><p>输出:</p><pre><code class="hljs json">[  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],  [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>],  [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],  [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>],  [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],  [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]]</code></pre><h2 id="解法1：回溯法"><a href="#解法1：回溯法" class="headerlink" title="解法1：回溯法"></a>解法1：回溯法</h2><p>&emsp;&emsp;对于一组<strong>没有重复</strong>数字的序列，要求它的全排列，假设这个序列是 <code>[1, 2, 3]</code>，若用手算，我们是这样算的：</p><ol><li><p>固定索引 <code>0</code> 处的数字 <code>1</code> ，剩下的就是 <code>[2, 3]</code>，两个数字的组合有 <code>[2, 3]</code> 和 <code>[3, 2]</code> ，再加上 <code>1</code> ，就得到了组合 <code>[1, 2, 3]</code> 和 <code>[1, 3, 2]</code>。（其实对于如 <code>[2, 3]</code> 这样的未固定的数字，我们也是像固定 <code>1</code> 一样，先固定住索引 <code>1</code> 处的数字 <code>2</code> ，剩下一个 <code>3</code>，得到组合后再回溯回去，换一个值固定在索引 <code>1</code> 处，即 <code>[3, 2]</code> … ）。</p></li><li><p>现在再改变索引 <code>0</code> 处的数字为 <code>2</code>，即 <code>1 </code> 与 <code>2</code> 互换位置，那么剩下的数字就是 <code>[1, 3]</code> ，组合有 <code>[1, 3]</code> 和 <code>[3, 1]</code>，再加上固定的 <code>2</code> ，就得到了 <code>[2, 1, 3]</code> 和 <code>[2, 3, 1]</code>。</p></li><li><p>同理，恢复到初始的 <code>[1, 2, 3]</code>，再改变索引 <code>0</code> 的值为 <code>3</code>，剩下了 <code>[2, 1]</code> ，组合有 <code>[2, 1]</code> 和 <code>[1, 2]</code>，加上 <code>3</code> ，得到的组合就是 <code>[3, 2, 1]</code> 和 <code>[3, 1, 2]</code>。</p></li></ol><p>&emsp;&emsp;整理一下我们的计算过程，也就是对于每个索引 <code>0, 1,...,n</code> ，我们从索引 <code>0</code>  开始，固定住每一位，对于剩下未固定的数字再进行全排列，这样，每次固定到索引末尾时，我们就获得了一个组合，对每个索引取所有的值都固定一遍，我们就得到了所有数字的全排列了！</p><p>&emsp;&emsp;（可能还是有些没讲清楚，请看代码：</p><p><strong>JS 代码：</strong></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> permute = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = [];    <span class="hljs-keyword">let</span> len = nums.length;    <span class="hljs-keyword">const</span> swap = <span class="hljs-function">(<span class="hljs-params">i, j</span>) =&gt;</span> &#123;        <span class="hljs-keyword">let</span> tmp = nums[i];        nums[i] = nums[j];        nums[j] = tmp;    &#125;;      <span class="hljs-keyword">const</span> helper = <span class="hljs-function"><span class="hljs-params">index</span> =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (index === len) &#123; <span class="hljs-comment">// 当最后一个数字也被固定后，就得到了一个组合</span>            res.push(nums.slice());            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 对于每个索引 index，取所有的值都固定一次，每固定一次后 index+1 ,固定下一位</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = index; i &lt; len; i++) &#123;            swap(index, i);            helper(index+<span class="hljs-number">1</span>);            swap(index, i);        &#125;    &#125;;    helper(<span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> res;&#125;;</code></pre><p><strong>CPP 代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">permute</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt; res;        helper(res,nums,<span class="hljs-number">0</span>,nums.size());        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt; &amp;res,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> n)</span></span>&#123;        <span class="hljs-keyword">if</span>(b == n)&#123;            res.push_back(nums);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = b; i &lt; n; i++)&#123;            swap(nums[i],nums[b]);            helper(res,nums,b + <span class="hljs-number">1</span>,n);            swap(nums[b],nums[i]);        &#125;    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>解答</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>github+picGo+jsDelivr构建图床</title>
    <link href="/2020/09/19/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/github-picGo-jsDelivr%E6%9E%84%E5%BB%BA%E5%9B%BE%E5%BA%8A/"/>
    <url>/2020/09/19/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/github-picGo-jsDelivr%E6%9E%84%E5%BB%BA%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;不论是写博客还是记笔记，图床的选择很重要。且对于一个博客平台来说，网站中的图片、视频以及音频等资源的下载速度直接影响到了整个博客网站的加载和体验，这点我深有体会。</p><p>&emsp;&emsp;就我个人来说，最开始，我在博客中有加入音乐播放器，音频和部分图片是直接存储在博客项目里的，而文章中的一些图片则使用 <strong>SM.MS 图床</strong>存储，然后每次打开网站时都要等很久网站的资源才能加载出来，开始我还认为是因为博客是部署在 githubPages 上导致的网站访问缓慢，也试了一些方法如 <a href="https://yleave.top/2020/09/12/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E4%BD%BF%E7%94%A8Netlify%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/">使用Netlify部署博客</a> 来尝试加速网站的访问，然并卵…</p><p>&emsp;&emsp;直到有一天我受不了图片的上传和加载速度的缓慢，就尝试了下经常在博客搭建教程中看到的 <strong>七牛云图床</strong>。结果确实很香~，我不仅将图片存储在了七牛云上，并且将音频也一并存储了。重新部署后网站的访问速度有了肉眼可见的提升。直到这时，我才直到原来之前<strong>访问速度慢的原因不止是部署服务器的问题，和网站中的静态资源也有很大的关系！</strong> </p><p>&emsp;&emsp;使用 七牛云图床 前后对比：</p><p><img src="https://i.loli.net/2020/09/18/IcYpjFWJnC6Kmft.png" alt="img" style="zoom: 40%;" /> <img src="https://i.loli.net/2020/09/18/1GJKUjIVdBLrTno.png" alt="image-20200918152333510" style="zoom:40%;" /></p><p>&emsp;&emsp;效果确实好了很多。</p><h2 id="七牛云图床吐槽"><a href="#七牛云图床吐槽" class="headerlink" title="七牛云图床吐槽"></a>七牛云图床吐槽</h2><p>&emsp;&emsp;<font color="skyblye" style="font-size:150%;font-weight:bold"> 不过!!! </font></p><p>&emsp;&emsp;虽然七牛云有提供免费的 10G 空间，但是如果想要真正使用七牛云图床的完整服务的话，你的网站<strong>需要备案</strong>，也就是说需要自己租一个服务器，在上面部署网站（掏了下口袋，空空的，想想还是算了吧）。</p><img src="https://i.loli.net/2020/09/18/Ei4Smw3g5lD8M2I.jpg" alt="穷" style="zoom:50%;" /><p>&emsp;&emsp;否则，你只能得到一个<strong>临时域名</strong>，也就是你你资源路径的前面部分，如 <code>http://xxxxx.hd-bkt.clouddn.com/1.jpg</code> 。然后这个临时域名会在 30 天之后回收！！这意味着 30 天后你网站中所有使用七牛云存储的静态资源都不能正常访问了！！</p><img src="https://i.loli.net/2020/09/18/meyl9OXUJAZu2xr.png" alt="image-20200918153307205" style="zoom:80%;" /><p>&emsp;&emsp;其次，七牛云上的临时域名还是 <code>HTTP</code> 的，就算使用了备案的域名绑定，想使用 <code>HTTPS</code> 的域名也需要交费（又掏了掏口袋）。</p><p>&emsp;&emsp;你的网站就会变成这样（看着是不是很不爽）</p><img src="https://i.loli.net/2020/09/18/9jygoJbrIdp4q7l.png" alt="image-20200918154227852" style="zoom:80%;" /><p>&emsp;&emsp;因此，果断抛弃七牛云，尝试使用 github 图床 + jsDelivr CDN加速访问！</p><p>&emsp;&emsp;好了，说了这么多废话，下面是配置过程。</p><h1 id="配置-github-图床"><a href="#配置-github-图床" class="headerlink" title="配置 github 图床"></a>配置 github 图床</h1><p>&emsp;&emsp;首先，新建一个 github 仓库：</p><img src="https://i.loli.net/2020/09/18/uk7X3qAhBJTIzNQ.png" alt="image-20200918154812090" style="zoom: 50%;" /><p>&emsp;&emsp;依次点击 Settings -&gt; DeveloperSettings -&gt; Personal access tokens -&gt;  Generate new token</p><p><img src="https://i.loli.net/2020/09/18/ZzsiVL1nSIbkKlH.png" alt="image-20200918155050224" style="zoom: 67%;" /> <img src="https://i.loli.net/2020/09/18/GKp6XhkMWPgnaoT.png" alt="image-20200918155149215" style="zoom:50%;" /> <img src="https://i.loli.net/2020/09/18/A6iyYX3ObQLZraI.png" alt="image-20200918155324860" style="zoom:50%;" /></p><p>&emsp;&emsp;填写描述，再勾选 repo，最后拉到底点击 Generate token。</p><img src="https://i.loli.net/2020/09/18/w2dSAbWyuz6QXF8.png" alt="image-20200918155537060" style="zoom:67%;" /> <img src="https://i.loli.net/2020/09/18/raUQvJ4lgGb7R1y.png" alt="image-20200918155736272" style="zoom:50%;" /> <h1 id="PicGo-配置"><a href="#PicGo-配置" class="headerlink" title="PicGo 配置"></a>PicGo 配置</h1><p>&emsp;&emsp;然后打开 <a href="https://github.com/Molunerfinn/picgo/releases">PicGo</a> 进行配置 （PicGo 是图床管理工具，能配合种图床使用，typora 中也支持使用 PicGo 自动上传图片，使用起来不要太方便了~</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200918174221758.png" alt="image-20200918174221758" style="zoom: 67%;" /><p>&emsp;&emsp;配置如上。</p><ul><li>仓库名：格式是 ：github用户名/图床仓库名</li><li>分支：master</li><li>token：前面生成的 token</li><li>存储路径：自己定义，如 <code>img/</code> 的话就会在仓库下生成一个 <code>img</code> 文件夹来存储图片</li><li>自定义域名：在图片上传后，PicGo会按照<code>自定义域名+储存路径+上传的图片名</code>的方式生成访问链接，放到粘贴板上，因为我们要使用 jsDelivr 加速访问，所以可以设置为<code>https://cdn.jsdelivr.net/gh/用户名/图床仓库名</code> ，上传完毕后，我们就可以通过<code>https://cdn.jsdelivr.net/gh/用户名/图床仓库名/图片路径</code>加速访问我们的图片了。</li></ul><h1 id="jsDelivr"><a href="#jsDelivr" class="headerlink" title="jsDelivr"></a>jsDelivr</h1><p>&emsp;&emsp;关于 jsDelivr 是不需要配置的，对于 github ，只要符合 jsDelivr 规定的路径，且<strong>仓库大小小于 50M ，文件不超过 20M</strong> 的都能直接引用。</p><p>&emsp;&emsp;规定的路径格式就是上面提到的：<code>https://cdn.jsdelivr.net/gh/用户名/图床仓库名/图片路径</code>。</p><p>&emsp;&emsp;如我在 <code>imagehost</code> 仓库的 <code>img</code> 文件夹下有一张图片 <code>default.png</code> ，这样就能通过：<a href="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/default.png">https://cdn.jsdelivr.net/gh/yleave/imagehost/img/default.png</a> 来访问它了。</p><p>&emsp;&emsp;当然，jsDelivr 不止能加速图片的访问，对于视频文件和音频文件也能使用同样的方法访问，不过美中不足的是仓库大小不能超过 50M。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="Imagine"><a href="#Imagine" class="headerlink" title="Imagine"></a>Imagine</h2><p>&emsp;&emsp;jsDelivr 限制了仓库大小，因此图片的压缩很重要，这里再推荐一个图片压缩工具 <a href="https://github.com/meowtec/Imagine">Imagine</a> ，非常好用，压缩效果很好，1M多的图片压缩成不到 100k 的图片也基本上看不出什么差别：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200918175722716.png" alt="image-20200918175722716" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200918175745739.png" alt="image-20200918175745739" style="zoom:67%;" /><h2 id="staticaly-与-githack"><a href="#staticaly-与-githack" class="headerlink" title="staticaly 与 githack"></a>staticaly 与 githack</h2><p>&emsp;&emsp;除了 jsDelivr 外，还有几个免费的且不限流量的CDN， <code>staticaly</code> <code>githack</code> ，它们都是全球通用的。</p><h3 id="staticaly"><a href="#staticaly" class="headerlink" title="staticaly"></a>staticaly</h3><p>&emsp;&emsp;官网地址：<a href="https://statically.io/">https://www.staticaly.com</a></p><p>&emsp;&emsp;轻松地从GitHub / GitLab / Bitbucket等加载您的项目 没有流量限制或限制。</p><p>&emsp;&emsp;文件通过超快速全球CDN提供。 在URL（不是分支）中使用特定标记或提交哈希。</p><p>&emsp;&emsp;根据URL永久缓存文件。 除master分支外，文件在浏览器中缓存1年。 具体用法：</p><p>&emsp;&emsp;<code>staticaly</code> 的用法：进入网站，将你的资源链接贴上去就会有了可用的链接：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200919005010468.png" alt="image-20200919005010468" style="zoom: 50%;" /><h3 id="githack"><a href="#githack" class="headerlink" title="githack"></a>githack</h3><p><strong>该 CDN 亲测需要接外网</strong></p><p>&emsp;&emsp;直接从GitHub，Bitbucket或GitLab提供原始文件</p><p>&emsp;&emsp;官网地址：<a href="https://raw.githack.com/">http://raw.githack.com/</a> 具体用法和上面的<code>staticaly</code>很类似</p><p>&emsp;&emsp;同样，在网站中输入资源链接，如：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200919005149597.png" alt="image-20200919005149597" style="zoom: 80%;" /><p>&emsp;&emsp;有两个 URL 版本：生产模式和开发模式，亲测生产模式速度会更快些，开发模式的 URL 会更“工整” 些，以便测试。不过别看生产模式的 URL 是有一长串字符，这些只要你前面的路径没变，这些字符都是一样的，因此同样比较方便统一路径。</p><p>&emsp;&emsp;当然，最最具有吸引力的就是它没有限制仓库容量，并且是永久免费的！</p><hr><p><a href="https://blog.csdn.net/qq_36759224/article/details/98058240">参考1</a></p><p><a href="https://www.itrhx.com/2019/02/10/A18-free-cdn/">参考2</a></p><p><a href="https://www.cnblogs.com/lfri/p/12212878.html">参考3</a></p>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图床</tag>
      
      <tag>CDN</tag>
      
      <tag>PicGo</tag>
      
      <tag>jsDelivr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2020/09/17/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2020/09/17/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p>并查集就是一个数组 <code>father[]</code> ，<code>father[i]</code> 表示元素 <code>i</code> 的父节点。</p><p>并查集的使用场景主要有：</p><ul><li>寻找节点的公共根结点</li><li>判断图的连通性</li><li>求集合的个数（根据给定的数据，求这些数据能够构成几个不连通的图）</li><li>…</li></ul><p>并查集的几个操作：</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><pre><code class="hljs js"><span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;    father[i] = i;&#125;</code></pre><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>用于快速找到某个节点的根结点</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findFather</span>(<span class="hljs-params">x</span>) </span>&#123;    <span class="hljs-keyword">while</span> (father[x] !== x) &#123;        x = father[x];    &#125;    <span class="hljs-keyword">return</span> x;&#125;<span class="hljs-comment">// or 递归</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">father</span>(<span class="hljs-params">x</span>) </span>&#123;    <span class="hljs-keyword">if</span> (x === father[x]) &#123;        <span class="hljs-keyword">return</span> x;    &#125;    <span class="hljs-keyword">return</span> findFather(father[x]);&#125;</code></pre><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">union</span>(<span class="hljs-params">a, b</span>) </span>&#123;    <span class="hljs-keyword">let</span> fa = findFather(a);    <span class="hljs-keyword">let</span> fb = findFather(b);    <span class="hljs-keyword">if</span> (fa !== fb) &#123;        father[fa] = fb; <span class="hljs-comment">// 将 a 接在 b 之下，即 b 作为 a 的父节点</span>    &#125; <span class="hljs-comment">// 否则，出现了环</span>&#125;</code></pre><h2 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h2><p>若节点很多的情况下，并查集的”高度”会非常高，因此可以使用路径压缩，使所有结点与根节点直接相连。</p><img src="https://i.loli.net/2020/09/17/e6BDlnFxiovp9K1.png" alt="image-20200917164907651" style="zoom: 67%;" /><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findFather</span>(<span class="hljs-params">x</span>) </span>&#123;    <span class="hljs-keyword">let</span> tmp = x;    <span class="hljs-keyword">while</span> (x !== father[x]) &#123; <span class="hljs-comment">// 寻找根结点，根结点是父节点等于当前值的节点</span>        x = father[x];    &#125;    <span class="hljs-keyword">while</span> (tmp !== father[tmp]) &#123;        <span class="hljs-keyword">let</span> a = x;        tmp = father[tmp];        father[a] = x; <span class="hljs-comment">// 将原先节点的父节点直接改为根结点。</span>    &#125;    <span class="hljs-keyword">return</span> x; <span class="hljs-comment">// 返回根结点</span>&#125;<span class="hljs-comment">// 递归写法</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findFather</span>(<span class="hljs-params">x</span>) </span>&#123;    <span class="hljs-keyword">if</span> (x === father[x]) &#123;        <span class="hljs-keyword">return</span> x;    &#125;    <span class="hljs-keyword">let</span> r = findFather(father[x]);    father[x] = r;    <span class="hljs-keyword">return</span> r;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>算法知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>连通性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 685. 冗余连接 II</title>
    <link href="/2020/09/17/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/685-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5-II/"/>
    <url>/2020/09/17/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/685-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5-II/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/redundant-connection-ii/">https://leetcode-cn.com/problems/redundant-connection-ii/</a></p><p>难度：困难</p><hr><p>&emsp;&emsp;在本问题中，有根树指满足以下条件的有向图。该树只有一个根节点，所有其他节点都是该根节点的后继。每一个节点只有一个父节点，除了根节点没有父节点。</p><p>&emsp;&emsp;输入一个有向图，该图由一个有着<code>N</code>个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在<code>1</code>到<code>N</code>中间，这条附加的边不属于树中已存在的边。</p><p>&emsp;&emsp;结果图是一个以边组成的二维数组。 每一个边 的元素是一对 <code>[u, v]</code>，用以表示有向图中连接顶点 <code>u</code> 和顶点 <code>v</code> 的边，其中 <code>u</code> 是 <code>v</code> 的一个父节点。</p><p>&emsp;&emsp;返回一条能删除的边，使得剩下的图是有<code>N</code>个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。</p><p><strong>简化题目：</strong> 根据给定的边集，求出一条多余的边，使得删除这条边后，图会变成一棵树，对于一些情况，这样的边会有多条，删除边集中出现的最后一条满足条件的边。</p><p><strong>示例 1:</strong></p><p>输入: <code>[[1,2], [1,3], [2,3]]</code></p><p>输出: <code>[2,3]</code></p><p>解释: 给定的有向图如下:</p><pre><code class="hljs angelscript">  <span class="hljs-number">1</span> / \v   v<span class="hljs-number">2</span>--&gt;<span class="hljs-number">3</span></code></pre><p><strong>示例 2:</strong></p><p>输入: <code>[[1,2], [2,3], [3,4], [4,1], [1,5]]</code></p><p>输出: <code>[4,1]</code></p><p>解释: 给定的有向图如下:</p><pre><code class="hljs angelscript"><span class="hljs-number">5</span> &lt;- <span class="hljs-number">1</span> -&gt; <span class="hljs-number">2</span>     ^    |     |    v     <span class="hljs-number">4</span> &lt;- <span class="hljs-number">3</span></code></pre><p><strong>注意:</strong></p><ul><li>二维数组大小的在<code>3</code>到<code>1000</code>范围内。</li><li>二维数组中的每个整数在<code>1</code>到<code>N</code>之间，其中 <code>N</code> 是二维数组的大小。</li></ul><h2 id="解法1：并查集"><a href="#解法1：并查集" class="headerlink" title="解法1：并查集"></a>解法1：并查集</h2><p>思路来源：<a href="https://leetcode-cn.com/problems/redundant-connection-ii/comments/70573">Nu11Pointer</a></p><p>&emsp;&emsp;对于一条能使一棵树变成图的边，它有以下几种情况：</p><ol><li><img src="https://i.loli.net/2020/09/17/OJIs4VDuBwAyxSd.png" alt="image-20200917170455420" style="zoom:80%;" />  <p>这条边从任意节点出发，指向了根结点，此时树形成了环，树也就没有根结点了（表现就是所有结点的入度都为 1），而这种情况下，处于这个环中的所有边都能被删除，因为删除任意一条边都能变成一棵正常的树，这也就是题目中提到的“多条边”的情况，但根据题目，需要删除边集中最后一条在环中的边。</p></li><li><img src="https://i.loli.net/2020/09/17/Cazh1PI3D4YecFn.png" alt="image-20200917170905916" style="zoom:80%;" />  <p>这条边从任意节点出发，指向了其祖先节点，树中形成了环，但仍有根结点，不过造成的后果就是有一个节点的入度变成 2了。这种情况下，只能删除环中的且造成 2 个入度的边，即图中橙色的边。</p></li><li><img src="https://i.loli.net/2020/09/17/qnpHve92sCIwOPW.png" alt="image-20200917171311259" style="zoom:80%;" /> <p> 这条边从任意节点出发，指向了一个非祖先节点。这种情况下，有一个节点的入度会为 2，这两条造成入度为 2 的边都能删除，但根据题目，需要删除后出现的那条。</p></li></ol><p>&emsp;&emsp;</p><p>&emsp;&emsp;好了，既然清楚可能的几种情况，就需要想办法找到这些满足条件的边了。</p><p>&emsp;&emsp;对于这种需要判断环的问题，可以考虑使用<a href="http://localhost:4000/2020/09/17/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/%E5%B9%B6%E6%9F%A5%E9%9B%86/">并查集</a>来做。在创建并查集的过程中，合并两个节点 <code>a</code> 和 <code>b</code> 时，若这两个节点有着公共的根结点，那么将它们合并的话就会出现环了。</p><p>&emsp;&emsp;好的，首先，我们可以判断图中是否存在入度为 2 的节点，<strong>若存在</strong>，那么就是第 2 和第 3 种情况，将造成入度为 2 的这两条边（<code>edge1，edge2</code>）都先记录下来。</p><p>&emsp;&emsp;然后创建并查集，我们跳过 <code>edge2</code> （<strong>后出现的边</strong>）这条边，若创建并查集的过程一路畅通（即未出现环），那么答案就是 <code>edge2</code>，也就是 <code>2.</code> 中删了正确的边（橙色的边）和 <code>3.</code> 中的情况 。</p><p>&emsp;&emsp;而若创建并查集的过程中出现了环，那么对应的就是 <code>2.</code> 中删除了错误的边，那么答案就是 <code>edge1</code>。</p><p>&emsp;&emsp;<strong>若不存在入度为 2 的节点</strong> ，那么就是 <code>1.</code> 中的情况了。此时，在创建并查集的过程中，记录那条造成环出现的边，这条边会是环中的边（废话），且会是边集中最后出现的满足条件的边，将其记录下来，作为答案返回。</p><p><strong>JS 代码：</strong></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> findRedundantDirectedConnection = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">edges</span>) </span>&#123;    <span class="hljs-keyword">let</span> inDegrees = [];    <span class="hljs-keyword">let</span> res = [];    <span class="hljs-keyword">let</span> meetCircle;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> edge <span class="hljs-keyword">of</span> edges) &#123;        <span class="hljs-keyword">let</span> node = edge[<span class="hljs-number">1</span>];        <span class="hljs-keyword">if</span> (!inDegrees[node]) &#123;            inDegrees[node] = edge;        &#125; <span class="hljs-keyword">else</span> &#123;            res.push(inDegrees[node]);            res.push(edge); <span class="hljs-comment">// 若找到入度为 2 的节点，将其中一条边记录下来</span>            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">let</span> father = [];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= edges.length; i++) &#123;        father[i] = i;    &#125;    <span class="hljs-keyword">const</span> findFather = <span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> &#123;        <span class="hljs-keyword">let</span> tmp = x;        <span class="hljs-keyword">while</span> (x !== father[x]) &#123;            x = father[x];        &#125;        <span class="hljs-keyword">let</span> a = tmp;        tmp = father[tmp];        father[a] = x;        <span class="hljs-keyword">return</span> x;    &#125;;    <span class="hljs-keyword">const</span> union = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;        <span class="hljs-keyword">let</span> fa = findFather(a);        <span class="hljs-keyword">let</span> fb = findFather(b);        <span class="hljs-keyword">if</span> (fa !== fb) &#123;            father[fb] = fa;        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 遇到了环</span>            meetCircle = [a, b];        &#125;    &#125;;    <span class="hljs-comment">// 建立并查集，若存在入度为 2 的节点，跳过后出现的边</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> edge <span class="hljs-keyword">of</span> edges) &#123;        <span class="hljs-keyword">if</span> (res.length &amp;&amp; res[<span class="hljs-number">1</span>] === edge) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        union(edge[<span class="hljs-number">0</span>], edge[<span class="hljs-number">1</span>]);    &#125;    <span class="hljs-comment">// 若没有入度为 2 的点，则说明冗余的边指向了根结点</span>    <span class="hljs-keyword">if</span> (res.length === <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> meetCircle;    &#125;    <span class="hljs-keyword">return</span> meetCircle ? res[<span class="hljs-number">0</span>] : res[<span class="hljs-number">1</span>];&#125;;</code></pre><p>&emsp;&emsp;优化后的代码：只遍历了一次边集</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> findRedundantDirectedConnection = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">edges</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = [], father = [];    <span class="hljs-keyword">let</span> indegrees = [];    <span class="hljs-keyword">let</span> meetCircle;    <span class="hljs-keyword">const</span> findFather = <span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> &#123;        <span class="hljs-keyword">let</span> tmp = x;        <span class="hljs-keyword">while</span> (x !== father[x]) &#123;            x = father[x];        &#125;        <span class="hljs-keyword">let</span> a = tmp;        tmp = father[tmp];        father[a] = x;        <span class="hljs-keyword">return</span> x;    &#125;;    <span class="hljs-comment">// 创建并查集</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> edge <span class="hljs-keyword">of</span> edges) &#123;        <span class="hljs-keyword">let</span> node1 = edge[<span class="hljs-number">0</span>], node2 = edge[<span class="hljs-number">1</span>];        <span class="hljs-comment">// 初始化</span>        <span class="hljs-keyword">if</span> (!father[node1]) &#123;            father[node1] = node1;        &#125;        <span class="hljs-keyword">if</span> (!father[node2]) &#123;            father[node2] = node2;        &#125;        <span class="hljs-keyword">if</span> (indegrees[node2]) &#123; <span class="hljs-comment">// 若其入度已经为 1 了，则加上当前边入度就是 2了</span>            res.push([indegrees[node2], node2]);            res.push(edge);        &#125; <span class="hljs-keyword">else</span> &#123;            indegrees[node2] = node1;            <span class="hljs-keyword">let</span> f1 = findFather(node1);            <span class="hljs-keyword">let</span> f2 = findFather(node2);            <span class="hljs-keyword">if</span> (f1 !== f2) &#123;                father[f2] = f1;            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 遇到了环</span>                meetCircle = edge;            &#125;        &#125;    &#125;    <span class="hljs-comment">// 若没有入度为 2 的点，则说明冗余的边指向了根结点</span>    <span class="hljs-keyword">if</span> (res.length === <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> meetCircle;    &#125;    <span class="hljs-comment">// 否则，根据是否产生环输出答案</span>    <span class="hljs-keyword">return</span> meetCircle ? res[<span class="hljs-number">0</span>] : res[<span class="hljs-number">1</span>];&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>解答</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>并查集</tag>
      
      <tag>图</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Netlify部署博客</title>
    <link href="/2020/09/12/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E4%BD%BF%E7%94%A8Netlify%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/09/12/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E4%BD%BF%E7%94%A8Netlify%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;原先博客是部署在 githubPages 上的，稍微设置一下就能实现自动化部署和启用 https，还是蛮方便的，但是使用国内网络访问 githubPages 上部署的网站速度太慢了，体验很差，因此，搜了下解决方案，发现了 <code>Netlify </code> 这个一站式自动化部署网站的平台，部署网站的过程很简单， githubPages 上的支持和不支持的功能 Netlify 上都有，最重要的是听说使用 Netlify 部署的网站，国内访问深度会比 githubPages 快多了。因此也捣鼓了一番，使用 Netlify 重新部署了网站。</p><p>&emsp;&emsp;但是。。。部署完后使用国内网络访问网站，感觉访问速度没什么变化。。。去站长之家测试了下速度，唉</p><p><strong>我理想中的变化：</strong></p><img src="https://i.loli.net/2020/09/12/QFlGUA7px2aDmMN.png" alt="image-20200912114349985" style="zoom:80%;" /><p><strong>残酷的现实：</strong></p><p><img src="https://i.loli.net/2020/09/12/cUhBsSGPVHZkApW.png" alt="image-20200912114441879" style="zoom:40%;" /> <img src="https://i.loli.net/2020/09/12/aWpBJ7IDlcXvFCx.png" alt="image-20200912114518298" style="zoom:40%;" /></p><p>&emsp;&emsp;总之记录一下部署的过程，不过可能还是会选用 githubPages 了，关于网站加速，后面再看了。</p><h2 id="github-项目部署"><a href="#github-项目部署" class="headerlink" title="github 项目部署"></a>github 项目部署</h2><p>&emsp;&emsp;首先，进入 <a href="https://app.netlify.com/teams/yleave/sites">Netlify</a> 官网，选择 github 账号登陆。</p><p>&emsp;&emsp;然后点击创建新网站：</p><img src="https://i.loli.net/2020/09/12/UNgWzbrBpMFin7E.png" alt="image-20200912024233068" style="zoom:80%;" /><p>&emsp;&emsp;选择 github </p><img src="https://i.loli.net/2020/09/12/KgbkJuPSoFNQaB8.png" alt="image-20200912024310535" style="zoom:80%;" /><p>&emsp;&emsp;然后进入第二步，选择网站的项目仓库：</p><img src="https://i.loli.net/2020/09/12/PGQSKXUyLz2clhF.png" alt="image-20200912024635089" style="zoom:80%;" /><p>&emsp;&emsp;然后选择部署的分支及打包命令与发布目录，我是使用了 hexo ，因此打包命令是 <code>hexo generate</code>：</p><img src="https://i.loli.net/2020/09/12/dvts5UECVeaTRgQ.png" alt="image-20200912024803284" style="zoom: 67%;" /><p>&emsp;&emsp;点击 <code>Deploy</code> 按钮后，会自动进行部署，部署完成后，就能通过它给你的域名访问你的网站了：</p><img src="https://i.loli.net/2020/09/12/oQVNMXCEUmgnSey.png" alt="image-20200912025256424" style="zoom: 67%;" /><p>&emsp;&emsp;网站名称默认会是一连串字符，可以在 <code>Site Setting</code> 里更改：</p><img src="https://i.loli.net/2020/09/12/gLuZcst8EAmrB5D.png" alt="image-20200912025420094" style="zoom:67%;" /><h2 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h2><p>&emsp;&emsp;Netify 的初始域名会是 <code>xxx.netify.app</code></p><p>&emsp;&emsp;需要更改域名的话需要去申请域名，解析 DNS，有了之前的<a href="https://yleave.netlify.app/2020/09/11/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%B9%B6%E6%B7%BB%E5%8A%A0ssl/">经验</a> ，这步就很快了：</p><p>&emsp;&emsp;首先使用 <a href="http://tool.chinaz.com/dns">dns查询工具</a> 查询网站的 ip：</p><img src="https://i.loli.net/2020/09/12/cD7wf495nxWISud.png" alt="image-20200912025833859" style="zoom:67%;" /><p>&emsp;&emsp;然后去阿里云的 dns 解析平台解析这几条IP，并添加 <code>CNAME</code> 记录：</p><img src="https://i.loli.net/2020/09/12/9mdcMTJOi61vRGK.png" alt="image-20200912030148298" style="zoom:80%;" /><p>&emsp;&emsp;操作完成后，回到 Neltify，点击 <code>Add custom domain</code> 添加你的域名：</p><img src="https://i.loli.net/2020/09/12/ftZqQe9b6z5Juxm.png" alt="image-20200912030601733" style="zoom:80%;" /><p>&emsp;&emsp;然后是为网站添加 SSL，我<a href="https://www.yleave.top/2020/09/11/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%B9%B6%E6%B7%BB%E5%8A%A0ssl/#%E7%BB%99%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E6%B7%BB%E5%8A%A0-SSL">之前</a>已经申请过 SSL 证书了，因此点击添加证书按钮，将证书的内容上传：</p><img src="https://i.loli.net/2020/09/12/q1xW8fHOP6VXr2t.png" alt="image-20200912030811357" style="zoom:67%;" /><img src="https://i.loli.net/2020/09/12/5sAOkrjQXTwGNPZ.png" alt="image-20200912030928206" style="zoom: 67%;" /><p>&emsp;&emsp;若没有申请过证书的话，Netlify 也提供了免费证书的发放服务：</p><p>&emsp;&emsp;点击 <code>Let&#39;s Encrypt</code>，完成后如下：</p><img src="https://i.loli.net/2020/09/12/di6oRcH5FhTbsEQ.png" alt="image-20200912031035996" style="zoom: 67%;" /><p>&emsp;&emsp;至此，使用 Netlify 自动部署博客步骤就全部完成了，之后添加新内容提交后， Netlify 会自动打包发布，非常方便:</p><img src="https://i.loli.net/2020/09/12/aVEbmrYw2MJtFQR.png" alt="image-20200912032343535" style="zoom: 80%;" /><hr><p><strong>Ref:</strong></p><p><a href="https://www.cnblogs.com/37Y37/p/12551839.html">https://www.cnblogs.com/37Y37/p/12551839.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/77651304">https://zhuanlan.zhihu.com/p/77651304</a></p>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netlify</tag>
      
      <tag>自动化部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自定义域名并添加SSL</title>
    <link href="/2020/09/11/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%B9%B6%E6%B7%BB%E5%8A%A0SSL/"/>
    <url>/2020/09/11/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%B9%B6%E6%B7%BB%E5%8A%A0SSL/</url>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;本博客是部署在 Github Pages 上的，因此访问时域名为： <code>yleave.github.io</code> ，不过还是感觉太长了，于是乎捣鼓了两天，给博客加了个域名并添加了SSL证书，下面记录了一些捣鼓经验。</p><h1 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h1><p>&emsp;&emsp;前置条件：一个已部署在 github 上的博客</p><p>&emsp;&emsp;首先，需要注册一个域名，我是在<a href="https://wanwang.aliyun.com/domain/?spm=5176.100251.111252.21.72014f15uvzIEz">阿里云</a>上注册的，首年 9 元，续费 27 元，价格还可以接受，步骤也不麻烦。</p><p>&emsp;&emsp;第一次注册的需要实名认证，而名认证审核时间大概半天就能完成。</p><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>&emsp;&emsp;域名注册完成后，进入解析页面，点击添加记录：</p><img src="https://i.loli.net/2020/09/11/izd5jS7e2TVDgM4.png" alt="image-20200911163555583" style="zoom:80%;" /><p>&emsp;&emsp;先获取你的博客 IP 地址，可以使用命令行窗口 <code>ping</code> 一下：<code>ping name.github.io</code>  :</p><img src="https://i.loli.net/2020/09/11/dUDfhNnM5B6xTtL.png" alt="image-20200911163939089" style="zoom:80%;" /><p>&emsp;&emsp;或是去<a href="http://tool.chinaz.com/dns">网站</a>查一下：</p><img src="https://i.loli.net/2020/09/11/rp169ZtWCVNwMfD.png" alt="image-20200911164127950" style="zoom:80%;" /><p>&emsp;&emsp;这几个其实都是 github 的 IP 地址，应该所有在 github 上部署的博客都是这几个地址。</p><p>&emsp;&emsp;可以只选择一个 ip 进行解析，不过我这边将这四个地址都解析了：</p><img src="https://i.loli.net/2020/09/11/iTPvBhr7J8nEmV4.png" alt="image-20200911164331299" style="zoom: 67%;" /><img src="https://i.loli.net/2020/09/11/PGYWM2OEjw7ycRk.png" alt="image-20200911164419343" style="zoom:80%;" /><p>&emsp;&emsp;然后解析一个 <code>CNAME</code> 类型的记录：</p><img src="https://i.loli.net/2020/09/11/zbDgrJtNh7d2uKL.png" alt="image-20200911164528656" style="zoom: 67%;" /><p>&emsp;&emsp;最后，在博客所在项目的 <code>source</code> 文件夹下新建一个 <code>CNAME</code> 文件，写入申请的域名：</p><img src="https://i.loli.net/2020/09/11/buEdOwZFxce8jQz.png" alt="image-20200911164738664" style="zoom:80%;" /><p>&emsp;&emsp;不过这一步不知道它的作用是什么，但看其他教程都有这步，就加上去吧。</p><p>&emsp;&emsp;到这里，域名解析步骤就完成了。</p><h2 id="github-绑定"><a href="#github-绑定" class="headerlink" title="github 绑定"></a>github 绑定</h2><p>&emsp;&emsp;这个步骤中将解析的域名与 github 上的博客项目绑定起来。</p><p>&emsp;&emsp;先进入博客项目的 <code>Settings</code> 中： </p><img src="https://i.loli.net/2020/09/11/rEj2z1pJh76ctsg.png" alt="image-20200911165059055" style="zoom:80%;" /><p>&emsp;&emsp;拉到底部，在 <code>Custom domain</code> 栏中填入申请的域名：</p><img src="https://i.loli.net/2020/09/11/3c5nN9RMHSADZbX.png" alt="image-20200911165140522" style="zoom:67%;" /><p>&emsp;&emsp;到这一步，自定义域名的步骤就完成了，但由于我是第一次注册，还需等待实名认证完成，审核完成后就能通过 <code>www.yleave.top</code> 和 <code>yleave.top</code> 访问了。</p><img src="https://i.loli.net/2020/09/11/tSsPnkwdz59qO4F.png" alt="image-20200911165328548" style="zoom:80%;" /><h1 id="给博客网站添加-SSL"><a href="#给博客网站添加-SSL" class="headerlink" title="给博客网站添加 SSL"></a>给博客网站添加 SSL</h1><img src="https://i.loli.net/2020/09/11/WX46dDuBK8OvMig.png" alt="image-20200911165528080" style="zoom:80%;" /><p>&emsp;&emsp;关于 SSL 和 HTTPS 的介绍这里就不说明了，这篇<a href="https://yq.aliyun.com/articles/721195">文章</a>有一些简介可以看看。</p><h2 id="申请免费SSL证书"><a href="#申请免费SSL证书" class="headerlink" title="申请免费SSL证书"></a>申请免费SSL证书</h2><p>&emsp;&emsp;证书这边我是在 <a href="https://console.qcloud.com/ssl">腾讯云</a>申请免费的 SSL 证书，不过只有一年免费时间。</p><img src="https://i.loli.net/2020/09/11/qwMHnYxtACdPuiW.png" alt="image-20200911170245686" style="zoom:80%;" /><p>&emsp;&emsp;阿里云应该也能申请，不过我没找到，因此去腾讯云申请了，但是证书申请和域名申请不在同一个网站的话，后面上传证书时会稍微麻烦一些，不过也还好。</p><p>&emsp;&emsp;申请步骤很简单，只需要填写一个表格并实名认证就行。</p><img src="https://i.loli.net/2020/09/11/QWJShizDbOuTClr.png" alt="image-20200911170359563" style="zoom:80%;" /><p>&emsp;&emsp;申请完成后需要进行 DNS 验证：</p><img src="https://i.loli.net/2020/09/11/IQqkwEmhx62lcav.png" alt="image-20200911171152620" style="zoom:80%;" /><p>&emsp;&emsp;因此再回到阿里云的 DNS 解析页面，将上表中出现的字段填入解析记录中：</p><img src="https://i.loli.net/2020/09/11/QGcaB6q4i9dOPVL.png" alt="image-20200911171242463" style="zoom:80%;" /><p>然后，等待<a href="https://console.cloud.tencent.com/ssl/detail/gLRDXe3L">腾讯云</a>那边的 DNS 验证</p><img src="https://i.loli.net/2020/09/11/YrRZfFmPxEBCqze.png" alt="image-20200911171319884" style="zoom:80%;" /><p>&emsp;&emsp;过了大概五分钟，腾讯云发来短信，提示 DNS 解析成功。</p><img src="https://i.loli.net/2020/09/11/7MBHXatQUG5Z4A6.png" alt="image-20200911171410380" style="zoom:67%;" /><p>&emsp;&emsp;证书下载下来是一个压缩包，里面是这样子的，我估摸着是不同代理的证书：</p><img src="https://i.loli.net/2020/09/11/X6adrQ8wRF79fU2.png" alt="image-20200911171553060" style="zoom:80%;" /><h2 id="上传SSL证书"><a href="#上传SSL证书" class="headerlink" title="上传SSL证书"></a>上传SSL证书</h2><p>&emsp;&emsp;在腾讯云上申请完 SSL 证书后，需要将其上传到域名申请的地方，也就是阿里云的<a href="https://yundunnext.console.aliyun.com/?p=casnext#/overview/cn-hangzhou">证书管理中心</a>：</p><img src="https://i.loli.net/2020/09/11/e8iPSIDBodCVhlq.png" alt="image-20200911171741501" style="zoom:80%;" /><p>&emsp;&emsp;证书名称可以随便填，证书文件就是 <code>.crt</code> 的文件中的内容，一个证书文件对应了一个私钥，如 Apache 目录下， <code>_www.yleave.top.crt</code> 就是证书文件，<code>.key</code> 就是私钥，填入这两个就好了：</p><img src="https://i.loli.net/2020/09/11/8Ns2I6nyMZFhrAK.png" alt="image-20200911171826131" style="zoom:80%;" /><img src="https://i.loli.net/2020/09/11/DvlAJ6pV9KyXGdf.png" alt="image-20200911171859459" style="zoom:80%;" /><p>&emsp;&emsp;我这边先是上传了两个证书：</p><p><img src="https://i.loli.net/2020/09/11/KFQq7to6xyhvfXC.png" alt="image-20200911171934657"></p><p>&emsp;&emsp;上传完后点击部署按钮：</p><img src="https://i.loli.net/2020/09/11/eJ1HLE5PRY3mhqO.png" alt="image-20200911172010043" style="zoom:80%;" /><p>&emsp;&emsp;全选，点击部署：</p><img src="https://i.loli.net/2020/09/11/rgBiSMDbJIOoNtp.png" alt="image-20200911172049141" style="zoom: 80%;" /><p>&emsp;&emsp;不过刚部署完后访问网站还是 <code>http</code> 类型的，当时感觉是不是自己哪错了（后来发现应该是要等一会儿才能生效），于是看<a href="https://www.cnblogs.com/sslwork/p/5984167.html">一个博文</a> 里说还需要部署中间证书，于是按照上面的方法又上传部署了一个带中间证书内容的证书，但刚部署完仍未生效。</p><p>&emsp;&emsp;不过过了一会儿，正当我沮丧找其他博文参考时，又访问了一下发现证书好像生效了：</p><img src="https://i.loli.net/2020/09/11/LlnEkSad2G4eMVP.png" alt="image-20200911172535154" style="zoom:80%;" /><p>&emsp;&emsp;最后，在浏览其他博文时，发现 github 上还有一个 <code>Enforce HTTPS</code> 选项，暂时不清楚作用，总之先勾选上：</p><img src="https://i.loli.net/2020/09/11/MWEApjaytkvcVCT.png" alt="image-20200911172829156" style="zoom:67%;" /><p>&emsp;&emsp;捣鼓了两天，虽然过程中对一些步骤的作用还不太清楚，但最后成功完成，时间还是没白费的</p>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自定义域名</tag>
      
      <tag>SSL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Python 编写 MapReduce -- Hadoop Streaming</title>
    <link href="/2020/08/18/%E5%A4%A7%E6%95%B0%E6%8D%AE/hadoop%20streaming/"/>
    <url>/2020/08/18/%E5%A4%A7%E6%95%B0%E6%8D%AE/hadoop%20streaming/</url>
    
    <content type="html"><![CDATA[<p>要使用其他语言编写 MR 任务，首先要了解一下 Hadoop Streaming</p><h2 id="hadoop-streaming-简介"><a href="#hadoop-streaming-简介" class="headerlink" title="hadoop streaming 简介"></a>hadoop streaming 简介</h2><p>&emsp;&emsp;Hadoop streaming 是 Hadoop的一个工具， 它帮助用户创建和运行一类特殊的 map/reduce 作业， 这些特殊的map/reduce 作业是由一些可执行文件或脚本文件充当 mapper 或者 reducer。</p><p>&emsp;&emsp;也就是 hadoop streaming 可以帮助我们使用其他语言（非 java) 来编写 mapper 和 reducer。</p><p><strong>下面使用 python 来编写 MR 脚本</strong></p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>&emsp;&emsp;在 hadoop streaming 中，mapper 和 reducer 都是可执行文件，它们从标准输入流读取数据，使用标准输出流输出数据。</p><p>&emsp;&emsp;在 python 中就是：<code>sys.stdin</code> 和 <code>print</code></p><p>&emsp;&emsp;mapper 和 reducer 会一行一行的读取数据，根据分隔符（默认为 <code>tab</code>）将读入的数据切分为 <code>key</code> 和 <code>value</code>，同时，输出的数据也需要是一个 <code>key,value</code> 对，在第一个 <code>tab</code> 分隔符前的会被认为是 <code>key</code>，后面的都作为 <code>value</code>。</p><p>&emsp;&emsp;如，输出时 <code>print(&quot;%s\t%s&quot;, %(key, value))</code></p><h2 id="MR-编写示例"><a href="#MR-编写示例" class="headerlink" title="MR 编写示例"></a>MR 编写示例</h2><p>&emsp;&emsp;假设有数据如下，下面编写 MR 实现 “倒排”。</p><pre><code class="hljs scheme"><span class="hljs-number">1</span>    <span class="hljs-symbol">&#x27;bread</span>&#x27; <span class="hljs-symbol">&#x27;milk</span>&#x27; <span class="hljs-symbol">&#x27;vegetable</span>&#x27; <span class="hljs-symbol">&#x27;fruit</span>&#x27; <span class="hljs-symbol">&#x27;eggs</span>&#x27;<span class="hljs-number">2</span>    <span class="hljs-symbol">&#x27;noodle</span>&#x27; <span class="hljs-symbol">&#x27;beef</span>&#x27; <span class="hljs-symbol">&#x27;pork</span>&#x27; <span class="hljs-symbol">&#x27;water</span>&#x27; <span class="hljs-symbol">&#x27;socks</span>&#x27; <span class="hljs-symbol">&#x27;gloves</span>&#x27; <span class="hljs-symbol">&#x27;shoes</span>&#x27; <span class="hljs-symbol">&#x27;rice</span>&#x27;<span class="hljs-number">3</span>    <span class="hljs-symbol">&#x27;socks</span>&#x27; <span class="hljs-symbol">&#x27;gloves</span>&#x27;<span class="hljs-number">4</span>    <span class="hljs-symbol">&#x27;bread</span>&#x27; <span class="hljs-symbol">&#x27;milk</span>&#x27; <span class="hljs-symbol">&#x27;shoes</span>&#x27; <span class="hljs-symbol">&#x27;socks</span>&#x27; <span class="hljs-symbol">&#x27;eggs</span>&#x27;<span class="hljs-number">5</span>    <span class="hljs-symbol">&#x27;socks</span>&#x27; <span class="hljs-symbol">&#x27;shoes</span>&#x27; <span class="hljs-symbol">&#x27;sweater</span>&#x27; <span class="hljs-symbol">&#x27;cap</span>&#x27; <span class="hljs-symbol">&#x27;milk</span>&#x27; <span class="hljs-symbol">&#x27;vegetable</span>&#x27; <span class="hljs-symbol">&#x27;gloves</span>&#x27;<span class="hljs-number">6</span>    <span class="hljs-symbol">&#x27;eggs</span>&#x27; <span class="hljs-symbol">&#x27;bread</span>&#x27; <span class="hljs-symbol">&#x27;milk</span>&#x27; <span class="hljs-symbol">&#x27;fish</span>&#x27; <span class="hljs-symbol">&#x27;crab</span>&#x27; <span class="hljs-symbol">&#x27;shrimp</span>&#x27; <span class="hljs-symbol">&#x27;rice</span>&#x27;</code></pre><p>&emsp;&emsp;所谓 “倒排” 就是将数据中的每一个字符 <code>word</code> 与其前面的编号 <code>num</code> 对应起来，如 <code>bread</code>，它在编号 <code>1</code>、<code>4</code>、<code>6</code> 中都有出现，因此 倒排 的结果就是：<code>bread 1 4 6</code>。</p><p>&emsp;&emsp;首先，编写一个 <code>mapper</code> 来将数据拆分为一个个的 <code>word, num</code> 对：</p><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment"># coding=utf-8</span><span class="hljs-keyword">import</span> sys<span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> sys.stdin:    line = line.strip()    words = line.split()    num = words[<span class="hljs-number">0</span>]    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(words)):        word = words[i]        print(<span class="hljs-string">&#x27;%s\t%s&#x27;</span> % (word, num))</code></pre><p>&emsp;&emsp;接着，编写 <code>reducer </code>，将同一个 <code>word</code> 的所属编号收集到一起：</p><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><span class="hljs-comment">#coding:utf-8</span><span class="hljs-keyword">import</span> sysoutput = &#123;&#125;curWord = <span class="hljs-string">&#x27;&#x27;</span>wordCount = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> sys.stdin:    line = line.strip()    word,tid = line.split()    <span class="hljs-keyword">if</span> output.get(word) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:        output[word] = []    output[word].append(tid)    <span class="hljs-keyword">if</span> curWord == <span class="hljs-string">&#x27;&#x27;</span>:        curWord = word    <span class="hljs-keyword">if</span> curWord == word:        wordCount += <span class="hljs-number">1</span>    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">if</span> wordCount &gt;= <span class="hljs-number">3</span>: <span class="hljs-comment"># 若一个单词对应的编号数量不少于 3，则输出</span>            print(<span class="hljs-string">&#x27;%s\t%r&#x27;</span> % (curWord, output[curWord]))        wordCount = <span class="hljs-number">1</span>        curWord = word</code></pre><h2 id="执行-MR-脚本"><a href="#执行-MR-脚本" class="headerlink" title="执行 MR 脚本"></a>执行 MR 脚本</h2><p>&emsp;&emsp;通常执行 MR 脚本需要在 hadoop 系统上工作，但是为了防止出错， <code>mapper</code> 脚本可以在本地测试，而 <code>reducer</code> 脚本通常涉及排序，在本地测试可能会得到错误结果。</p><h3 id="本地测试"><a href="#本地测试" class="headerlink" title="本地测试"></a>本地测试</h3><p>&emsp;&emsp;在当前路径下有 <code>t1.txt</code> 存放数据，<code>mapper/mapper1.py</code> 为 mapper 脚本，在 <code>shell</code> 上运行命令：</p><p><code>cat t1.txt | python mapper/mapper1.py</code> ，这样 mapper 运行的结果就会打印在屏幕上了，若想要输出到文件中，可以使用 <code>&gt;</code> ，即 <code>cat t1.txt | python mapper/mapper1.py &gt; out1.txt</code></p><img src="https://i.loli.net/2020/09/11/iXvlZ6Tx2MoReJs.png" alt="image-20200828222203501" style="zoom:80%;" /><p>&emsp;&emsp;若想要读取一个文件夹下的所有文件的话，则改为：<code>cat data/*.txt | python mapper/mapper1.py</code> </p><h3 id="分布式系统上执行"><a href="#分布式系统上执行" class="headerlink" title="分布式系统上执行"></a>分布式系统上执行</h3><p>&emsp;&emsp;首先，将数据上传到 HDFS 的 <code>/pj</code> 目录下：<code>hadoop fs -put t1.txt /pj</code></p><p>&emsp;&emsp;然后使用 hadoop streaming 执行 MapReduce，hadoop streaming 需要提供一些设置参数，可以在命令行中直接输入，也可以编写 <code>shell</code> 脚本来执行（推荐）</p><p>&emsp;&emsp;来看 <code>shell</code> 脚本的编写，文件命名后缀是 <code>.sh</code></p><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span>hadoop jar /usr/<span class="hljs-built_in">local</span>/hadoop/share/hadoop/tools/lib/hadoop-streaming-2.7.7.jar \-jobconf mapreduce.reduce.shuffle.memory.limit.percent=0.1 \-jobconf mapreduce.reduce.shuffle.input.buffer.percent=0.3 \-jobconf mapreduce.map.memory.mb=512 \-jobconf mapreduce.reduce.memory.mb=512 \-jobconf mapred.map.capacity=100 \-jobconf mapred.reduce.capacity=100 \-jobconf mapred.job.name=reverse_sort \-file mapper/mapper1.py -mapper mapper/mapper1.py  \-file reducer/reducer1.py -reducer reducer/reducer1.py  \-input /pj/t1.txt -output /pj/output/</code></pre><p>&emsp;&emsp;简单说明一下这个 <code>shell</code> 脚本：</p><p>&emsp;&emsp;第一行 <code>#!/bin/bash</code> 说明这个是一个 <code>shell</code> 脚本</p><p>&emsp;&emsp;第二行中的 <code>hadoop-streaming-2.7.7.jar</code> jar 包路径是在自己安装 hadoop 的路径下，应该都会有的</p><p>&emsp;&emsp;再下面，<code>-jobconfig</code> 的那些参数根据自己的需要来设置，具体可以参照<a href="https://cwiki.apache.org/confluence/display/HADOOP2/JobConfFile">官网</a> 和这篇<a href="https://www.jianshu.com/p/1b69df99d949">博客</a>的介绍</p><p>&emsp;&emsp;而 <code>file</code>、<code>mapper</code>、<code>reducer</code>、<code>input</code> 和 <code>output</code> 是必须的。</p><p>&emsp;&emsp;其中 <code>file</code> 选项是让f ramework 把可执行文件作为作业的一部分，一起打包提交。</p><p>&emsp;&emsp;接下来，运行这个 <code>shell </code> 脚本，假设这个 <code>shell</code> 脚本的文件名是 <code>run.sh</code>。</p><p>&emsp;&emsp;<code>shell</code> 脚本有三种运行方式：</p><ol><li><p>先输入 <code>chmod +x run.sh</code> 赋予可执行权限，然后在命令行中输入 <code>./run.sh</code> 即可运行</p><img src="https://i.loli.net/2020/09/11/1SlUOAciyk4GLhK.png" alt="image-20200828224508743" style="zoom:80%;" /></li><li><p>使用 <code>sh run.sh</code> 运行</p></li><li><p>使用 <code>source run.sh</code> 运行</p></li></ol><p>&emsp;&emsp;脚本若正确执行完毕，拉取 HDFS 上的结果：<code>hadoop fs -get /pj/output</code></p>   <img src="https://i.loli.net/2020/09/11/kIN7CSXZxvsniMp.png" alt="image-20200828224740795" style="zoom:80%;" /><p>&emsp;&emsp;顺便一提，若不是使用编写 <code>shell</code> 脚本的方式运行，则上面的 hadoop streaming 运行方式为：</p><img src="https://i.loli.net/2020/09/11/G4fhzH6aeVMjX8E.png" alt="image-20200828225015917" style="zoom:80%;" /><p>&emsp;&emsp;即将脚本里的内容全写在命令行中。</p><h2 id="关于-hadoop-streaming-配置的一些参考学习文章"><a href="#关于-hadoop-streaming-配置的一些参考学习文章" class="headerlink" title="关于 hadoop streaming 配置的一些参考学习文章"></a>关于 hadoop streaming 配置的一些参考学习文章</h2><p><a href="http://hadoop.apache.org/docs/r1.0.4/cn/streaming.html">Hadoop Streaming</a></p><p><a href="https://help.aliyun.com/document_detail/44024.html?spm=a2c4g.11186623.6.914.162d19d6A0ZelV">阿里云Hadoop Streaming</a></p><p><a href="https://www.cnblogs.com/shay-zhangjin/p/7714868.html">Hadoop Streaming详解</a></p><p><a href="https://blog.csdn.net/Alanyungz/article/details/106767668">Hadoop Streaming介绍与实战</a></p><p><a href="https://cwiki.apache.org/confluence/display/HADOOP2/JobConfFile">JobConfFile</a> </p><p><a href="http://www.uml.org.cn/zjjs/201205303.asp">hadoop作业调优参数整理及原理</a></p><p><a href="https://blog.csdn.net/loveblair1990/article/details/53608293">hadoop streaming参数配置</a></p><p><a href="https://www.jianshu.com/p/1b69df99d949">Hadoop-Streaming参考一</a></p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>big data</tag>
      
      <tag>hadoop streaming</tag>
      
      <tag>MapReduce</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>写在前面</title>
    <link href="/2020/08/17/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/"/>
    <url>/2020/08/17/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;2019 初，我开始了我的第一篇博客，说是写作，但更多的是 「做笔记」「转载」 等没有深度的文章。</p><p>&emsp;&emsp;开始是在 <a href="https://blog.csdn.net/qq_38701868">CSDN</a> 上写博客，一些不想让别人看的笔记就使用有道云笔记写。慢慢的，看着一些大牛的博客，感觉他们的文章有深度、有干货，也有自己的理解，再看看我的 “博客”，大多是知识积累笔记，而对于一些知识点的理解并不是很透彻，即怕误导别人又怕被别人吐槽…发布博客的激情也就逐渐淡下来了。越来越多的笔记选择在本地的有道云笔记上记录而不是再发布到 CSDN 上，最终，零零散散的发了快一年的博客后，我停止了 CSDN 上的 “写作”。</p><p>&emsp;&emsp;后来，面向浏览器编程的我，看了许多大佬的博客和他们炫酷的博客网站后，萌生了搭网站写博客的想法，也想着能在搭博客的过程中学习一些 Web 知识，不过由于对自己文章的信心不足，这个想法也因此搁置了很久，直到一次逛B站时看到了 <strong>Up 主 CodeSheep</strong>  的 <a href="https://www.bilibili.com/video/BV1Px411d74c">为什么程序员必须写技术博客?…</a> 这个视频后再次激起了我搭建自己的博客网站并再次开始发布博客的想法。</p><p>&emsp;&emsp;视频中分享了自己写博客的感想，以及写博客的重要性和必要性，但对我说服力最大的还是视频中提到的<strong>写博客误区</strong>，以及对这个误区的纠正:</p><blockquote><p>&emsp;&emsp;<strong>误区一</strong>：初学者写博客没技术含量怎么办（感同身受</p><p>&emsp;&emsp;<strong>误区二</strong>：初学者写博客会不会被喷   </p><p>​&emsp;&emsp;对于误区二，虽然只是不到一年的写博客经历，但基本上没遇到喷我博客的人（可能是我博客的流量太小hh），并且偶尔有一些感谢的留言和点赞还是会有点小开心的~</p></blockquote><p>&emsp;&emsp;诚然，写博客能够在以后找工作，面试时加分，不过正如视频里所说，写博客更重要的是能够在写作过程中锻炼自己的语言表达和知识总结能力。知识需要沉淀，每学的一些知识，每做的一件事，都需要总结、输出，学习过的内容能够用自己的话说出来，能够有自己的理解，才能说你学过了这个知识。这点我在做笔记、写博客时有些体会，需要将学习的知识整理、凝练一番，在写博客的过程中才能有一个比较清晰的思路，写完后立马再回顾一下会感觉对这个知识点有着更加清晰的理解。</p><p>&emsp;&emsp;即使是一个小的技术点、一个小的 idea，甚至一些简单的笔记，都可以写到博客中，我相信积累的力量。</p><p>&emsp;&emsp;就这样，我再次开始了我的写博客之旅，或许博客内容会有些青涩，有些错误，请见谅~</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
