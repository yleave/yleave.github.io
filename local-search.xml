<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>股票问题</title>
    <link href="/2021/01/09/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/"/>
    <url>/2021/01/09/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>总结一下力扣上的股票交易问题。有：</p><ol><li><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121.买卖股票的最佳时机</a></p></li><li><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></p></li><li><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></p></li><li><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a></p></li><li><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期</a></p></li><li><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a></p></li></ol><p>这些问题基本上都是差不多的套路，都可以使用动态规划或是贪心解决。</p><h1 id="121买卖股票的最佳时机"><a class="markdownIt-Anchor" href="#121买卖股票的最佳时机"></a> 121.买卖股票的最佳时机</h1><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/</a></p><p><strong>题目简述</strong>：给定一个数组表示第 <code>i</code> 天的股票价格，规定<strong>最多只能完成一笔交易（买入+卖出一次）</strong>，求能获取的最大利润。</p><p><strong>例1：</strong></p><p>输入: <code>[7,1,5,3,6,4]</code></p><p>输出: <code>5</code></p><p>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</p><p><strong>例2：</strong></p><p>输入: <code>[7,6,4,3,1]</code></p><p>输出: <code>0</code></p><p>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p><h2 id="解法1"><a class="markdownIt-Anchor" href="#解法1"></a> 解法1：</h2><p>  由于规定了<strong>只能买卖一次</strong>，因此我们要想得到最大利润，那么我们肯定是要在<strong>最低价格的时候买入</strong>，在<strong>最高价格的时候卖出</strong>。并且我们不能在买入前卖出，也就是我们要找到在买入之后的最高价格。</p><p>  按照这个想法，代码是这样的：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices</span>) </span>&#123;    <span class="hljs-keyword">let</span> len = prices.length;    <span class="hljs-keyword">let</span> maxPro = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 首先初始化第一天的最低最高价</span>    <span class="hljs-keyword">let</span> min = prices[<span class="hljs-number">0</span>], max = prices[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        <span class="hljs-comment">// 若找到了一个更低的价格，那么重置最高最低价</span>        <span class="hljs-keyword">if</span> (min &gt; prices[i]) &#123;            min = max = prices[i];        &#125;<span class="hljs-comment">// 找到买入价格之后的最高价</span>        max = <span class="hljs-built_in">Math</span>.max(max, prices[i]);        <span class="hljs-comment">// 对每个较高的价格进行一次计算</span>        maxPro = <span class="hljs-built_in">Math</span>.max(maxPro, max - min);    &#125;    <span class="hljs-keyword">return</span> maxPro;&#125;;</code></pre><p>  上面的代码可以再简化，最高价 <code>max</code> 其实是不必要的，因为我们 <code>max</code> 每次循环都会更新为较大值，并且这个较大值我们只需要用到一次，后面当 <code>max</code> 没变化时， <code>maxPro</code> 的计算就重复了。</p><p>  因此我们只需要更新 <code>min</code> 的价格，<code>max</code> 使用每天的价格 <code>prices[i]</code> 替代即可：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices</span>) </span>&#123;    <span class="hljs-keyword">let</span> len = prices.length;    <span class="hljs-keyword">let</span> maxPro = <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> min = prices[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        min = <span class="hljs-built_in">Math</span>.min(min, prices[i]);        <span class="hljs-comment">// 计算当天价格与历史最低价的差，选取最高利润</span>        maxPro = <span class="hljs-built_in">Math</span>.max(maxPro, prices[i] - min);    &#125;    <span class="hljs-keyword">return</span> maxPro;&#125;;</code></pre><h1 id="122买卖股票的最佳时机-ii"><a class="markdownIt-Anchor" href="#122买卖股票的最佳时机-ii"></a> 122.买卖股票的最佳时机 II</h1><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/</a></p><p><strong>题意简述</strong>：给定数组 <code>prices</code>，第 <code>i</code>个元素是股票第 <code>i</code> 天的价格。</p><p>规定可以完成多次交易，但手中最多只能持有一只股票（即在卖出之前不能买入）。</p><p><strong>例1</strong>：</p><p>输入: <code>[7,1,5,3,6,4]</code></p><p>输出: <code>7</code></p><p>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br />随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p><p><strong>例2：</strong></p><p>输入: <code>[1,2,3,4,5]</code></p><p>输出: <code>4</code></p><p>解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br />注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。<br />因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p><h2 id="解法1贪心1"><a class="markdownIt-Anchor" href="#解法1贪心1"></a> 解法1：贪心1</h2><p>  我们可以把股票的价格看作一张折线图：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost@master/img/image-20210109165626358.png" alt="image-20210109165626358" style="zoom: 67%;" /><p>  想要获取多次交易的最大利润，其实就是找到折线图中的<strong>波峰波谷</strong>位置，我们每次买入股票时贪心的<strong>选择距离我们最近的波谷点买入，然后再选择最近的波峰处卖出</strong>。如上图就是先选择第二天的波谷 <code>1</code> 买入，再选择第三天的波峰 <code>5</code> 卖出；再选择第四天的波谷 <code>3</code> 买入，再选择第五天的波峰 <code>6</code> 卖出。</p><p>  这样下来获得的利润就是：<code>(5 - 1) + (6 - 3) = 7</code></p><p>  再注意边界的处理即可：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices</span>) </span>&#123;    <span class="hljs-keyword">let</span> profit = <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> len = prices.length;    <span class="hljs-keyword">let</span> cost; <span class="hljs-comment">// 当前持有的股票价格</span>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(i &lt; len) &#123;        <span class="hljs-comment">// 先找到波谷</span>        <span class="hljs-keyword">while</span>(i + <span class="hljs-number">1</span> &lt; len &amp;&amp; prices[i] &gt; prices[i+<span class="hljs-number">1</span>]) &#123;            i++;        &#125;        cost = prices[i++];        <span class="hljs-comment">// 边界处理</span>        <span class="hljs-keyword">if</span> (i &lt; len) &#123;            <span class="hljs-comment">// 再找到波峰</span>            <span class="hljs-keyword">while</span>(i + <span class="hljs-number">1</span> &lt; len &amp;&amp; prices[i] &lt; prices[i+<span class="hljs-number">1</span>]) &#123;                i++;            &#125;            profit += prices[i++] - cost;        &#125;    &#125;    <span class="hljs-keyword">return</span> profit;&#125;;</code></pre><h2 id="解法2贪心2"><a class="markdownIt-Anchor" href="#解法2贪心2"></a> 解法2：贪心2</h2><p>  我们观察一下 例2 的折线图：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost@master/img/image-20210109172818259.png" alt="image-20210109172818259" style="zoom:67%;" /><p>  我们知道它的最大利润是在第一天买入，在第五天卖出，也就是 <code>5 - 1 = 4</code>，这<strong>和我们连续交易四次获得的利润是一样的</strong>：<code>(2 - 1) + (3 - 2) + (4 - 3) + (5 - 4) = 4</code>。</p><p>  因此我们可以一天天的累积，当上一天的价格比当天价格低时，我们的最终利润就加上这个差价，否则就不用管它。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices</span>) </span>&#123;    <span class="hljs-keyword">let</span> len = prices.length;    <span class="hljs-keyword">let</span> profit = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        profit += <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, prices[i] - prices[i<span class="hljs-number">-1</span>]);    &#125;    <span class="hljs-keyword">return</span> profit;&#125;;</code></pre><h2 id="解法3动态规划"><a class="markdownIt-Anchor" href="#解法3动态规划"></a> 解法3：动态规划</h2><p>  对于股票交易，我们只有两种状态：<strong>未持有股票</strong> 和 <strong>持有股票</strong>。</p><p>  因此我们可以使用一个数组来存储每一天在每个状态下能够获取的最大利润：<code>dp[len][2]</code>。</p><p>  其中 <code>dp[i][0]</code> 表示第 <code>i</code> 天<strong>未持有</strong>股票所能够获得的最大利润</p><p>  <code>dp[i][1]</code> 表示第 <code>i</code> 天<strong>持有</strong>股票能够获得的最大利润。</p><p>  因此，对于第 <code>i</code> 天：</p><ul><li><p><strong>未持有股票</strong>能够获得的最大利润也可以从第 <code>i-1</code> 天的状态转移而来，也就是：</p><ul><li>第 <code>i-1</code> 天持有股票，在第 <code>i</code> 天卖出：<code>dp[i-1][1] + prices[i]</code></li><li>第 <code>i-1</code> 天未持有股票，第 <code>i</code> 天也没有买入：<code>dp[i-1][0]</code></li></ul><p>也就是 <code>dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i])</code></p></li><li><p><strong>持有股票</strong>能够获得的最大利润可以从第 <code>i-1</code> 天的状态转移而来，也就是：</p><ul><li>第 <code>i-1</code> 天未持有股票，在第 <code>i</code> 天买入了股票：<code>dp[i-1][0] - prices[i]</code></li><li>第 <code>i-1</code> 天就已经持有了股票：<code>dp[i-1][1]</code></li></ul><p>也就是 <code>dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i])</code></p></li></ul><p>  <strong>边界</strong>也就是第 <code>1</code> 天持有股票的话，最大利润 <code>dp[0][1] = -prices[0]</code> （买入花了这么多钱）</p><p>  其他默认为 <code>0</code>，表示还未获得利润。</p><p>  最后返回最<strong>后一天未持有股票的最大利润</strong>，因为我们不可能在最后一天还花钱买股票，后面就没得卖了…</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices</span>) </span>&#123;    <span class="hljs-keyword">let</span> n = prices.length;    <span class="hljs-keyword">let</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n).fill(<span class="hljs-number">0</span>).map(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">2</span>).fill(<span class="hljs-number">0</span>));    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">Math</span>.max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] + prices[i]);        dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">Math</span>.max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] - prices[i]);    &#125;    <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];&#125;;</code></pre><h3 id="空间优化"><a class="markdownIt-Anchor" href="#空间优化"></a> 空间优化</h3><p>  仔细观察可以发现，我们第 <code>i</code> 天的状态都只由第 <code>i-1</code> 天的状态转移而来，那么第 <code>0 - i-2</code> 天的状态就都没用了，因此我们可以节约空间，<strong>只使用两个变量保存上一天的状态</strong>即可。</p><p>  具体我们使用 <code>hold</code> 表示<strong>持有股票</strong>能获取的最大利润；</p><p>  使用 <code>unhold</code> 表示<strong>未持有</strong>股票能获取的最大利润。</p><p>  根据我们上面的分析：</p><p>  <code>hold</code> 能由 <code>unhold</code> 转移而来：<code>hold = max(hold, unhold - prices[i])</code> （上一天未持有，当天买入）</p><p>  <code>unhold</code> 也能由 <code>hold</code> 转移而来：<code>unhold = max(unhold, hold + prices[i])</code> （上一天持有，当天卖出）</p><p>  同样，初始化第一天持有股票的状态 <code>hold = -prices[0]</code>，未持有股票的状态 <code>unhold = 0</code>、</p><p>  在下面的代码中，我们在同一天中更新了 <code>hold</code> 和 <code>unhold</code> 这两个状态，按我们对这两个变量的定义，它们在<strong>未更新前</strong>是表示上一天状态，但我们在更新时却使用了<strong>当天更新后</strong>的其中一个状态来更新另一个状态，这样不是会有影响吗？</p><p>  乍一看感觉会有影响，不过我们再进一步分析可以发现，这其实是<strong>没有影响的</strong>，为了方便观察，我们把<strong>上一天</strong>的状态定义为 <code>hold1</code>和 <code>unhold1</code>，<strong>当天</strong>的状态定义为 <code>hold</code> 和 <code>unhold</code>：</p><p>  我们在代码中先更新了 <code>hold</code> 状态为 <code>hold = max(hold1, unhold1 - prices[i])</code></p><p>  然后我们更新 <code>unhold</code> ：<code>unhold = max(unhold1, hold1 + prices[i])</code></p><p>  更新后的 <code>hold</code> 由上一天的 <code>hold1</code> 和上一天的 <code>unhold1 - prices[i]</code> 决定的。</p><p>  我们<strong>将这两个因素带入表达式</strong>中：<code>unhold = max(unhold1, hold1 + prices[i], unhold1 - prices[i] + prices[i])</code>。</p><p>  其实就是等于 <code>unhold = max(unhold1, hold1 + prices[i], unhold1)</code>，对我们的状态更新并没有影响！</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices</span>) </span>&#123;    <span class="hljs-keyword">let</span> n = prices.length;    <span class="hljs-keyword">let</span> hold = -prices[<span class="hljs-number">0</span>];    <span class="hljs-keyword">let</span> unhold = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;        hold = <span class="hljs-built_in">Math</span>.max(hold, unhold - prices[i]);        unhold = <span class="hljs-built_in">Math</span>.max(unhold, hold + prices[i]);    &#125;    <span class="hljs-keyword">return</span> unhold;&#125;;</code></pre><h1 id="123-买卖股票的最佳时机-iii"><a class="markdownIt-Anchor" href="#123-买卖股票的最佳时机-iii"></a> 123. 买卖股票的最佳时机 III</h1><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/</a></p><p><strong>题意简述</strong>：给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素是股票在第 <code>i</code> 天的价格。</p><p>限制<strong>最多只能完成两笔交易</strong>，且手中最多只能同时持有一只股票。</p><p><strong>例1</strong></p><p>输入：<code>prices = [3,3,5,0,0,3,1,4]</code></p><p>输出：<code>6</code></p><p>解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。<br />随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</p><h2 id="解法1动态规划"><a class="markdownIt-Anchor" href="#解法1动态规划"></a> 解法1：动态规划</h2><p>  这题和 <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121.买卖股票的最佳时机</a> 非常相似，区别就是 <code>121.</code> 规定只能买卖一次，而本题最多能买卖<strong>两次</strong>。</p><p>  我们 <code>121.</code> 中的想法是：遍历 <code>prices</code> 数组，在遍历过程中，我们不断更新最低价格，并使用这个最低价格和每天的股票价格 <code>prices[i]</code> 来更新我们的最高利润（<code>max(profit, prices[i] - min)</code>）。</p><p>  而本题可以交易两次，那这样，我们可以沿袭 <code>121.</code> 中的思路，不断记录<strong>第一次交易完后最大的利润 <code>profit1</code></strong>， 视其为我们<strong>第一次交易完后赚的钱</strong>，然后再使用相同的思路计算第二次交易能得到的最大利润。</p><p>  也就是在完成第一笔交易后，我们继续寻找一个最低的价格来让我们买完第二支股票后<strong>手里剩下的钱</strong>最多（<code>left = max(left, profit1 - prices[i])</code>），然后再使用每天的 <code>prices[i]</code> 不断更新我们售出第二只股票能获取的最大利润：<code>profit2 = max(profit2, left + prices[i])</code>。</p><p>  有的情况下，我们只需要<strong>交易一次</strong>即可得到最高利润，不过上面的状态转移其实也包括了这种情况：即我们的 <code>profit1</code> 其实就是最终结果（最高的利润），这种情况下，我们的 <code>left = profit1 - prices[i]</code>，然后我们使用它来计算出<code>profit2</code>： <code>profit2 = max(profit2, profit1 - prices[i] + prices[1])</code>，也就是 <code>profit2 = profit1</code>。因此也会得到正确结果。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices</span>) </span>&#123;    <span class="hljs-keyword">let</span> n = prices.length;    <span class="hljs-keyword">let</span> min = prices[<span class="hljs-number">0</span>], profit1 = <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> left = -<span class="hljs-built_in">Number</span>.MAX_VALUE, profit2 = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;        <span class="hljs-keyword">let</span> p = prices[i];        <span class="hljs-comment">// 不断更新第一次买卖的最低股票价格</span>        min = <span class="hljs-built_in">Math</span>.min(min, p);        <span class="hljs-comment">// 不断更新第一次买卖后获得的最高利润</span>        profit1 = <span class="hljs-built_in">Math</span>.max(profit1, p - min);        <span class="hljs-comment">// 第二次买入股票后我们手中还剩下的钱</span>        left = <span class="hljs-built_in">Math</span>.max(left, profit1 - p);        <span class="hljs-comment">// 第二次卖出股票后我们能获取的最高利润</span>        profit2 = <span class="hljs-built_in">Math</span>.max(profit2, left + p);    &#125;    <span class="hljs-keyword">return</span> profit2;&#125;;</code></pre><h1 id="188-买卖股票的最佳时机-iv"><a class="markdownIt-Anchor" href="#188-买卖股票的最佳时机-iv"></a> 188. 买卖股票的最佳时机 IV</h1><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/</a></p><p><strong>题意简述</strong>：给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素是股票在第 <code>i</code> 天的价格。</p><p>限制<strong>最多只能完成 k 笔交易</strong>，且手中最多只能同时持有一只股票。</p><p><strong>例 2：</strong></p><p>输入：<code>k=2</code>, <code>prices = [3,2,6,5,0,3]</code></p><p>输出：<code>7</code></p><p>解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。<br />随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。</p><h2 id="解法1动态规划-2"><a class="markdownIt-Anchor" href="#解法1动态规划-2"></a> 解法1：动态规划</h2><p>  这题是 <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a> 的拓展，<code>123.</code> 中限制了最多买卖两次，而本题最多买卖次数不定。</p><p>  <code>123.</code> 中使用了<code>两</code>组变量来分别保存第一次交易和第二次交易的<strong>最低开销</strong>和<strong>最高利润</strong>。那么本题我们就使用 <code>k</code> 组变量来保存这两个状态即可。</p><p>  沿袭 <code>123.</code> 中的动态规划思想，我们很容易就能写出答案：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">k, prices</span>) </span>&#123;    <span class="hljs-keyword">if</span> (k === <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">let</span> n = prices.length;    <span class="hljs-comment">// hold 表示买入当前股票需要的最低开销</span>    <span class="hljs-keyword">let</span> hold = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(k).fill(-<span class="hljs-built_in">Number</span>.MAX_VALUE);    <span class="hljs-comment">// unhold 表示未持有股票所能得到的最高利润，这个利润可能是当天卖出股票得到的，也可能是前面的交易得到的最高利润。</span>    <span class="hljs-keyword">let</span> unhold = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(k).fill(<span class="hljs-number">0</span>);    hold[<span class="hljs-number">0</span>] = prices[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;        <span class="hljs-keyword">let</span> p = prices[i];        hold[<span class="hljs-number">0</span>] = <span class="hljs-built_in">Math</span>.min(hold[<span class="hljs-number">0</span>], p);        unhold[<span class="hljs-number">0</span>] = <span class="hljs-built_in">Math</span>.max(unhold[<span class="hljs-number">0</span>], p - hold[<span class="hljs-number">0</span>]);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt; k; j++) &#123;            hold[j] = <span class="hljs-built_in">Math</span>.max(hold[j], unhold[j<span class="hljs-number">-1</span>] - p);            unhold[j] = <span class="hljs-built_in">Math</span>.max(unhold[j], hold[j] + p);        &#125;    &#125;    <span class="hljs-keyword">return</span> unhold[k<span class="hljs-number">-1</span>];&#125;;</code></pre><h1 id="309-最佳买卖股票时机含冷冻期"><a class="markdownIt-Anchor" href="#309-最佳买卖股票时机含冷冻期"></a> 309. 最佳买卖股票时机含冷冻期</h1><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/</a></p><p><strong>题意简述</strong>：给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素是股票在第 <code>i</code> 天的价格。</p><p><strong>约束条件</strong>：</p><ul><li>卖出股票后无法在第二天买入股票（冷冻期为 1 天）</li><li>手中只能同时持有一只股票</li></ul><p>求在任意交易次数后能够获得的最大利润。</p><p><strong>示例:</strong></p><p>输入: <code>[1,2,3,0,2]</code></p><p>输出: <code>3</code></p><p>解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</p><h2 id="解法1动态规划-3"><a class="markdownIt-Anchor" href="#解法1动态规划-3"></a> 解法1：动态规划</h2><p>  前面几题的交易状态只有两种：<strong>持有股票</strong> 和 <strong>未持有股票</strong>，而本题多了一种状态：<strong>处于冷冻期</strong>。</p><p>  因为有了前面几题的经验，我们可以知道，这些状态其实都是由上一次的状态转移而来，因此我们只需要设置三个变量来代表这三个状态即可。</p><p>我们设置</p><ul><li><code>hold</code> 表示<strong>当天交易过后</strong>持<strong>有股票</strong>的状态下能够获得的最大利润</li><li><code>unhold</code> 表示当天交易过后<strong>未持有股票</strong>的状态下能够获得的最大利润</li><li><code>freeze</code> 表示当前交易过后处于<strong>冷冻期</strong>的状态下能够获得的最大利润</li></ul><p>  因此 <code>hold</code> 的状态能够由 <code>hold</code>（仍然保持持有股票的状态）和 <code>unhold</code> （当天新买入股票，从未持有股票转移到持有股票）转移而来，也就是：<code>hold = max(hold, unhold - prices[i])</code></p><p>  <code>unhold</code> 状态能够由 <code>unhold</code>（仍然保持未持有股票状态）和 <code>freeze</code>（刚从冷冻期恢复）转移而来，也就是：<code>unhold = max(unhold, freeze)</code></p><p>  而 <code>freeze</code> 状态只能由 <code>hold</code> 状态转移而来（将持有的股票卖出，进入冷冻期），并不能由 <code>freeze</code> 转移，因为冷冻期只有一天！因此 <code>freeze = hold + prices[i]</code>。</p><p>  状态初始化：<code>hold = -prices[0]</code>，<code>unhold = freeze = 0</code></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices</span>) </span>&#123;    <span class="hljs-keyword">let</span> n = prices.length;    <span class="hljs-keyword">let</span> hold = -prices[<span class="hljs-number">0</span>], unhold = <span class="hljs-number">0</span>, freeze = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;        hold = <span class="hljs-built_in">Math</span>.max(hold, unhold - prices[i]);        unhold = <span class="hljs-built_in">Math</span>.max(unhold, freeze);        freeze = hold + prices[i];    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(freeze, unhold);&#125;;</code></pre><h1 id="714-买卖股票的最佳时机含手续费"><a class="markdownIt-Anchor" href="#714-买卖股票的最佳时机含手续费"></a> 714. 买卖股票的最佳时机含手续费</h1><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/</a></p><p><strong>题意简述</strong>：给定 <code>prices</code> 数组，数组元素 <code>i</code> 表示股票第 <code>i</code> 天的价格。</p><p>可以进行尽可能多次交易，不过手中最多只能持有一只股票，且每次交易（一次买入卖出）都需要支付手续费 <code>fee</code>，求股票交易的最大利润。</p><p><strong>示例 1:</strong></p><p>输入: <code>prices = [1, 3, 2, 8, 4, 9]</code>, <code>fee = 2</code></p><p>输出: <code>8</code></p><p>解释: 能够达到的最大利润:</p><p>在此处买入 prices[0] = 1</p><p>在此处卖出 prices[3] = 8</p><p>在此处买入 prices[4] = 4</p><p>在此处卖出 prices[5] = 9</p><p>总利润: <code>((8 - 1) - 2) + ((9 - 4) - 2) = 8</code>.</p><h2 id="解法1贪心"><a class="markdownIt-Anchor" href="#解法1贪心"></a> 解法1：贪心</h2><p>  我们可以<strong>将手续费算在股票的价格中</strong>，也就是每次买入股票需要花费 <code>prices[i] + fee</code>，这样，我们遍历 <code>prices</code> 数组，且不断更新购买股票的最小花费 <code>cost</code>，在遍历过程中，若将手中最小花费的股票<code>cost</code> 以当天价格 <code>prices[i]</code> 卖出我们能获利的话（<code>prices[i] &gt; cost</code>），那么我们就选择将其卖出 : <code>profit += prices[i] - cost</code> 并<strong>重置</strong>最小花费 <code>cost</code> 为当天的价格：<code>cost = prices[i]</code>，因为我们已经不能再以之前的价格买入股票了。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices, fee</span>) </span>&#123;    <span class="hljs-keyword">let</span> profit = <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> len = prices.length;    <span class="hljs-keyword">let</span> cost = <span class="hljs-built_in">Number</span>.MAX_VALUE;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> p <span class="hljs-keyword">of</span> prices) &#123;        cost = <span class="hljs-built_in">Math</span>.min(p + fee, cost);        <span class="hljs-keyword">if</span> (p &gt; cost) &#123;            profit += p - cost;            cost = p;        &#125;    &#125;    <span class="hljs-keyword">return</span> profit;&#125;;</code></pre><h2 id="解法2动态规划"><a class="markdownIt-Anchor" href="#解法2动态规划"></a> 解法2：动态规划</h2><p>  动态规划方法还是老样子，股票交易有两个状态：<strong>持有股票 hold</strong> 和<strong>未持有股票 unhold</strong>。且我们的股票交易状态只与前一次的交易状态有关。</p><p>  <strong>持有股票状态</strong>能够由未持有股票状态转移而来：<code>hold = max(hold, unhold - prices[i])</code>；</p><p>  <strong>未持有股票状态</strong>能够由持有股票状态转移而来：<code>unhold = max(unhold, hold + prices[i])</code>。</p><p>代码如下：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices, fee</span>) </span>&#123;    <span class="hljs-keyword">let</span> n = prices.length;    <span class="hljs-keyword">let</span> hold = -prices[<span class="hljs-number">0</span>], unhold = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;        hold = <span class="hljs-built_in">Math</span>.max(hold, unhold - prices[i]);        unhold = <span class="hljs-built_in">Math</span>.max(unhold, hold + prices[i] - fee);    &#125;    <span class="hljs-keyword">return</span> unhold;&#125;;</code></pre><h1 id="股票问题小结"><a class="markdownIt-Anchor" href="#股票问题小结"></a> 股票问题小结</h1><p>  连续写了六道股票问题，对这类问题的解题思路清晰了很多。</p><p>  对于股票问题，<strong>动态规划</strong>基本是通用的，即<strong>先确定股票的状态</strong>（持有、未持有、冷冻期），然后再确定这些状态之间的转移关系，一般是：</p><ul><li>持有 <code>hold</code> 状态可由未持有转移而来：<code>hold = max(hold, unhold - prices[i])</code>（未持有状态下的利润减去当天买入股票的开销）</li><li>未持有 <code>unhold</code> 状态可由持有状态转移而来：<code>unhold = max(unhold, hold + prices[i])</code> （持有股票状态下的利润加上当天卖出股票所能获得的利润）</li></ul><p>  边界则是第一天的状态：<code>hold = -prices[0]</code>，<code>unhold = 0</code></p><p>  有些问题可以使用<strong>贪心</strong>思路解决：即我们只进行那些能让我们获得利润的交易（买入价格低于卖出价格）。我们遍历 <code>prices</code> 数组，不断更新我们最低的买入价格 <code>cost</code>，当 <code>prices[i]</code> 大于 <code>cost</code> 时，我们能够获利，此时可以选择将其卖出。</p><p>  有些情况下，题目有限制条件，即我们最多只能完成 <code>k</code> 次交易。</p><ul><li>若最多只能完成一次交易，那么我们可以在更新最低买入价格 <code>cost</code> 的过程中，不断计算我们的最高利润 <code>max(profit, prices[i] - cost)</code>。</li><li>若最多完成交易次数大于一次，那么我们第 <code>i</code> 次交易能够获得的利润需要由第 <code>i-1</code> 次交易能获得的利润转移而来（动态规划），这种情况下，我们视第 <code>i-1</code> 次交易所能获得的利润为我们的本金，我们可以选择是否要买入当前股票：<code>max(不买入，买入) ： max(cost[i], profit[i-1] - prices[i])</code>，并以第 <code>i</code> 次交易的本金来计算是否能够得到更高的利润：<code>max(profit[i], cost[i] + prices[i])</code>。</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>解答</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
      <tag>动态规划</tag>
      
      <tag>股票问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>词法作用域和动态作用域</title>
    <link href="/2021/01/08/JS/%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85/%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <url>/2021/01/08/JS/%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85/%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="作用域"><a class="markdownIt-Anchor" href="#作用域"></a> 作用域</h1><p>  作用域是指程序源代码中定义变量的区域。</p><p>  它规定了如何查找变量，也是就确定当前执行代码对变量的访问权限。</p><p>  JS 采用了词法作用域（lexical scoping），也就是静态作用域。</p><h1 id="静态作用域和动态作用域"><a class="markdownIt-Anchor" href="#静态作用域和动态作用域"></a> 静态作用域和动态作用域</h1><p>  JS 采用的<strong>词法作用域</strong>是<strong>静态作用域</strong>，因此函数的作用域在函数定义的时候就决定了。</p><p>  与静态作用域相对的是<strong>动态作用域</strong>，函数的作用域是在函数调用的时候才决定的。</p><p>例如：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> value = <span class="hljs-number">1</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(value);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> value = <span class="hljs-number">2</span>;    foo();&#125;bar(); <span class="hljs-comment">// ???</span></code></pre><p>  因为 JS 是静态作用域，因此执行过程大致如下：</p><p>  执行 <code>foo</code> 函数，先从 <code>foo</code> 函数内部查找是否有局部变量 <code>value</code> ，若没有，就根据书写位置，查找上面一层的代码，也就是 <code>value</code> 等于 <code>1</code>，因此上面的代码会打印 <code>1</code>。</p><p>  若是动态作用域，当 <code>foo</code> 内部找不到 <code>value</code> 时，会从调用函数的作用域，也就是 <code>bar</code> 内部查找 <code>value</code>，此时就会打印 <code>2</code>。</p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
      <category>作用域和闭包</category>
      
    </categories>
    
    
    <tags>
      
      <tag>词法作用域</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原型和原型链</title>
    <link href="/2021/01/08/JS/%E5%8E%9F%E5%9E%8BPrototype/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <url>/2021/01/08/JS/%E5%8E%9F%E5%9E%8BPrototype/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<p>  首先，在 JS 中可以使用类或构造函数来创建一个实例：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<span class="hljs-comment">// or</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;&#125;Person.prototype.name = <span class="hljs-string">&#x27;Kevin&#x27;</span>;<span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> Person();<span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> Person();<span class="hljs-comment">// p1.name === p2.name = &#x27;Kevin&#x27;;</span></code></pre><h2 id="prototype"><a class="markdownIt-Anchor" href="#prototype"></a> prototype</h2><p>  每个函数/类都有一个 <code>prototype</code> 属性，它指向了一个对象，这个对象就是我们调用这个构造函数/类而创建的实例的原型，即上面代码中 <code>p1</code> 和 <code>p2</code> 的原型。</p><p>  而<strong>原型</strong>可以这样理解：<strong>每一个 JS 对象（null除外）在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型中 “继承” 属性</strong>。</p><p>  用一张图来表示构造函数和实例原型之间的关系：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost@master/img/prototype1.png" alt="构造函数和实例原型的关系图" style="zoom:80%;" /><h2 id="__proto__"><a class="markdownIt-Anchor" href="#__proto__"></a> <code>__proto__</code></h2><p>  每一个 JS 对象（除了 null）都具有 <code>__proto__</code> 这个属性，它指向该对象的原型。</p><p>如：</p><pre><code class="hljs js">p1.__proto__ === Person.prototype;<span class="hljs-keyword">let</span> n = <span class="hljs-number">3</span>;n.__proto__ === <span class="hljs-built_in">Number</span>.prototype;</code></pre><p>  因此关系图更新为：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost@master/img/prototype2.png" alt="实例与实例原型的关系图" style="zoom:80%;" /><p>  除了可以使用 <code>__proto_</code> 属性来获取实例的原型之外，还能使用 <code>Object.getPrototypeOf(p1)</code> （ES5 的方法）来获取对象原型：</p><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.getPrototypeOf(p1) === Person.prototype;</code></pre><h2 id="constructor"><a class="markdownIt-Anchor" href="#constructor"></a> constructor</h2><p>  每个原型都有一个 <code>constructor</code> 属性来指向与其关联的构造函数/类。</p><p>如：</p><pre><code class="hljs js">Person.prototype.constructor === Person;<span class="hljs-built_in">Number</span>.prototype.constructor === <span class="hljs-built_in">Number</span>;</code></pre><p>  因此再次更新关系图：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost@master/img/prototype3.png" alt="实例原型与构造函数的关系图" style="zoom:80%;" /><h2 id="原型的原型"><a class="markdownIt-Anchor" href="#原型的原型"></a> 原型的原型</h2><p>  前面原型理解中有提到，<strong>原型也是一个对象</strong>，因此我们可以使用最原始的方式创建它：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();</code></pre><p>  其实原型对象也就是通过 <code>Object</code> 构造函数生成的，因此原型对象的 <code>__proto__</code> 属性会指向构造函数的 <code>prototype</code> ，也就是：</p><pre><code class="hljs js">p1.__proto__.__proto__ === <span class="hljs-built_in">Object</span>.prototype;<span class="hljs-comment">// 即</span>Person.prototype.__proto__ === <span class="hljs-built_in">Object</span>.prototype;</code></pre><p>  那么 <code>Object.prototype</code> 的原型是什么呢？</p><p>  答案是 <code>null</code>：<code>Object.prototype.__proto__ === null</code></p><p>  代表了原型链的尽头。</p><p>  因此关系图可以更新为：其中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost@master/img/prototype5.png" alt="原型链示意图" style="zoom:80%;" /><h2 id="实例与原型链"><a class="markdownIt-Anchor" href="#实例与原型链"></a> 实例与原型链</h2><p>  当读取实例的属性时，如果找不到，就会查找与其相关的原型中的属性，如果还找不到，就会去找原型的原型，直到最顶层的 <code>null</code> 为止。</p><p>如：</p><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.prototype.name = <span class="hljs-string">&#x27;End&#x27;</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;&#125;Person.prototype.name = <span class="hljs-string">&#x27;Kevin&#x27;</span>;<span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> Person();p.name = <span class="hljs-string">&#x27;Daisy&#x27;</span>;<span class="hljs-comment">// 首先会在当前对象中查找</span><span class="hljs-built_in">console</span>.log(p.name); <span class="hljs-comment">// Daisy</span><span class="hljs-comment">// 若找不到，则去与其关联的原型中查找</span><span class="hljs-keyword">delete</span> p.name;<span class="hljs-built_in">console</span>.log(p.name); <span class="hljs-comment">// Kevin</span><span class="hljs-comment">// 若其原型中也没有，则去原型的原型中查找</span><span class="hljs-keyword">delete</span> Person.prototype.name;<span class="hljs-built_in">console</span>.log(p.name); <span class="hljs-comment">// End</span></code></pre><h2 id="补充"><a class="markdownIt-Anchor" href="#补充"></a> 补充</h2><h3 id="constructor"><a class="markdownIt-Anchor" href="#constructor"></a> constructor</h3><p>  先看个例子：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> Person();person.constructor === Person; <span class="hljs-comment">//true</span></code></pre><p>  根据我们前面的描述，<code>constructor</code> 是 <code>person</code> 对象的原型中的属性，<code>person</code> 中并没有这个属性；但当我们获取 <code>person.constructor</code> 时，会从 <code>person</code> 的原型中读取，而原型中正好有这个属性，因此还是能够正确读取。</p><p>  因此：</p><pre><code class="hljs js">person.constructor === Person.prototype.constructor;</code></pre><h3 id="__proto__"><a class="markdownIt-Anchor" href="#__proto__"></a> <code>__proto__</code></h3><p>  绝大部分浏览器都支持这个非标准的方法来访问原型，然而它并不存在于 <code>Person.prototype</code> 中，<strong>实际上，它是来自于 <code>Object.prototype</code></strong>，与其说是一个属性，不如说是一个 <code>getter/setter</code>，当使用 <code>obj.__proto__</code> 时，可以理解为返回了 <code>Object.getPrototypeOf(obj)</code>。</p><h3 id="属性-继承"><a class="markdownIt-Anchor" href="#属性-继承"></a> 属性 “继承”</h3><p>  前面有说到，每一个对象都会从原型中 “继承” 属性。实际上，继承是一个比较迷惑的说法，在 《你不知道的 JS》 中有这样一段话：</p><blockquote><p>继承意味着复制操作，然而 JS 默认并不会复制对象中的属性，相反，JS 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数。</p><p>所以与其叫继承，<strong>委托</strong>的说法反而更准确些。</p></blockquote><hr /><p>REF：</p><p><a href="https://github.com/mqyqingfeng/Blog/issues/2">https://github.com/mqyqingfeng/Blog/issues/2</a></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
      <category>原型和原型链</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.JS内存机制</title>
    <link href="/2021/01/05/JS/JS%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88/3-JS%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/01/05/JS/JS%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88/3-JS%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>  JS 内存空间分为 <strong>栈</strong>、<strong>堆</strong>、<strong>池（一般归类为栈中）</strong>。其中<strong>栈</strong>存放变量，<strong>堆</strong>存放复杂对象，<strong>池存放常量</strong>，因此也叫常量池。</p><h1 id="变量的存放"><a class="markdownIt-Anchor" href="#变量的存放"></a> 变量的存放</h1><p>  JS 使用了传统的<strong>堆栈</strong>来保存变量：</p><ul><li><strong>基本类型</strong>：保存在<strong>栈</strong>内存中，这些类型在内存中有<strong>固定的大小</strong>，通过按值来访问。基本数据类型一共有 6 种：<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>、<code>Symbol</code>（ES6）</li><li><strong>引用类型</strong>：保存在<strong>堆</strong>内存中，因为其<strong>大小不固定</strong>，因此不能将它们保存在栈中，但其保存的位置的地址大小是固定，因此其<strong>访问地址保存在栈中</strong>。当查询引用类型时，先从栈中读取内存地址，然后再通过这个内存地址找到堆中的值。这种访问方式我们称为<strong>按引用访问</strong>。</li></ul><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost@master/img/2019-07-24-060214.png" alt="img" style="zoom:80%;" /><p>  在计算机中，栈的运算效率比堆高，而 <code>Object</code> 是一种复杂的结构且可以拓展：数组可扩充、对象属性可添加，可增删改。为了不影响栈的效率，因此将它放到堆中并以引用的方式查找到堆中的实际对象再进行操作。</p><p>  所以查找引用类型值的时候回先去栈中查找再去堆中查找。</p><p><mark>鼠标选中查看答案</mark></p><p><strong>问题1</strong></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;前端开发&#x27;</span> &#125;<span class="hljs-keyword">var</span> b = a;b.name = <span class="hljs-string">&#x27;进阶&#x27;</span>;<span class="hljs-comment">// 这时a.name的值是多少</span></code></pre><p>  答： <code>a.name</code> 的值是：<font color="white"> 进阶 </font>。</p><p>  问题中 <code>a</code> 是引用类型，它在栈中保存了一个对象的地址，<code>b</code> 对 <code>a</code> 进行复制的时候，复制的就是这个对象的地址，所以它们指向的对象是同一个对象，因此 <code>b</code> 的修改也会反映到 <code>a</code> 中。</p><p><strong>问题2</strong></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;前端开发&#x27;</span> &#125;<span class="hljs-keyword">var</span> b = a;a = <span class="hljs-literal">null</span>;<span class="hljs-comment">// 这时b的值是多少</span></code></pre><p>  答：<code>b</code> 的值是：<font color="white"> {name: ‘前端开发’} </font> 。</p><p>  同样的，<code>b</code> 对 <code>a</code> 的复制只是复制了指向堆中的对象的内存地址。然后 <code>a</code> 被修改为 <code>null</code>，也就是把 <code>a</code> 存储在栈中的内存地址变成了基本类型 <code>null</code>，并不影响 <code>b</code> 和堆内存中的对象，因此 <code>b</code> 还是该对象。</p><p><strong>问题3</strong></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = &#123;<span class="hljs-attr">n</span>: <span class="hljs-number">1</span>&#125;;<span class="hljs-keyword">var</span> b = a;a.x = a = &#123;<span class="hljs-attr">n</span>: <span class="hljs-number">2</span>&#125;;a.x <span class="hljs-comment">// 这时 a.x 的值是多少</span>b.x <span class="hljs-comment">// 这时 b.x 的值是多少</span></code></pre><p>  答：<code>a.x =</code> <font color="white">undefined</font>，<code>b.x =</code> <font color="white">{n : 2}</font> （鼠标选中空白处查看答案）</p><p>  这道题的关键在于：</p><ol><li>运算符的优先级：<code>.</code> 运算符的优先级高于 <code>=</code>，因此先执行 <code>a.x</code>，堆中内存的 <code>&#123;n: 1&#125;</code> 就变成了 <code>&#123;n: 1，x: undefined&#125;</code>，<code>b</code> 和 <code>a</code> 的指向是相同的，因此 <code>b.x</code> 也发生了变化。</li><li>运算符的结合性：<strong>赋值操作</strong>的结合性是<strong>从右到左</strong>的，因此会先执行 <code>a = &#123;n: 2&#125;</code>，<code>a</code> 的引用就被改变了，但是在这一步中 <code>a.x</code> 还是第一步中的 <code>&#123;n: 1, x: undefined&#125;</code> 对象，也就相当于 <code>b.x</code>，因此就是 <code>b.x = &#123;n: 2&#125;</code>。</li></ol><p>  <strong>但是</strong>，<strong>闭包</strong>中的变量并不保存在栈内存中，而是<strong>保存在堆中</strong>，这也就解释了为什么函数使用完后闭包还能引用到函数内的变量。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">B</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(a)    &#125;    <span class="hljs-keyword">return</span> B&#125;</code></pre><p>  上面代码中，函数 <code>B</code> 就被称为闭包。</p><p>  函数 A 弹出调用栈后，函数 A 中的变量是存储在堆上的，因此函数 B 依旧能够引用到函数 A 中你的变量。JS 引擎可以通过逃逸分析辨别出哪些变量需要存储在堆上，哪些变量需要存储在栈中。</p><p><strong>问题4</strong> ：从内存来看， <code>null</code> 和 <code>undefined</code> 的区别是什么？</p><p>  答：给一个<strong>全局变量</strong>赋值为 <code>null</code>，相当于将这个变量的指针对象及值清空；如果是给<strong>对象的属性</strong>或<strong>局部变量</strong>赋值为 <code>null</code>，相当于给这个属性分配了一块空的内存，然后值为 <code>null</code>，JS 会回收全局变量为 <code>null</code> 的对象。</p><p>  给一个全局变量赋值为 <code>undefined</code> ，相当于将这个对象的值清空，但是这个对象依然存在；如果是给对象的属性赋值为 <code>undefined</code>，说明这个值为空值。</p><h1 id="内存回收"><a class="markdownIt-Anchor" href="#内存回收"></a> 内存回收</h1><p>  JS 有自动垃圾回收机制，垃圾收集器每隔一段时间就执行一次，找出那些不再继续使用的值，然后释放其占用的内存。</p><ul><li>局部变量和全局变量的回收<ul><li><strong>局部变量</strong>：局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收</li><li><strong>全局变量</strong>：全局变量什么时候需要自动释放内存空间很难判断，因此在开发中尽量避免使用全局变量。</li></ul></li><li>以 V8 为例，V8 中所有的 JS 对象都是通过<strong>堆</strong>来分配内存的：<ul><li><strong>初始分配</strong>：当变量声明并赋值时，V8 就会在堆中给这个遍历分配内存。</li><li><strong>继续申请</strong>：当已申请的内存不足以存储这个变量时，V8 就会继续申请内存，直到堆的大小达到了 V8 内存上限为止。</li></ul></li><li>V8 对堆内存中的对象进行<strong>分代</strong>管理<ul><li><strong>新生代</strong>：存活周期较短的 JS 对象，如临时变量、字符串等。</li><li><strong>老生代</strong>：经过多次垃圾回收仍存活、存活周期较长的对象，如主控制器、服务器对象等。</li></ul></li></ul><h1 id="垃圾回收算法"><a class="markdownIt-Anchor" href="#垃圾回收算法"></a> 垃圾回收算法</h1><p>  常用的垃圾回收算法有两种：</p><ol><li><strong>引用计数</strong>（现代浏览器已不再使用）</li><li><strong>标记清除</strong>（常用）</li></ol><h2 id="引用计数"><a class="markdownIt-Anchor" href="#引用计数"></a> 引用计数</h2><p>  引用计数的内存使用判断标准很简单，就是看一个对象是否有指向它的引用，若没有其他对象指向它，说明这个对象不会再被使用到了。</p><pre><code class="hljs js"><span class="hljs-comment">// 创建一个对象person，他有两个指向属性age和name的引用</span><span class="hljs-keyword">var</span> person = &#123;    age: <span class="hljs-number">12</span>,    name: <span class="hljs-string">&#x27;aaaa&#x27;</span>&#125;;person.name = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 虽然name设置为null，但因为person对象还有指向name的引用，因此name不会回收</span><span class="hljs-keyword">var</span> p = person; person = <span class="hljs-number">1</span>;    <span class="hljs-comment">//原来的person对象被赋值为1，但因为有新引用p指向原person对象，因此它不会被回收</span>p = <span class="hljs-literal">null</span>;   <span class="hljs-comment">//原person对象已经没有引用，很快会被回收</span></code></pre><p>  引用计数有一个致命的问题，那就是<strong>循环引用</strong>。</p><p>  如果两个对象相互引用，尽管他们已不再使用，但垃圾回收器不会进行回收，最终可能会导致<strong>内存泄露</strong>。如：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cycle</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">var</span> o1 = &#123;&#125;;    <span class="hljs-keyword">var</span> o2 = &#123;&#125;;    o1.a = o2;    o2.a = o1;        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;cycle reference&#x27;</span>;&#125;cycle();</code></pre><p>  上面的代码中，<code>cycle</code> 函数执行完后，对象 <code>o1</code> 和 <code>o2</code> 实际上已经不再需要了，但是根据引用计数规则，它们之间的相互引用仍然存在，因此这部分内存不会被回收。</p><h2 id="标记清除"><a class="markdownIt-Anchor" href="#标记清除"></a> 标记清除</h2><p>  **标记清除（Mark-and-sweep）**算法将 “不再使用的对象” 定义为 “<strong>无法到达的对象</strong>”。即从根部（JS中是全局对象）出发定时扫描内存中的对象，<strong>凡是能从根部到达的对象都保留</strong>，无法从根部到达的对象被标记为不再使用，稍后会进行回收。</p><p>  标记清除算法由以下几步组成：</p><ol><li>垃圾回收器创建一个 <code>roots</code> 列表。<code>roots</code> 通常是代码中全局变量的引用。JS 中， <code>window</code> 对象是一个 <code>root</code>，因为 <code>window</code> 对象总是存在，因此垃圾回收器可以检查它和它的所有子对象是否存在（即不是垃圾）；</li><li>所有的 <code>roots</code> 被检查和标记为激活（不是垃圾）。所有的子对象也被递归地检查。从 <code>root</code> 开始的所有对象如果是可达的，它就不会被当做垃圾。</li><li>所有未被标记的内存会被当做垃圾，收集器会释放它们的内存，归还给操作系统。</li></ol><h1 id="内存泄漏"><a class="markdownIt-Anchor" href="#内存泄漏"></a> 内存泄漏</h1><p><a href="https://ruanyifeng.com/blog/2017/04/memory-leak.html">阮一峰内存泄漏教程</a></p><p>  对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。</p><p>  <strong>对于不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）</strong></p><h2 id="内存泄漏的识别方法"><a class="markdownIt-Anchor" href="#内存泄漏的识别方法"></a> 内存泄漏的识别方法</h2><p>  <a href="https://www.toptal.com/nodejs/debugging-memory-leaks-node-js-applications">经验法则</a>是，如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏。这就要求实时查看内存占用。</p><h3 id="1-浏览器方法"><a class="markdownIt-Anchor" href="#1-浏览器方法"></a> 1 浏览器方法</h3><ol><li>打开开发者工具，选择 Memory</li><li>在右侧的 Select profiling type 字段里勾选 timeline</li><li>点击左上角的录制按钮</li><li>在页面上进行各种操作，模拟正常的使用情况</li><li>一段时间后，点击左上角的 stop 按钮，面板上就会显示这段时间的内存占用情况</li></ol><h3 id="2-命令行方法"><a class="markdownIt-Anchor" href="#2-命令行方法"></a> 2 命令行方法</h3><p>  使用 Node 提供的 <code>process.memoryUsage</code> 方法。</p><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(process.memoryUsage());<span class="hljs-comment">// 输出</span>&#123;   rss: <span class="hljs-number">27709440</span>,<span class="hljs-comment">// resident set size，所有内存占用，包括指令区和堆栈</span>  heapTotal: <span class="hljs-number">5685248</span>,   <span class="hljs-comment">// &quot;堆&quot;占用的内存，包括用到的和没用到的</span>  heapUsed: <span class="hljs-number">3449392</span>,<span class="hljs-comment">// 用到的堆的部分</span>  external: <span class="hljs-number">8772</span> <span class="hljs-comment">// V8 引擎内部的 C++ 对象占用的内存</span>&#125;</code></pre><p>  判断内存泄漏，以<code>heapUsed</code>字段为准。</p><p>  ES6 新增的两种数据结构 <a href="https://yleave.top/2020/12/09/JS/Set%E3%80%81Map%E3%80%81%E5%92%8CWeakSet%E3%80%81WeakMap/#weakset">WeakSet 和 WeakMap</a> ，使用了一种弱引用机制，可以有效解决常见的 DOM 节点泄漏问题。</p><h1 id="四种常见的-js-内存泄漏"><a class="markdownIt-Anchor" href="#四种常见的-js-内存泄漏"></a> 四种常见的 JS 内存泄漏</h1><h2 id="1意外的全局变量"><a class="markdownIt-Anchor" href="#1意外的全局变量"></a> 1.意外的全局变量</h2><p>  未定义的变量会在全局对象下创建一个新变量，如：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">arg</span>) </span>&#123;    bar = <span class="hljs-string">&quot;this is a hidden global variable&quot;</span>; <span class="hljs-comment">// window.bar = &quot;...&quot;</span>&#125;</code></pre><p>  函数 <code>foo</code> 内未使用 <code>var</code> 等关键字声明变量，JS 会将其挂载到全局对象上，意外的创建一个全局变量。</p><p>  另一个意外的全局变量可能由 <code>this</code> 创建：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">this</span>.variable = <span class="hljs-string">&quot;potentail accidental global&quot;</span>;&#125;<span class="hljs-comment">// 此时 foo 中的 this 指向了全局对象，因此 this.variable 变成了全局变量</span>foo();</code></pre><p>  <strong>解决方法</strong>：在 JS 文件头部加上 <code>use strict</code>，使用严格模式避免意外的全局变量，此时上例中的 <code>this</code> 指向 <code>undefined</code>。</p><p>  若需要使用全局变量存储大量数据时，确保用完后将它设置为 <code>null</code> 或重新定义以保证能够被回收。</p><h2 id="2-被遗忘的计时器或回调函数"><a class="markdownIt-Anchor" href="#2-被遗忘的计时器或回调函数"></a> 2. 被遗忘的计时器或回调函数</h2><p>计时器 <code>setInterval</code>：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> someResource = getData();<span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> node = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;Node&#x27;</span>);    <span class="hljs-keyword">if</span>(node) &#123;        <span class="hljs-comment">// 处理 node 和 someResource</span>        node.innerHTML = <span class="hljs-built_in">JSON</span>.stringify(someResource));    &#125;&#125;, <span class="hljs-number">1000</span>);</code></pre><p>  在上面的例子中，在节点 <code>node</code> 不再需要时，定时器仍然指向这些数据，因此即使 <code>node</code> 节点被移除， <code>interval</code> 仍然存活且垃圾回收器没办法回收，它的依赖也没办法被回收，除非终止定时器。</p><h2 id="3-脱离-dom-的引用"><a class="markdownIt-Anchor" href="#3-脱离-dom-的引用"></a> 3. 脱离 DOM 的引用</h2><p>  如果把 DOM 保存到字典或数组中，这样 DOM 元素会存在两个引用：一个在 DOM 树中，另一个在字典中，那么当不需要的时候需要把这两个引用都清除：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> elements = &#123;    button: <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;button&#x27;</span>),    image: <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;image&#x27;</span>),    text: <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;text&#x27;</span>)&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doStuff</span>(<span class="hljs-params"></span>) </span>&#123;    image.src = <span class="hljs-string">&#x27;http://some.url/image&#x27;</span>;    button.click();    <span class="hljs-built_in">console</span>.log(text.innerHTML);    <span class="hljs-comment">// 更多逻辑</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeButton</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-comment">// 按钮是 body 的后代元素</span>    <span class="hljs-built_in">document</span>.body.removeChild(<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;button&#x27;</span>));    <span class="hljs-comment">// 此时，仍旧存在一个全局的 #button 的引用</span>    <span class="hljs-comment">// elements 字典。button 元素仍旧在内存中，不能被 GC 回收。</span>&#125;</code></pre><p>  此外，<strong>如果代码中保存了表格中某一个 <code>&lt;td&gt;</code> 的引用</strong>，将来决定删除表格后，直觉会认为 GC 会回收除了已保存的 <code>&lt;td&gt;</code> 之外的其他节点。</p><p>  但实际情况并非如此：<strong>这个 <code>&lt;td&gt;</code> 是表格的子节点，子元素与父元素是引用关系</strong>。由于代码中保存了子元素 <code>&lt;td&gt;</code> 的引用，导致整个表格仍保存在内存中。</p><h2 id="4-闭包"><a class="markdownIt-Anchor" href="#4-闭包"></a> 4. 闭包</h2><p>  闭包的关键是匿名函数可以访问父级作用域的变量。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> theThing = <span class="hljs-literal">null</span>;<span class="hljs-keyword">var</span> replaceThing = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> originalThing = theThing;        <span class="hljs-keyword">var</span> unused = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">if</span> (originalThing)            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;hi&quot;</span>);    &#125;;    theThing = &#123;        longStr: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">1000000</span>).join(<span class="hljs-string">&#x27;*&#x27;</span>),        someMethod: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-built_in">console</span>.log(someMessage);        &#125;    &#125;;&#125;;<span class="hljs-built_in">setInterval</span>(replaceThing, <span class="hljs-number">1000</span>);</code></pre><p>  在上面的代码中，每次调用 <code>replaceThing</code>，<code>theThing</code> 得到一个包含一个大数组和一个新闭包（<code>someMethod</code>）的新对象。同时，变量 <code>unused</code> 是一个引用 <code>originalThing</code> 的闭包。</p><p>  <code>someMethod</code> 可以通过 <code>theThing</code> 使用，<code>someMethod</code> 与 <code>unused</code> 分享闭包的作用域，尽管 <code>unused</code> 从未使用，它引用的 <code>originalThing</code> 迫使它保留在内存中（防止被回收）。</p><p>  <strong>解决方法</strong>：在 <code>replaceThing</code> 函数的最后面添加 <code>originalThing = null</code>。</p><hr /><p>REF:</p><p><a href="https://muyiy.cn/blog/1/1.3.html">https://muyiy.cn/blog/1/1.3.html</a></p><p><a href="https://muyiy.cn/blog/1/1.4.html">https://muyiy.cn/blog/1/1.4.html</a></p><p><a href="https://muyiy.cn/blog/1/1.5.html">https://muyiy.cn/blog/1/1.5.html</a></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
      <category>JS调用堆栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS内存回收</tag>
      
      <tag>内存泄漏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 399.除法求值</title>
    <link href="/2021/01/05/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/399-%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/"/>
    <url>/2021/01/05/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/399-%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/evaluate-division/">https://leetcode-cn.com/problems/evaluate-division/</a></p><hr /><p>  给出方程式 <code>A / B = k</code>, 其中 <code>A</code> 和 <code>B</code> 均为用字符串表示的变量， <code>k</code> 是一个浮点型数字。根据已知方程式求解问题，并返回计算结果。如果结果不存在，则返回 <code>-1.0</code>。</p><p>  输入总是有效的。你可以假设除法运算中不会出现除数为 <code>0</code> 的情况，且不存在任何矛盾的结果。</p><p><strong>示例 1：</strong></p><p>输入：<code>equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;]], values = [2.0,3.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;e&quot;],[&quot;a&quot;,&quot;a&quot;],[&quot;x&quot;,&quot;x&quot;]]</code></p><p>输出：<code>[6.00000,0.50000,-1.00000,1.00000,-1.00000]</code></p><p><strong>解释：</strong></p><p>给定：<code>a / b = 2.0, b / c = 3.0</code></p><p>问题：<code>a / c = ?</code>, <code>b / a = ?</code>, <code>a / e = ?</code>, <code>a / a = ?</code>, <code>x / x = ?</code></p><p>返回：<code>[6.0, 0.5, -1.0, 1.0, -1.0 ]</code></p><p><strong>示例 2：</strong></p><p>输入：<code>equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;],[&quot;bc&quot;,&quot;cd&quot;]], values = [1.5,2.5,5.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;c&quot;,&quot;b&quot;],[&quot;bc&quot;,&quot;cd&quot;],[&quot;cd&quot;,&quot;bc&quot;]]</code></p><p>输出：<code>[3.75000,0.40000,5.00000,0.20000]</code></p><hr /><p>  开始，刚看完题目后，直觉就是需要找到每个变量之间的关系，然后计算出各个变量的值，最后根据 <code>queries</code> 来求值（暴力想法）。</p><p>  比如 <strong>示例1</strong> 中，<code>a / b = 2.0</code>，<code>b / c = 3.0</code>，这样我们可以利用这个关系找到同时满足这两个等式的解。首先我们处理 <code>a / b = 2.0</code>，由于 <code>a</code> 和 <code>b</code> 都是第一次遇到，因此为了方便计算，设 <code>b = 1.0</code>，那么 <code>a = 2.0</code>，然后再处理 <code>b / c = 3.0</code>，此时 <code>b</code> 我们已经设置了值 <code>1.0</code>，因此 <code>c = 1.0 / 3.0</code>。</p><p>  然后我们就能愉快的计算结果了。</p><p>  <strong>但是</strong>，这种处理方法只能计算那些比较简单的 <code>case</code>，有些复杂的情况，如 <code>[[&quot;a&quot;,&quot;b&quot;],[&quot;e&quot;,&quot;f&quot;],[&quot;b&quot;,&quot;e&quot;]]</code>，这种情况下，我们的 <code>b</code> 和 <code>e</code> 即要满足等式 <code>a / b = x</code> 也需要满足 <code>b / e = y</code>，这样就得综合这两个等式来求得结果，处理起来太麻烦了。因此 <code>pass</code>！</p><h1 id="解法1邻接表-dfs"><a class="markdownIt-Anchor" href="#解法1邻接表-dfs"></a> 解法1：邻接表 + dfs</h1><p>  其实我们再仔细观察，可以发现：<strong>对于 <code>queries</code> 中能得到结果的等式，它的除号两边的变量都能直接找到关联或能通过一些中间变量来找到关联</strong>，这样我们可以使用一种数据结构来保存这种关联，那就是 <strong>图</strong>！</p><p>  对 <strong>示例1</strong>，我们创建一张图来观察，我们使用边权来表示这两个数的商，如 <code>a / b = 2.0</code> ，<code>b / a = 1 / 2.0</code></p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost@master/img/image-20210105165911118.png" alt="image-20210105165911118" style="zoom:80%;" /><p>  这样，我们要求图上任意两点的商，我们只需要乘上这两点之间的路径权值即可，如 <code>a / c = a-&gt;b-&gt;c = 2.0 * 3.0</code></p><p>  图常用的存储结构有两种，邻接矩阵和邻接表，这里我选择使用<strong>邻接表</strong>。</p><p>  不过好久没写图算法了，邻接表的定义方式有些模糊，依靠对邻接表的回忆使用了一个 <code>map + array</code> 来完成邻接表的创建。</p><p>  即使用 <code>map</code> 作为顶点表存储所有顶点，对一个顶点，使用一个数组 <code>array</code> 来存储与其相连的所有边。</p><p>  因此对于 <strong>示例1</strong>，存储的邻接表就是这样的：</p><pre><code class="hljs js"><span class="hljs-built_in">Map</span>(<span class="hljs-number">3</span>) &#123;  <span class="hljs-string">&#x27;a&#x27;</span> =&gt; [ [ <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2</span> ] ],  <span class="hljs-string">&#x27;b&#x27;</span> =&gt; [ [ <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">0.5</span> ], [ <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">3</span> ] ],  <span class="hljs-string">&#x27;c&#x27;</span> =&gt; [ [ <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">0.3333333333333333</span> ] ]&#125;</code></pre><p>  创建完邻接表后，遍历 <code>queries</code> 数组，若这两个变量均为邻接表中的顶点，我们就对其使用深度优先遍历计算它们的路径积，否则填入 <code>-1.0</code>：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> calcEquation = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">equations, values, queries</span>) </span>&#123;    <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(), res = [];    <span class="hljs-keyword">let</span> visit = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();  <span class="hljs-comment">// visit 数组标记在搜索过程中是否访问过</span>    <span class="hljs-keyword">const</span> dfs = <span class="hljs-function">(<span class="hljs-params">src, dst</span>) =&gt;</span> &#123;        <span class="hljs-comment">// 若可达，且找到了目的节点，返回 1.0 表示成功到达</span>        <span class="hljs-keyword">if</span> (src === dst) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>;        &#125;        <span class="hljs-keyword">let</span> adjs = map.get(src);        <span class="hljs-comment">// 遍历 src 的所有边，若未访问过，则对其调用 dfs 获取路径积</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; adjs.length; ++i) &#123;            <span class="hljs-keyword">let</span> next = adjs[i];            <span class="hljs-keyword">if</span> (!visit.get(next[<span class="hljs-number">0</span>])) &#123;                visit.set(next[<span class="hljs-number">0</span>], <span class="hljs-literal">true</span>);                <span class="hljs-keyword">let</span> ret = dfs(next[<span class="hljs-number">0</span>], dst);                visit.set(next[<span class="hljs-number">0</span>], <span class="hljs-literal">false</span>);                <span class="hljs-comment">// 若可达 dst，则返回当前边权与后续的边权积 ret 的乘积</span>                <span class="hljs-keyword">if</span> (ret !== <span class="hljs-number">-1.0</span>) &#123;                    <span class="hljs-keyword">return</span> next[<span class="hljs-number">1</span>] * ret;                &#125;            &#125;        &#125;        <span class="hljs-comment">// 否则，不可达，返回 -1.0</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1.0</span>;    &#125;;    <span class="hljs-comment">// 创建邻接表</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; equations.length; ++i) &#123;        <span class="hljs-keyword">let</span> e = equations[i], v = values[i];        <span class="hljs-keyword">if</span> (!map.has(e[<span class="hljs-number">0</span>])) &#123;            map.set(e[<span class="hljs-number">0</span>], []);            visit.set(e[<span class="hljs-number">0</span>], <span class="hljs-literal">false</span>);        &#125;        <span class="hljs-keyword">if</span> (!map.has(e[<span class="hljs-number">1</span>])) &#123;            map.set(e[<span class="hljs-number">1</span>], []);            visit.set(e[<span class="hljs-number">1</span>], <span class="hljs-literal">false</span>);        &#125;        <span class="hljs-keyword">let</span> adj1 = map.get(e[<span class="hljs-number">0</span>]);        <span class="hljs-keyword">let</span> adj2 = map.get(e[<span class="hljs-number">1</span>]);        adj1.push([e[<span class="hljs-number">1</span>], v]);        adj2.push([e[<span class="hljs-number">0</span>], <span class="hljs-number">1</span> / v]);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> q <span class="hljs-keyword">of</span> queries) &#123;        <span class="hljs-keyword">let</span> n0 = q[<span class="hljs-number">0</span>], n1 = q[<span class="hljs-number">1</span>];        <span class="hljs-keyword">if</span> (map.has(n0) &amp;&amp; map.has(n1)) &#123;            visit.set(n0, <span class="hljs-literal">true</span>);            res.push(dfs(n0, n1));            visit.set(n0, <span class="hljs-literal">false</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            res.push(<span class="hljs-number">-1.0</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> res;    &#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>解答</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 279. 完全平方数</title>
    <link href="/2021/01/04/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"/>
    <url>/2021/01/04/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/perfect-squares/">https://leetcode-cn.com/problems/perfect-squares/</a></p><hr /><p>  给定正整数 <code>n</code>，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 <code>n</code>。你需要让组成和的完全平方数的个数最少。</p><p><strong>示例 1:</strong></p><p>输入: n = 12</p><p>输出: 3</p><p>解释: 12 = 4 + 4 + 4.</p><p><strong>示例 2:</strong></p><p>输入: n = 13</p><p>输出: 2</p><p>解释: 13 = 4 + 9.</p><h1 id="解法1递归-记忆数组"><a class="markdownIt-Anchor" href="#解法1递归-记忆数组"></a> 解法1：递归 + 记忆数组</h1><p>  对于一个正整数数 <code>n</code>，我们需要找出它的<strong>最少</strong>完全平方数的组合个数。</p><p>  首先考虑 <code>n &lt;= 3</code> 的情况，这种情况下，最小的完全平方数就只有 <code>1</code>，因此 <code>n</code> 的完全平方组合个数就是 <code>n</code>。</p><p>  然后来看 <code>n &gt;= 4</code> 的情况，能够组成这个数的<strong>最大完全平方数</strong>很容易想到，就是 <code>n</code> 的平方根取整后的值，即： <code>s = Math.floor(Math.sqrt(n))</code> ，假设这个值是 <code>n</code> 的组成数的其中一个，那剩下我们再对 <code>n - s</code> 做同样考虑即可。</p><p>  穷举所有情况， <code>[2, s] (s 为 n 的平方根取整后的值)</code>，直到当前的 <code>n</code> 小于等于 <code>3</code> 时，返回 <code>n</code>。</p><p>  使用图来表示就是：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost@master/img/image-20210104185104232.png" alt="image-20210104185104232" style="zoom: 80%;" /><p>  不过对于一些比较大的数字，我们在计算过程其实是会有很多<strong>重复计算</strong>的（因为我们使用了穷举），也就是假设一个数字 <code>n</code>，它的根号取整值是 <code>s</code>，我们最开始枚举 <code>s * s</code> 是 <code>n</code> 的组合数之一，然后计算包含 <code>s^2</code> 的组合数个数时，我们遇到了数字 <code>x1,x2,x3</code> 之后计算得到了组合数个数，我们再回到开头，继续枚举 <code>(s-1) * (s-1)</code> 作为 <code>n</code> 的组合数之一，在这个计算过程中，我们遇到了数字 <code>y1,y2,x2,x3</code> 之后得到了结果。那么在这个过程中，我们的 <code>x2,x3</code> 就是重复计算的数。</p><p>  因此我们完全可以使用一个<strong>记忆数组</strong> <code>memeo</code> 来根据当前的数字 <code>n</code> 记录 <code>n</code> 能够得到的最少的组合数，这样，当我们第二次遇到  <code>x2</code> 的时候，就能够凭借记忆数组直接返回 <code>memo[x2]</code>，减少了我们的计算。</p><p>JS 代码：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> numSquares = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>&#123;    <span class="hljs-keyword">let</span> memo = [];    <span class="hljs-keyword">const</span> getCount = <span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">3</span>) &#123;            <span class="hljs-keyword">return</span> num;        &#125;        <span class="hljs-comment">// 若已计算过，直接返回</span>        <span class="hljs-keyword">if</span> (memo[num]) &#123;            <span class="hljs-keyword">return</span> memo[num];        &#125;        <span class="hljs-keyword">let</span> sqrt = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.sqrt(num));        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = sqrt; i &gt;= <span class="hljs-number">2</span>; i--) &#123;            <span class="hljs-keyword">let</span> c = getCount(num - i * i);            <span class="hljs-comment">// memo 记录 num 的最少的组合数个数</span>            memo[num] = <span class="hljs-built_in">Math</span>.min(memo[num] || <span class="hljs-built_in">Number</span>.MAX_VALUE, c + <span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">return</span> memo[num];    &#125;;    <span class="hljs-keyword">return</span> getCount(n);&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>解答</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>记忆数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.JS执行上下文和变量对象</title>
    <link href="/2021/01/01/JS/JS%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88/2-JS%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/"/>
    <url>/2021/01/01/JS/JS%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88/2-JS%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>  JS 是单线程语言，因此执行顺序是<strong>顺序执行</strong>，不过 JS 引擎在执行 JS 代码的时候并不是逐行执行，而是一段一段地分析执行，先是编译阶段，然后才是执行阶段。</p><p>  具体的体现可看例子：</p><p><strong>例一  变量提升</strong></p><p>  我们在未定义 <code>foo</code> 之前就使用了它，结果不会报错，而是会为 <code>undefined</code>，随后， <code>foo</code> 会像我们定义的那样先是输出 <code>foo1</code> ，后输出 <code>foo2</code>。</p><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(foo);   <span class="hljs-comment">// undefined</span><span class="hljs-keyword">var</span> foo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;foo1&#x27;</span>);&#125;foo();  <span class="hljs-comment">// foo1</span><span class="hljs-keyword">var</span> foo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;foo2&#x27;</span>);&#125;foo();  <span class="hljs-comment">// foo2</span></code></pre><p><strong>例二  函数提升</strong></p><p>  在定义之前就调用 <code>foo</code> ，不会发生错误，且后定义的 <code>foo</code> 会覆盖先定义的同名函数。</p><pre><code class="hljs js">foo();  <span class="hljs-comment">// foo2</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;foo1&#x27;</span>);&#125;foo();  <span class="hljs-comment">// foo2</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;foo2&#x27;</span>);&#125;foo();  <span class="hljs-comment">// foo2</span></code></pre><p><strong>例三  声明优先级：函数 &gt; 变量</strong></p><p>  首先，函数提升的优先级会高于变量提升，因此开始输出 <code>foo2</code>，然后 <code>foo</code> 被重新定义，接下来都输出 <code>foo1</code>。</p><pre><code class="hljs js">foo();  <span class="hljs-comment">// foo2</span><span class="hljs-keyword">var</span> foo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;foo1&#x27;</span>);&#125;foo();  <span class="hljs-comment">// foo1</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;foo2&#x27;</span>);&#125;foo();  <span class="hljs-comment">// foo1</span></code></pre><h1 id="执行上下文栈"><a class="markdownIt-Anchor" href="#执行上下文栈"></a> 执行上下文栈</h1><p>  JS 使用了执行上下文栈（Execution context stack，ESC）来管理执行上下文。</p><p>  这个在 <a href="https://yleave.top/2020/12/29/JS/JS%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88/1.JS-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88/">1-JS执行上下文和执行栈</a> 中就有提到</p><p>  关于执行上下文栈，有以下例子：</p><p><strong>代码1</strong></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&#x27;global scope&#x27;</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkScope</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> scope = <span class="hljs-string">&#x27;local scope&#x27;</span>;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">return</span> scope;    &#125;    <span class="hljs-keyword">return</span> f();&#125;<span class="hljs-built_in">console</span>.log(checkScope());</code></pre><p><strong>代码2</strong></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&#x27;global scope&#x27;</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkScope</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> scope = <span class="hljs-string">&#x27;local scope&#x27;</span>;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">return</span> scope;    &#125;    <span class="hljs-keyword">return</span> f();&#125;<span class="hljs-built_in">console</span>.log(checkScope()());</code></pre><p>  这两段代码的输出都为  <font color="white">local scope</font>。(选中看答案)</p><p>  原因很简单，是因为 JS 采用的是词法作用域，函数的作用域基于函数创建的位置。</p><p>  用 《JS 权威指南》的回答就是：</p><blockquote><p>JS 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。</p><p>嵌套的函数 <code>f()</code> 定义在这个作用域链里，其中的变量 <code>scope</code> 一定是局部变量，不管何时何地执行函数 <code>f()</code> 这种绑定在执行 <code>f()</code> 时依然有效。</p></blockquote><p>  <strong>而这两段代码的不同之处在于其执行上下栈的变化不一样：</strong></p><p>  使用伪代码表示，<strong>第一段</strong>代码的执行上下文栈是这样的：</p><pre><code class="hljs js">ECStack.push(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">checkscope</span>&gt;</span> functionContext);</span>ECStack.push(&lt;f&gt; functionContext);ECStack.pop();ECStack.pop();</code></pre><p>  而<strong>第二段</strong>代码为：</p><pre><code class="hljs js">ECStack.push(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">checkscope</span>&gt;</span> functionContext);</span><span class="xml">ECStack.pop();</span>ECStack.push(&lt;f&gt; functionContext);ECStack.pop();</code></pre><h1 id="函数上下文"><a class="markdownIt-Anchor" href="#函数上下文"></a> 函数上下文</h1><h2 id="变量对象"><a class="markdownIt-Anchor" href="#变量对象"></a> 变量对象</h2><p>  **变量对象(variable object，VO)**是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。</p><p>  在函数上下文中，使用<strong>活动对象（activation object，AO）<strong>来表示</strong>变量对象</strong>。</p><p>  变量对象和活动对象实际上是一个东西，它们的区别在于：</p><ul><li>变量对象（<strong>VO</strong>）是规范上或是 JS 引擎上实现的，并不能在 JS 环境中直接访问</li><li>当进入到一个执行上下文后，这个变量对象才会被激活，所以叫活动对象（<strong>AO</strong>），这时候活动对象上的各种属性才能被访问。</li></ul><p>  在调用函数时，会为其创建一个 <code>Arguments</code> 对象，并自动初始化剧本变量 <code>arugments</code>，指代 <code>Arguments</code> 对象。这个对象中存储了所有传入函数的参数。</p><p>  因此 <strong>AO = VO + function parameters + arguments</strong></p><h1 id="执行过程"><a class="markdownIt-Anchor" href="#执行过程"></a> 执行过程</h1><p>  执行上下文中的代码会分为两个阶段进行处理：</p><ol><li>进入执行上下文</li><li>代码执行</li></ol><h2 id="进入执行上下文"><a class="markdownIt-Anchor" href="#进入执行上下文"></a> 进入执行上下文</h2><p>  此时的<strong>变量对象</strong>会以以下顺序初始化：</p><ol><li><p><strong>函数的所有形参</strong>（函数上下文中）：</p><ul><li><p>由名称和对应值组成的一个变量对象的属性被创建</p></li><li><p>没有实参，属性值设为 <code>undefined</code></p></li></ul></li><li><p><strong>函数声明</strong>：</p><ul><li><p>由名称和对应值（function-object）组成的一个变量对象的属性被创建</p></li><li><p>如果变量对象已经存在相同名称的属性，则完全替换这个属性。</p></li></ul></li><li><p><strong>变量声明</strong>：</p><ul><li><p>由名称和对应值（<code>undefined</code>）组成一个变量对象的属性被创建</p></li><li><p>如果变量名称跟已经声明的形参或函数相同，则遍历声明不会干扰已存在的这类属性。</p></li></ul></li></ol><p>如下代码：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">a</span>) </span>&#123;    <span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span>(<span class="hljs-params"></span>) </span>&#123;&#125;    <span class="hljs-keyword">var</span> d = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;    b = <span class="hljs-number">3</span>;&#125;foo(<span class="hljs-number">1</span>);</code></pre><p>  进入执行上下文后，这个时候的（活动对象） AO 是：</p><pre><code class="hljs js">AO = &#123;    <span class="hljs-built_in">arguments</span>: &#123;        <span class="hljs-number">0</span>: <span class="hljs-number">1</span>,        length: <span class="hljs-number">1</span>    &#125;,    a: <span class="hljs-number">1</span>,    b: <span class="hljs-literal">undefined</span>,    c: reference to <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span>(<span class="hljs-params"></span>) </span>&#123;&#125;,    d: <span class="hljs-literal">undefined</span>&#125;</code></pre><p>  形参 <code>a</code> 和 <code>arguments</code> 这时候已经有赋值了，而变量还是 <code>undefined</code>。</p><h2 id="代码执行"><a class="markdownIt-Anchor" href="#代码执行"></a> 代码执行</h2><p>  这个阶段会顺序执行代码，并修改变量对象的值，执行完成后 <code>AO</code> 如下：</p><pre><code class="hljs js">AO = &#123;    <span class="hljs-built_in">arguments</span>: &#123;        <span class="hljs-number">0</span>: <span class="hljs-number">1</span>,        length: <span class="hljs-number">1</span>    &#125;,    a: <span class="hljs-number">1</span>,    b: <span class="hljs-number">3</span>,    c: reference to <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span>(<span class="hljs-params"></span>) </span>&#123;&#125;,    d: reference to FunctionExpression <span class="hljs-string">&quot;d&quot;</span>&#125;</code></pre><h2 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h2><ol><li>全局上下文的变量对象初始化是全局对象</li><li>函数上下文的变量对象初始化只包括 <code>Arguments</code> 对象</li><li>在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值</li><li>在代码执行阶段，会再次修改变量对象的属性值</li></ol><h2 id="两个例子"><a class="markdownIt-Anchor" href="#两个例子"></a> 两个例子</h2><h3 id="1"><a class="markdownIt-Anchor" href="#1"></a> 1</h3><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(a);    a = <span class="hljs-number">1</span>;&#125;foo();</code></pre><p>  上面的代码会报错：<code>Uncaught ReferenceError: a is not defined</code></p><p>  这是因为函数中的 <code>a</code> 没有通过 <code>var</code> 关键字声明，所以不会被存放在 <code>AO</code> 中。</p><p>  在执行 <code>console.log</code> 的时候，<code>AO</code> 的值是：</p><pre><code class="hljs js">AO = &#123;    <span class="hljs-built_in">arguments</span>: &#123;        length: <span class="hljs-number">0</span>    &#125;&#125;</code></pre><p>  没有 <code>a</code> 的值，然后就去全局对象中寻找，也没找到，因此报错了。</p><p>  如果在函数中使用了 <code>var</code> 声明的话：</p><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(a)<span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;</code></pre><p>  那么 <code>console</code> 会打印 <code>undefined</code>。</p><h3 id="2"><a class="markdownIt-Anchor" href="#2"></a> 2</h3><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(foo);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;foo&#x27;</span>);&#125;<span class="hljs-keyword">var</span> foo = <span class="hljs-number">1</span>;</code></pre><p>  上面的代码会打印函数，而不是 <code>undefined</code>。</p><p>  这是因为在进入执行上下文时，首先会处理函数声明，其次处理变量声明，如果变量名称跟已经声明的形参或函数相同，则变量声明不会干扰已存在的这类属性。</p><hr /><p>REF：<a href="https://muyiy.cn/blog/1/1.2.html#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87">https://muyiy.cn/blog/1/1.2.html#执行上下文</a></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
      <category>JS调用堆栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>执行上下文</tag>
      
      <tag>执行栈</tag>
      
      <tag>变量对象</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.JS 执行上下文和执行栈</title>
    <link href="/2020/12/29/JS/JS%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88/1.JS-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88/"/>
    <url>/2020/12/29/JS/JS%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88/1.JS-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<p>  <strong>执行上下文</strong>就是当前 JS 代码被<strong>解析</strong>和<strong>执行</strong>时所在的环境的抽象概念，JS 中运行的代码都是在执行上下文中进行的。</p><h1 id="执行上下文的类型"><a class="markdownIt-Anchor" href="#执行上下文的类型"></a> 执行上下文的类型</h1><h2 id="全局执行上下文"><a class="markdownIt-Anchor" href="#全局执行上下文"></a> 全局执行上下文</h2><p>  默认的执行上下文，一个程序中只有一个全局执行上下文。不在任何函数中的代码都位于全局执行上下文中。它会：1. 创建一个全局对象，浏览器中这个全局对象就是 <code>window</code> 对象；2. 将 <code>this</code> 指向这个全局对象。</p><h2 id="函数执行上下文"><a class="markdownIt-Anchor" href="#函数执行上下文"></a> 函数执行上下文</h2><p>  每个函数都有各自的执行上下文，<strong>只有在函数被调用时才会被创建</strong>，一个程序中可以有任意个函数执行上下文。</p><h2 id="eval-函数执行上下文"><a class="markdownIt-Anchor" href="#eval-函数执行上下文"></a> Eval 函数执行上下文</h2><p>  运行在 <code>eval</code> 函数中的代码也有自己的执行上下文，不过用的很少且不建议使用。</p><h1 id="执行栈"><a class="markdownIt-Anchor" href="#执行栈"></a> 执行栈</h1><p>  执行栈（调用栈），是一个具有 LIFO（后进先出）的结构，用于存储在代码运行期间创建的所有上下文环境。</p><p>  JS 引擎首次读取脚本时，会创建一个全局执行上下文环境并压入执行栈中。然后再代码执行过程中，每发生一个函数调用，就会为该函数创建一个新的执行上下文并将其压入栈顶。</p><p>  JS 引擎会运行执行上下文在执行栈顶端的函数，当函数运行完后，其对应的执行上下文会从执行栈中弹出，上下文控制权转移到当前执行栈的下一个上下文。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;Hello World!&#x27;</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">first</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Inside first function&#x27;</span>);    second();    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Again inside first function&#x27;</span>);  &#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">second</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Inside second function&#x27;</span>);  &#125;first();  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Inside Global Execution Context&#x27;</span>);<span class="hljs-comment">// Inside first function</span><span class="hljs-comment">// Inside second function</span><span class="hljs-comment">// Again inside first function</span><span class="hljs-comment">// Inside Global Execution Context</span></code></pre><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost@master/img/166e258e1d0281a6"><h1 id="执行上下文的创建"><a class="markdownIt-Anchor" href="#执行上下文的创建"></a> 执行上下文的创建</h1><p>  JS 引擎使用执行栈管理执行上下文，下面来看看执行上下文是怎么被创建的。</p><p>  执行上下文的创建分为两个阶段：</p><ol><li>确定 <code>this</code> 的值，也被称为 <code>This Binding</code></li><li><code>LexicalEnvironment（词法环境）</code>组件被创建</li><li><code>VariableEnvironment（变量环境）</code>组件被创建</li></ol><p>  执行上下文在概念上可以这样表示：</p><pre><code class="hljs js">ExecutionContext = &#123;      ThisBinding = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">this</span> <span class="hljs-attr">value</span>&gt;</span>,  // 确定 this 指向</span><span class="xml">    LexicalEnvironment = &#123; ... &#125;,  // 词法环境</span><span class="xml">    VariableEnvironment = &#123; ... &#125;,  // 变量环境</span><span class="xml">&#125;</span></code></pre><h2 id="this-binding"><a class="markdownIt-Anchor" href="#this-binding"></a> This Binding</h2><ul><li><p>在<strong>全局执行上下文</strong>中，<code>this</code> 的值指向全局对象。浏览器中，<code>this</code> 的值指向 <code>window</code> 对象；在 <code>nodejs</code> 中 <code>this</code> 的值指向这个文件的 <code>module</code> 对象。</p></li><li><p>在<strong>函数执行上下文</strong>中，<code>this</code> 的值取决于函数的调用方式。</p></li></ul><h2 id="词法环境lexical-environment"><a class="markdownIt-Anchor" href="#词法环境lexical-environment"></a> 词法环境（Lexical Environment）</h2><p>  词法环境是一个包含<strong>标识符变量映射</strong>的结构。（这里的<strong>标识符</strong>表示变量/函数的名称，<strong>变量</strong>是对实际对象或原始值的引用）</p><p>  词法环境中有两个组成部分：</p><ul><li><strong>环境记录</strong>（environment record）：存储变量和函数声明的实际位置</li><li><strong>对外部环境的引用</strong>：用于访问其外部词法环境</li></ul><p><strong>词法环境</strong>有两种类型：</p><ul><li><strong>全局环境</strong>：是一个没有外部环境的词法环境。全局环境的外部引用为 <code>null</code>。它拥有一个全局对象及其关联的方法和属性以及任何用户自定义的全局变量，<code>this</code> 的值指向这个全局对象。</li><li><strong>函数环境</strong>：用户在函数中定义的变量被存储在环境记录中。对外部的引用可以是全局环境也可以是外部函数环境。且环境记录中还包含了一个 <code>arguments</code> 对象，该对象包含了索引和传递给函数的参数之间的映射即参数长度（数量）。</li></ul><p>  <strong>环境记录</strong>同样有两种类型：</p><ul><li><strong>声明性环境记录</strong>：存储变量、函数和参数。<strong>函数环境</strong>包含声明性环境记录。</li><li><strong>对象环境记录</strong>：用于定义在全局执行上下文中出现的变量和函数的关联。<strong>全局环境</strong>包含对象环境记录。</li></ul><p>词法环境在伪代码中看起来像这样：</p><pre><code class="hljs js">GlobalExectionContext = &#123;    LexicalEnvironment: &#123;      EnvironmentRecord: &#123;        Type: <span class="hljs-string">&quot;Object&quot;</span>,        <span class="hljs-comment">// 标识符绑定在这里 </span>      outer: <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">null</span>&gt;</span>  </span><span class="xml">  &#125;  </span><span class="xml">&#125;</span><span class="xml">FunctionExectionContext = &#123;  </span><span class="xml">  LexicalEnvironment: &#123;  </span><span class="xml">    EnvironmentRecord: &#123;  </span><span class="xml">      Type: &quot;Declarative&quot;,  </span><span class="xml">      // 标识符绑定在这里 </span>      outer: &lt;Global or outer function environment reference&gt;    &#125;  &#125;</code></pre><h2 id="变量环境variable-environment"><a class="markdownIt-Anchor" href="#变量环境variable-environment"></a> 变量环境（Variable Environment）</h2><p>  <strong>变量环境也是一个词法环境，因此它具有词法环境的所有属性。</strong></p><p>  在 ES6 中，<strong>词法环境组件</strong>和<strong>变量环境组件</strong>的区别在于前者用于存储函数声明和变量（<code>let</code> 和 <code>const</code>）绑定，而后者仅用于存储变量（<code>var</code>）绑定。</p><p>例：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">20</span>;  <span class="hljs-keyword">const</span> b = <span class="hljs-number">30</span>;  <span class="hljs-keyword">var</span> c;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multiply</span>(<span class="hljs-params">e, f</span>) </span>&#123;      <span class="hljs-keyword">var</span> g = <span class="hljs-number">20</span>;      <span class="hljs-keyword">return</span> e * f * g;  &#125;c = multiply(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>);</code></pre><p>执行上下文为：</p><pre><code class="hljs js">GlobalExectionContext = &#123;  ThisBinding: <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Global</span> <span class="hljs-attr">Object</span>&gt;</span>,</span><span class="xml">  LexicalEnvironment: &#123;  </span><span class="xml">    EnvironmentRecord: &#123;  </span><span class="xml">      Type: &quot;Object&quot;,  </span><span class="xml">      // 标识符绑定在这里  </span><span class="xml">      a: <span class="hljs-tag">&lt; <span class="hljs-attr">uninitialized</span> &gt;</span>,  </span><span class="xml">      b: <span class="hljs-tag">&lt; <span class="hljs-attr">uninitialized</span> &gt;</span>,  </span><span class="xml">      multiply: <span class="hljs-tag">&lt; <span class="hljs-attr">func</span> &gt;</span>  </span><span class="xml">    &#125;  </span>    outer: &lt;null&gt;    &#125;,  VariableEnvironment: &#123;      EnvironmentRecord: &#123;        Type: &quot;Object&quot;,        // 标识符绑定在这里        c: undefined,      &#125;      outer: &lt;null&gt;    &#125;  &#125;FunctionExectionContext = &#123;       ThisBinding: &lt;Global Object&gt;,  LexicalEnvironment: &#123;      EnvironmentRecord: &#123;        Type: &quot;Declarative&quot;,        // 标识符绑定在这里        Arguments: &#123;0: 20, 1: 30, length: 2&#125;,      &#125;,      outer: &lt;GlobalLexicalEnvironment&gt;    &#125;,  VariableEnvironment: &#123;      EnvironmentRecord: &#123;        Type: &quot;Declarative&quot;,        // 标识符绑定在这里        g: undefined      &#125;,      outer: &lt;GlobalLexicalEnvironment&gt;    &#125;  &#125;</code></pre><p>  <strong>注意</strong>，只有在遇到函数 <code>multiply</code> 的调用时才会创建执行上下文。</p><p>  在上面的环境记录中，<code>let</code> 和 <code>const</code> 定义的变量没有任何与之关联的值，但 <code>var</code> 定义的变量设置为 <code>undefined</code>。</p><p>  这是因为在创建阶段，代码会被扫描并解析变量和函数声明，其中函数声明存储在环境中，而变量会被设置为 <code>undefined</code> （在 <code>var</code> 的情况下）或保持未初始化（在 <code>let</code> 和 <code>const</code> 的情况下）。</p><p>  这就是对于 <code>var</code> 定义的变量能在声明之前就访问（尽管是 <code>undefined</code>），但如果在声明之前就访问 <code>let</code> 和 <code>const</code> 定义的变量就会提示引用错误。</p><p>  这就是所谓的<strong>变量提升</strong>。</p><h2 id="执行阶段"><a class="markdownIt-Anchor" href="#执行阶段"></a> 执行阶段</h2><p>  在此阶段，完成对所有变量的分配，最后执行代码。</p><p>  在执行阶段，如果 Javascript 引擎在源代码中声明的实际位置找不到 <code>let</code> 变量的值，那么将为其分配 <code>undefined</code> 值。</p><hr /><p>REF：<a href="https://juejin.cn/post/6844903704466833421">https://juejin.cn/post/6844903704466833421</a></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
      <category>JS调用堆栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>执行上下文</tag>
      
      <tag>执行栈</tag>
      
      <tag>变量提升</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运行环境</title>
    <link href="/2020/12/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/JS%E7%8E%AF%E5%A2%83/"/>
    <url>/2020/12/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/JS%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h1 id="v8-执行-js-大致流程"><a class="markdownIt-Anchor" href="#v8-执行-js-大致流程"></a> V8 执行 JS 大致流程</h1><p>  编程语言有两种类别：静态类型和动态类型。</p><p>  <strong>静态类型语言</strong>如 C++、GO 等，需要提前编译（AOT）成机器码然后执行，这个过程主要使用<strong>编译器</strong>来完成。</p><p>  <strong>动态类型语言</strong>如 JS、Python 等，只在运行时进行编译执行（JIT），这个过程通过<strong>解释器</strong>来完成。</p><p>  而 V8 采用了混合编译执行和解释执行的方式，我们称为 <strong>JIT</strong>（Just-In-Time-Compilation）</p><p>  这是一种权衡策略，因为这两种方法都有各自优缺点，解释执行的启动速度快，但是执行时的速度慢，而编译执行的启动速度慢，但是执行时的速度快。</p><h2 id="编译器的工作流程"><a class="markdownIt-Anchor" href="#编译器的工作流程"></a> 编译器的工作流程</h2><p>源代码<code>-&gt;</code>词法分析、语法分析<code>-&gt;</code>AST<code>-&gt;</code>语义分析<code>-&gt;</code>中间代码<code>-&gt;</code>代码优化<code>-&gt;</code>机器码<code>-&gt;</code>执行</p><h2 id="解释器工作流程"><a class="markdownIt-Anchor" href="#解释器工作流程"></a> 解释器工作流程</h2><p>源代码<code>-&gt;</code>词法、语法分析<code>-&gt;</code>AST<code>-&gt;</code>语义分析<code>-&gt;</code>字节码<code>-&gt;</code>执行</p><h2 id="v8-工作流程"><a class="markdownIt-Anchor" href="#v8-工作流程"></a> V8 工作流程</h2><p>  首先将 JS <strong>源码</strong>通过解析器解析成<strong>抽象语法树 AST</strong>。</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost@master/img/image-20200802170037793.png" alt="image-20200802170037793" style="zoom:80%;" /><p>  接着再通过解释器将 <strong>AST</strong> 编译成<strong>字节码</strong> bytecode</p><p>  字节码是跨平台的一种中间表示，不同于最终的机器代码，字节码与平台无关，能够在不同操作系统上运行：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost@master/img/image-20200802170115022.png" alt="image-20200802170115022" style="zoom:80%;" /><p>  字节码最后通过编译器生成机器代码：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost@master/img/image-20200802170225783.png" alt="image-20200802170225783" style="zoom:80%;" /><h3 id="基础准备"><a class="markdownIt-Anchor" href="#基础准备"></a> 基础准备</h3><p>  V8 在启动执行 JS 之前，还需要准备一些执行 JS 需要的基础环境，包括 <strong>堆空间</strong>，<strong>栈空间</strong>，<strong>全局执行上下文</strong>，<strong>全局作用域</strong>，<strong>消息循环系统</strong>，<strong>内置函数</strong> 等。</p><h2 id="执行步骤"><a class="markdownIt-Anchor" href="#执行步骤"></a> 执行步骤</h2><p>  基础环境准备好之后，接下来就能使用 V8 执行启动 JS 了：</p><ol><li>首先使用解析器将 JS 源码解析成抽象语法树（AST），它是一种便于 V8 理解的结构，在生成 AST 的同时，V8 还会生成相关的作用域，作用域中存放相关变量。</li><li>接着，通过解释器将 AST 编译成字节码 bytecode，解释器可以直接执行字节码，或通过编译器将其编译为二进制代码再执行</li><li>解释器按照顺序解释执行字节码，并输出执行结果</li><li>在解释器执行过程中，若某段代码被重复多次执行，那么这段代码会被标记为热点代码</li><li>对于热点代码，V8 会将这段字节码交给编译器去将其编译为二进制代码，并执行优化操作，优化后的二进制代码执行效率会大幅提升。若下面再次执行到这段代码时，V8 会优先选择执行优化后的二进制代码。</li><li>不过，由于 JS 是一种动态类型语言，因此在执行过程中某个对象的结构和属性是可以被修改的，而经过编译器优化后的代码是只针对某种固定的结构，因此编译器需要再次执行优化操作。</li></ol><h2 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h2><p>  V8 执行一段 JS 代码的大致流程：</p><ol><li>初始化基础环境</li><li>解析源码生成 AST 和作用域</li><li>根据 AST 和作用域生成字节码</li><li>解释执行字节码</li><li>监听热点代码</li><li>使用编译器优化编译热点代码成二进制代码</li></ol>]]></content>
    
    
    <categories>
      
      <category>前端面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>V8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 51. 数组中的逆序对</title>
    <link href="/2020/12/19/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87-Offer-51-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    <url>/2020/12/19/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87-Offer-51-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/</a></p><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><p><strong>示例 1:</strong></p><p>输入: <code>[7,5,6,4]</code></p><p>输出: <code>5</code></p><p><strong>限制：</strong></p><p><code>0 &lt;= 数组长度 &lt;= 50000</code></p><hr /><p>  在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><h1 id="解法1二叉搜索树"><a class="markdownIt-Anchor" href="#解法1二叉搜索树"></a> 解法1：二叉搜索树</h1><p>  在一组数字中，如 <code>[7, 5, 6, 4]</code>，对于每个数字，能否组成逆序对就得看前面是否有出现过比当前数字大的数字，而这个数字的个数就是与当前数字构成的逆序对的个数。如 <code>4</code>，那么前面有 <code>3</code> 个比 <code>4</code> 大的数，因此与当前数字 <code>4</code> 组成的逆序对个数就是 <code>3</code>。</p><p>  那么我们就需要一种办法来快速找到比当前数字大的出现过的数字的个数，想到效率问题，我们就可能会联想到<strong>二叉搜索树</strong>：<strong>左子树的节点值都比父节点值小，右子树的节点值都比当父节点值大</strong>。</p><p>  我们一边顺序遍历数字一边建树，对于遍历到的数字 <code>x</code>，在建树的过程中，若当前比较的节点值 <code>y</code> 比 <code>x</code> 大，那么其右子树上的节点值一定都大于 <code>x</code>，因此这个节点值 <code>y</code> 和其右子树上的所有节点值都能与 <code>x</code> 组成一个逆序对，所以逆序对的数量就是：<strong>右子树节点的个数 + 1（节点 y）</strong>，不过考虑到输入的数组中会出现<strong>重复的数字</strong>，因此每个节点中还需要使用一个变量来保存当前节点值的出现次数 <code>n</code>，所以最终逆序对的个数就是：<strong>右子树节点的个数 + 当前节点的出现次数</strong>。</p><p>  综上，二叉搜索树的构造为：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Tree</span>(<span class="hljs-params">val</span>) </span>&#123;<span class="hljs-built_in">this</span>.val = val;    <span class="hljs-built_in">this</span>.left = <span class="hljs-literal">null</span>;    <span class="hljs-built_in">this</span>.right = <span class="hljs-literal">null</span>;    <span class="hljs-built_in">this</span>.rightChildren = <span class="hljs-number">0</span>; <span class="hljs-comment">// 右子树的节点个数</span>    <span class="hljs-built_in">this</span>.n = <span class="hljs-number">1</span>;<span class="hljs-comment">// 当前节点值的出现次数</span>&#125;</code></pre><p>因此算法步骤就是：</p><ol><li>遍历输入数组，当前遍历到的值为 <code>x</code>，将 <code>x</code> 插入二叉搜索树中，二叉搜索树的根为 <code>nums[0]</code>。</li><li>插入过程中会将 <code>x</code> 对树中的节点值进行比较，若当前节点的值大于 <code>x</code> ，那么将 <code>x</code> 插入其左子树中，并累计逆序对个数：<code>ans += node.rightChildren + node.n</code>。</li><li>若当前节点值小于 <code>x</code>，那么将 <code>x</code> 插入其右子树中，且增加右子树节点个数：<code>node.rightChildren++</code></li><li>若当前节点值等于 <code>x</code>，那么将 <code>x</code> 的出现次数加1：<code>node.n++</code>；且当前节点的右子树都能与 <code>x</code> 组成逆序对，因此 <code>ans += node.rightChildren</code>。</li></ol><p>用图来表示就是（下图中红色点代表当前插入的节点）：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost@master/img/image-20201219162125669.png" alt="image-20201219162125669" style="zoom:80%;" /><p><strong>想法很好但遇到了超时的 case</strong> 😭</p><p>  因为有 <code>case</code> 是单调递增、递减的，因此二叉树退化成链表，然后插入操作时间复杂度就变成了 <code>O(n^2)</code>。</p><p><strong>JS 代码：</strong></p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Tree</span>(<span class="hljs-params">val, left, right</span>) </span>&#123;    <span class="hljs-built_in">this</span>.val = val;    <span class="hljs-built_in">this</span>.rightChildren = <span class="hljs-number">0</span>;    <span class="hljs-built_in">this</span>.n = <span class="hljs-number">1</span>;    <span class="hljs-built_in">this</span>.left = left || <span class="hljs-literal">null</span>;    <span class="hljs-built_in">this</span>.right = right || <span class="hljs-literal">null</span>;&#125;<span class="hljs-keyword">var</span> reversePairs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;    <span class="hljs-keyword">if</span> (nums.length === <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">let</span> root = <span class="hljs-keyword">new</span> Tree(nums[<span class="hljs-number">0</span>]);    <span class="hljs-keyword">let</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">const</span> insert = <span class="hljs-function">(<span class="hljs-params">root, val</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (val === root.val) &#123;            ans += root.rightChildren;            root.n++;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val &lt; root.val) &#123;            ans += root.rightChildren + root.n;            <span class="hljs-keyword">if</span> (!root.left) &#123;                root.left = <span class="hljs-keyword">new</span> Tree(val);            &#125; <span class="hljs-keyword">else</span> &#123;                insert(root.left, val);            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            root.rightChildren++;            <span class="hljs-keyword">if</span> (!root.right) &#123;                root.right = <span class="hljs-keyword">new</span> Tree(val);            &#125; <span class="hljs-keyword">else</span> &#123;                insert(root.right, val);            &#125;        &#125;    &#125;;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;        insert(root, nums[i]);    &#125;    <span class="hljs-keyword">return</span> ans;&#125;;</code></pre><h1 id="解法二归并"><a class="markdownIt-Anchor" href="#解法二归并"></a> 解法二：归并</h1><p>  归并的思想是将一个序列分为两份，如 <code>L = [8, 12, 16, 22, 100]</code>， <code>R = [9, 26, 55, 64, 91]</code>；</p><p>  那么<strong>左边的部分 <code>L</code> 中的值的索引一定是小于右边部分 <code>R</code> 中的值的索引的。</strong> 因此<strong>若 <code>L</code> 中有值比 <code>R</code> 中的值大</strong>，那么一定是能组成逆序对的。</p><p>  且基于归并排序，这两个序列都是有序的，因此就可以使用双指针来辅助计算逆序对个数 <code>ans</code>，我们按顺序比较 <code>L</code> 和 <code>R</code> 中的值，假设 <code>L</code> 的索引是从 <code>l</code> 到 <code>mid</code> ，<code>R</code> 的索引是从 <code>mid+1</code> 到 <code>r</code>，那么：</p><ul><li>初始时设置两个指针，指针 <code>i</code> 指向 <code>L</code> 中的第一个元素 <code>8</code>，<code>j</code> 指向 <code>R</code> 中的第一个元素 <code>9</code></li><li>若 <code>nums[i] &gt; nums[j]</code>，那么 <code>nums[i]</code> 能与 <code>nums[mid+1] ~ nums[j]</code> 的所有数字构成逆序对（因为序列 <code>R</code> 是递增的，因此 <code>nums[j]</code> 之前的数一定会小于 <code>nums[j]</code>，也就是会小于 <code>nums[i]</code>），但此时我们先不计算逆序对个数（后面再一起计算），将 <code>j</code> 向后移一位：<code>j++</code></li><li>若 <code>nums[i] &lt;= nums[j]</code>，那么这两个数无法构成逆序对，此时计算 <code>nums[i]</code> 能与 <code>R</code> 中元素组成的逆序对个数：<code>ans += j - mid - 1</code>（<code>mid + 1 ~ j - 1</code> 的元素个数），指针 <code>i</code> 向后移一位：<code>i++</code></li><li>当 <code>i &gt; mid</code> 或 <code>j &gt; r</code> 时，退出循环，此时：<ul><li>若 <code>i &lt;= mid</code>，那么说明 <code>i</code> 及 <code>i</code> 之后的数都会<strong>大于</strong> <code>nums[mid + 1] ~ nums[r]</code>（因为循环中是当 <code>nums[i] &gt; nums[j]</code> 时 <code>j</code> 才向后移一位），因此这些数字都能与 <code>R</code> 中的所有数字组成逆序对，所以能够组成的逆序对的个数是 <code>L 中剩余的元素个数 * R 中的元素个数</code>，也就是：<code>ans += (mid - i + 1) * (r - mid)</code></li></ul></li></ul><p>JS 代码为：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> reversePairs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;    <span class="hljs-keyword">let</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 合并操作，将 [l, mid] 和 [mid+1, r] 位置的元素从小到大合并</span>    <span class="hljs-keyword">const</span> merge = <span class="hljs-function">(<span class="hljs-params">l, mid, r</span>) =&gt;</span> &#123;        <span class="hljs-keyword">let</span> res = [];        <span class="hljs-keyword">let</span> i = l, j = mid + <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;            <span class="hljs-keyword">if</span> (nums[i] &lt;= nums[j]) &#123;                res.push(nums[i]);                i++;            &#125; <span class="hljs-keyword">else</span> &#123;                res.push(nums[j]);                j++;            &#125;        &#125;        <span class="hljs-keyword">while</span>(i &lt;= mid) &#123;            res.push(nums[i++]);        &#125;        <span class="hljs-keyword">while</span> (j &lt;= r) &#123;            res.push(nums[j++]);        &#125;        i = l;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n <span class="hljs-keyword">of</span> res) &#123;            nums[i++] = n;        &#125;    &#125;;    <span class="hljs-keyword">const</span> mergeSort = <span class="hljs-function">(<span class="hljs-params">l, r</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (l &lt; r) &#123;            <span class="hljs-keyword">let</span> mid = l + <span class="hljs-built_in">Math</span>.floor((r - l) / <span class="hljs-number">2</span>);            mergeSort(l, mid);            mergeSort(mid + <span class="hljs-number">1</span>, r);            <span class="hljs-keyword">let</span> i = l, j = mid + <span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;                <span class="hljs-comment">// 当 nums[i] &lt;= nums[j] 时，计算 nums[i] 能与 nums[mid + 1 ~ j - 1] 组成逆序对</span>                <span class="hljs-keyword">if</span> (nums[i] &lt;= nums[j]) &#123;                    i++;                    ans += j - mid - <span class="hljs-number">1</span>;                &#125; <span class="hljs-keyword">else</span> &#123;                    j++;                &#125;            &#125;            <span class="hljs-comment">// 若出循环后 R 已经遍历完了，那么 L 中的剩余数字都能与 R 中的数字组成逆序对</span>            <span class="hljs-keyword">if</span> (i &lt;= mid) &#123;                ans += (mid + <span class="hljs-number">1</span> - i) * (r - mid);            &#125;            merge(l, mid, r);        &#125;    &#125;;    mergeSort(<span class="hljs-number">0</span>, nums.length<span class="hljs-number">-1</span>);    <span class="hljs-keyword">return</span> ans;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>解答</category>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉搜索树</tag>
      
      <tag>分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手撕内核源码</title>
    <link href="/2020/12/13/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%89%8B%E6%92%95JS%E4%BB%A3%E7%A0%81/"/>
    <url>/2020/12/13/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%89%8B%E6%92%95JS%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="array"><a class="markdownIt-Anchor" href="#array"></a> Array</h1><h2 id="arrayprototypemap"><a class="markdownIt-Anchor" href="#arrayprototypemap"></a> Array.prototype.map</h2><h3 id="map-概念"><a class="markdownIt-Anchor" href="#map-概念"></a> map 概念</h3><p><code>map(callback(val, idx, arr), thisArg)</code> 方法将创建一个新数组，这个数组中的元素是原数组中的每个元素都调用 <code>callback</code> 后的结果，其中 <code>callback</code> 的三个参数分别是原数组中的元素、元素对应索引值和原数组，<code>thisArg</code> 是 <code>map</code> 函数的 <code>this</code> 指向。</p><p>因此调用 <code>map</code> 函数后，原数组不会发生改变。</p><p>且，调用的数组 <code>arr</code> 中的元素不一定是连续的（有的索引位置会为 <code>empty</code>），这点需要注意。</p><pre><code class="hljs js"><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.prototype.map) &#123;    <span class="hljs-built_in">Array</span>.prototype.map = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback, thisArg</span>) </span>&#123;        <span class="hljs-keyword">let</span> A, T, k;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;this is null or undefined!&quot;</span>);        &#125;        <span class="hljs-comment">// 1. 将 O 赋值为调用 map 方法的数组.</span>        <span class="hljs-comment">// 使用 Object 是为了保证 o 为对象</span>        <span class="hljs-keyword">let</span> O = <span class="hljs-built_in">Object</span>(<span class="hljs-built_in">this</span>);        <span class="hljs-comment">// 2. 将 len 赋值为数组 O 的长度.  </span>        <span class="hljs-comment">// 这边 &lt;&lt;&lt; 运算符为 零填充右移运算符，如 0101 &gt;&gt;&gt; 1 : 0010，猜测这么做是为了防止 len 为字符串</span>        <span class="hljs-keyword">let</span> len = O.length &gt;&gt;&gt; <span class="hljs-number">0</span>;        <span class="hljs-comment">// 3. 如果 callback 不是函数,则抛出 TypeError 异常.</span>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.prototype.toString.call(callback) != <span class="hljs-string">&quot;[object Function]&quot;</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(callback + <span class="hljs-string">&quot;is not a function!&quot;</span>);        &#125;        <span class="hljs-comment">// 4. 如果参数 thisArg 有值,则将 T 赋值为 thisArg; 否则T为 undefined.</span>        <span class="hljs-keyword">if</span> (thisArg) &#123;            T = thisArg;        &#125;        <span class="hljs-comment">// 5. 创建新数组 A,长度为原数组 O 长度 len</span>        A = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len);        <span class="hljs-comment">// 6. 将 k 赋值为0</span>        k = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 7. 当 k &lt; len 时,执行循环.</span>        <span class="hljs-keyword">while</span> (k &lt; len) &#123;            <span class="hljs-keyword">let</span> kVal, mappedVal;            <span class="hljs-comment">//遍历 O, k 为原数组索引 , 这边有个疑问，为什么不直接遍历 O，因为如果数组中的元素很松散的话 k++ 效率可能会很低</span>            <span class="hljs-keyword">if</span> (k <span class="hljs-keyword">in</span> O) &#123;                <span class="hljs-comment">// kVa为索引 k 对应的值.</span>                kVal = O[k];                <span class="hljs-comment">// 执行 callback,this 指向 T,参数有三个.分别是kVal:值, k:索引, O:原数组.</span>                mappedVal = callback.call(T, kVal, k, O);                <span class="hljs-comment">// 返回值添加到新数组 A 中.</span>                A[k] = mappedVal;            &#125;            k++;        &#125;        <span class="hljs-keyword">return</span> A;    &#125;&#125;</code></pre><p>上面代码中的 <code>1</code>：使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object">Object</a>  是为了保证 <code>o</code> 一定是一个对象：</p><ul><li>当给定值是 <code>null</code> 或 <code>undefined</code> 时，会创建并返回一个空对象</li><li>若传进去的是一个基本类型的值，则会构造其包装类型的对象，如 <code>Object(3)</code> ，会返回 <code>Number &#123;3&#125;</code></li><li>若传的是引用类型的值，仍会返回这个值，因此引用是相同的</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内核源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS内容</title>
    <link href="/2020/12/13/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/JS%E5%86%85%E5%AE%B9/"/>
    <url>/2020/12/13/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/JS%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="1-1-2-3mapparseint"><a class="markdownIt-Anchor" href="#1-1-2-3mapparseint"></a> 1. [‘1’, ‘2’, ‘3’].map(parseInt)</h1><p>  这题涉及到两个函数，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map">Array.prototype.map</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt">parseInt</a></p><p>说点题外话，首先，<code>map</code> 函数的调用不会改变原数组，它会返回一个新数组，其次，map 函数在调用回调时的处理元素的范围已经确定了，过程中再追加的数组元素不会被访问到。</p><p>  回到本题，<code>map</code> 函数的第一个参数是一个回调函数，第二个参数是可选的 <code>this</code> 指向，回调函数会被<strong>自动传入三个参数</strong>：<strong>数组元素</strong>、<strong>元素索引</strong>、原数组本身。</p><p>  而 <code>parseInt</code> 函数接收两个参数，第一个是要被解析的值，第二个是可选的进制基数（ <code>2 - 36</code>，当第二个参数为 <code>undefined</code> 或 <code>0</code> 时，若第一个参数以 <code>0x</code> 开头，会认为是十六进制，以 <code>0</code> 开头会认为是八进制，其他开头会默认为十进制）。</p><p>  当传入的第二个参数小于 <code>2</code> 或大于 <code>36</code> 时，函数会返回 <code>NaN</code></p><p>  这样问题就来了，在 <code>map</code> 函数中使用 <code>parseInt</code> 作为回调函数，会自动传入数组元素和元素索引作为 <code>parseInt</code> 函数的两个参数，因此解析的过程就是：</p><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 1</span><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// NaN</span><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// NaN</span></code></pre><p>  根据上面对 <code>parseInt</code> 的描述，因为 <code>radix</code> 为 <code>0</code> 且不是 <code>0x</code> 或 <code>0</code> 开头，因此默认为十进制，返回 <code>1</code>；</p><p>  第二行，因为 <code>radix = 1 &lt; 2</code>，因此返回 <code>NaN</code>；</p><p>  第三行，<code>radix = 2</code>，但 <code>3</code> 超出了二进制范围，因此也返回 <code>NaN</code>。</p><p>  同理，<code>['10','10','10','10','10'].map(parseInt);</code> 返回值为 <code>[10, NaN, 2, 3, 4]</code></p><p>  那么要怎么修改才能使结果变成我们想要的答案呢？</p><p>  1.使用 <code>Number</code> 构造函数：</p><pre><code class="hljs js">[<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>].map(<span class="hljs-built_in">Number</span>); <span class="hljs-comment">// [1, 2, 3]</span></code></pre><p>  2.<code>map</code> 中指定 <code>parseInt</code> 函数的参数：</p><pre><code class="hljs js">[<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>].map(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-built_in">parseInt</span>(v)); <span class="hljs-comment">// 或 parseInt(v, 10)，指定为 10 进制</span></code></pre><h2 id="一个变形"><a class="markdownIt-Anchor" href="#一个变形"></a> 一个变形</h2><p>  使用了连续的箭头表达式，指定了<code>map</code> 回调中的参数</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> unary = <span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> fn(val)<span class="hljs-keyword">let</span> parse = unary(<span class="hljs-built_in">parseInt</span>)<span class="hljs-built_in">console</span>.log([<span class="hljs-string">&#x27;1.1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;0.3&#x27;</span>].map(parse))</code></pre><p>  相当于：</p><pre><code class="hljs js">[<span class="hljs-string">&#x27;1.1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;0.3&#x27;</span>].map(<span class="hljs-function">(<span class="hljs-params">val, idx, arr</span>) =&gt;</span> <span class="hljs-built_in">parseInt</span>(val));</code></pre><h1 id="2-什么是防抖和节流有什么区别"><a class="markdownIt-Anchor" href="#2-什么是防抖和节流有什么区别"></a> 2. 什么是防抖和节流，有什么区别</h1><p>REF :</p><p><a href="https://github.com/mqyqingfeng/Blog/issues/22">https://github.com/mqyqingfeng/Blog/issues/22</a></p><p><a href="https://github.com/mqyqingfeng/Blog/issues/26">https://github.com/mqyqingfeng/Blog/issues/26</a></p><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>  对于一些频繁的操作，如对窗口的 <code>resize</code>、<code>scroll</code>、输入框内容改动响应时，如果相应处理函数没有频率限制的话，会加重浏览器的负担，导致用户体验差，而防抖(debounce) 和节流(throttle) 可以有效减少处理函数的调用频率，同时不影响实际效果。</p><h2 id="防抖"><a class="markdownIt-Anchor" href="#防抖"></a> 防抖</h2><p>  触发高频事件后 <code>n</code> 秒内函数只会执行一次，如果 <code>n</code> 秒内高频事件再次被触发，则重新计算时间。</p><p>  一个连续操作中的处理，只触发一次，从而实现防抖动。</p><blockquote><p>思路：每次触发事件后都取消之前的延迟调用的方法</p></blockquote><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, wait</span>) </span>&#123;    <span class="hljs-keyword">let</span> timeout = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">clearTimeout</span>(timeout); <span class="hljs-comment">// 每当用户输入的时候把前一个 setTimeout clear 掉</span>        <span class="hljs-comment">// 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数</span>        timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-comment">// this 确保当前指向的对象是调用函数的对象，如 input 对象</span>            fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);        &#125;, wait);    &#125;;&#125;</code></pre><h3 id="立即执行的-debounce"><a class="markdownIt-Anchor" href="#立即执行的-debounce"></a> 立即执行的 debounce</h3><p>  <code>underscore</code> 中的防抖还可以实现立即执行的功能：当 <code>immediate</code> 为 <code>true</code> 时，立即执行函数， <code>wait</code> 秒后才能重新触发（即当 <code>timer</code> 为 <code>null</code> 时）。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">immedDebounce</span>(<span class="hljs-params">fn, wait, immediate</span>) </span>&#123;    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">if</span> (timer) &#123;            <span class="hljs-built_in">clearTimeout</span>(timer);        &#125;        <span class="hljs-keyword">if</span> (immediate) &#123;            <span class="hljs-keyword">let</span> callNow = !timer;            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;                timer = <span class="hljs-literal">null</span>;            &#125;, wait);            <span class="hljs-keyword">if</span> (callNow) &#123;                fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;                fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);            &#125;, wait);        &#125;    &#125;&#125;</code></pre><h3 id="带返回值的-debounce"><a class="markdownIt-Anchor" href="#带返回值的-debounce"></a> 带返回值的 debounce</h3><p>  对于立即执行的 <code>debounce</code>，当 <code>immediate</code> 为 <code>true</code> 时，当函数立即执行时，可以直接返回函数结果，而当 <code>immediate</code> 为 <code>false</code> 时，因为设置了 <code>timeout</code> ，因此获取不到返回值，函数返回 <code>undefined</code>。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">retDebounce</span>(<span class="hljs-params">fn, wait, immediate</span>) </span>&#123;    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">let</span> result;        <span class="hljs-keyword">if</span> (timer) &#123;            <span class="hljs-built_in">clearTimeout</span>(timer);        &#125;        <span class="hljs-keyword">if</span> (immediate) &#123;            <span class="hljs-keyword">let</span> callNow = !timer;            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;                timer = <span class="hljs-literal">null</span>;            &#125;, wait);            <span class="hljs-keyword">if</span> (callNow) &#123;                result = fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;                fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);            &#125;, wait);        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre><h3 id="可取消的-debounce"><a class="markdownIt-Anchor" href="#可取消的-debounce"></a> 可取消的 debounce</h3><p>  若防抖时间较长，而 <code>immediate</code> 为 <code>true</code> 时（立即执行一次，然后需要再等待 <code>wait</code> 后才能触发），又想早点再次触发，可以选择取消防抖状态。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cancelDebounce</span>(<span class="hljs-params">fn, wait, immediate</span>) </span>&#123;    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">const</span> debounced = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">let</span> result;        <span class="hljs-keyword">if</span> (timer) &#123;            <span class="hljs-built_in">clearTimeout</span>(timer);        &#125;        <span class="hljs-keyword">if</span> (immediate) &#123;            <span class="hljs-keyword">let</span> callNow = !timer;            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;                timer = <span class="hljs-literal">null</span>;            &#125;, wait);            <span class="hljs-keyword">if</span> (callNow) &#123;                result = fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;                fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);            &#125;, wait);        &#125;        <span class="hljs-keyword">return</span> result;    &#125;;    debounced.cancel = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">clearTimeout</span>(timer);        timer = <span class="hljs-literal">null</span>;    &#125;;    <span class="hljs-keyword">return</span> debounced;&#125;</code></pre><p>  使用实例：两个按钮，当点击了 <code>say hello</code> 按钮后，需要等待两秒后再次点击按钮才能输出 <code>hello</code>，若不想等待，点击 <code>cancel hello</code> 后再次点击 <code>say hello</code> 后会立即输出 <code>hello</code>。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hi</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>);&#125;<span class="hljs-keyword">let</span> inp = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;button&#x27;</span>);inp.innerHTML = <span class="hljs-string">&#x27;say hello&#x27;</span>;<span class="hljs-keyword">let</span> inp1 = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;button&#x27;</span>);inp1.innerHTML = <span class="hljs-string">&#x27;cancel hello&#x27;</span>;<span class="hljs-built_in">document</span>.body.appendChild(inp);<span class="hljs-built_in">document</span>.body.appendChild(inp1);<span class="hljs-keyword">let</span> de = cancelDebounce(hi, <span class="hljs-number">2000</span>, <span class="hljs-literal">true</span>);inp.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, de);inp1.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, de.cancel);</code></pre><h2 id="节流"><a class="markdownIt-Anchor" href="#节流"></a> 节流</h2><p>  高频事件触发，但在 <code>n</code> 秒内只会执行一次，所以节流会稀释函数的执行频率。</p><p>  一个连续操作中的处理，按照阀值时间间隔进行触发，从而实现节流。</p><p>  在一定的时间间隔内，某个事件之会执行一次</p><blockquote><p>思路：每次触发事件时都判断当前是否有在等待执行的回调函数</p></blockquote><h3 id="使用时间戳"><a class="markdownIt-Anchor" href="#使用时间戳"></a> 使用时间戳</h3><p>  根据时间戳来判断两次响应的间隔是否大于设置的间隔，大于才能执行下一次响应函数。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, time</span>) </span>&#123;    <span class="hljs-keyword">let</span> activeTime = <span class="hljs-number">0</span>;    reutrn () =&gt; &#123;        <span class="hljs-keyword">const</span> current = <span class="hljs-built_in">Date</span>.now(); <span class="hljs-comment">// +new Date()</span>        <span class="hljs-keyword">if</span> (current - activeTime &gt; time) &#123;            fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);            activeTime = current;        &#125;    &#125;;&#125;</code></pre><h3 id="使用定时器"><a class="markdownIt-Anchor" href="#使用定时器"></a> 使用定时器</h3><p>使用了定时器，当事件触发时不会立即执行，等待时间过后才会开始执行，然后清空计数器。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle1</span>(<span class="hljs-params">fn, wait</span>) </span>&#123;    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">if</span> (!timer) &#123;            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;                timer = <span class="hljs-literal">null</span>;                fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);            &#125;, wait);        &#125;    &#125;&#125;</code></pre><h3 id="比较两个节流方法"><a class="markdownIt-Anchor" href="#比较两个节流方法"></a> 比较两个节流方法</h3><ol><li>使用时间戳的节流方法触发事件时会立即执行，而使用定时器的方法会在触发事件 <code>n</code> 秒后再执行；</li><li>使用时间戳的方法停止触发事件后不会再执行，使用定时器的方法会在停止触发事件的 <code>n</code> 秒后再执行一次。</li></ol><h3 id="综合节流方法"><a class="markdownIt-Anchor" href="#综合节流方法"></a> 综合节流方法</h3><p>综合时间戳和定时器的效果，当触发事件时会立即执行，且在停止事件触发的 <code>n</code> 秒后还会再执行一次。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle2</span>(<span class="hljs-params">fn, wait</span>) </span>&#123;    <span class="hljs-keyword">let</span> previous = <span class="hljs-number">0</span>, timer = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">let</span> later = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        timer = <span class="hljs-literal">null</span>;        previous = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();        fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);    &#125;;    <span class="hljs-keyword">let</span> throttled = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">let</span> now = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();        <span class="hljs-comment">// 剩余等待时间</span>        <span class="hljs-keyword">let</span> remain = wait - (now - previous);        <span class="hljs-comment">// 若没有剩余时间或因修改了系统时间导致剩余时间大于等待时间</span>        <span class="hljs-comment">// 若非主动修改系统时间，此时会是第一次触发执行</span>        <span class="hljs-keyword">if</span> (remain &lt;= <span class="hljs-number">0</span> || remain &gt; wait) &#123;            <span class="hljs-comment">// 若是调整了系统时间导致的立即执行，若前面有设置一个 timer，需要将其清除</span>            <span class="hljs-keyword">if</span> (timer) &#123;                <span class="hljs-built_in">clearTimeout</span>(timer);                timer = <span class="hljs-literal">null</span>;            &#125;            previous = now;            fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!timer) &#123;            <span class="hljs-comment">// 否则若处于等待时间内触发且前面的定时器被清除，那么会延迟执行，延迟时间即为剩余等待时间</span>            timer = <span class="hljs-built_in">setTimeout</span>(later, remain);        &#125;    &#125;;    <span class="hljs-keyword">return</span> throttled;&#125;</code></pre><h3 id="通过参数调整节流效果"><a class="markdownIt-Anchor" href="#通过参数调整节流效果"></a> 通过参数调整节流效果</h3><p>有时候我们希望节流效果为 “有头无尾”， 有时候希望是 “有尾无头”。</p><p>这样的话我们可以通过设置参数 <code>options</code> 来调整，约定：</p><ul><li><code>leading: false</code> ：表示禁用第一次执行</li><li><code>trailing: false</code> ：表示禁用停止触发的回调</li></ul><pre><code class="hljs js"><span class="hljs-comment">// 当设置了 leading 为 false 时，表示禁用第一次执行，当 trailing 为 false，表示禁用停止后的回调</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle3</span>(<span class="hljs-params">fn, wait, options=&#123;&#125;</span>) </span>&#123;    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>, previous = <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> later = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        timer = <span class="hljs-literal">null</span>;        <span class="hljs-comment">// leading 为 false 时，将 previous 设置为 0，那么每次触发时，remain 计算结果都会是 wait</span>        previous = options.leading === <span class="hljs-literal">false</span> ? <span class="hljs-number">0</span> : <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime();        fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);    &#125;;    <span class="hljs-keyword">let</span> throttled = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">let</span> now = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();        <span class="hljs-comment">// 当 leading 为 false 时，每次执行 fn，previous 都会被设置为 0，再加上初始时刻 previous = 0</span>        <span class="hljs-comment">// 就达到了取消第一次立即执行的效果，也就是会跳过接下来的第一个 if 判断，直接进行 timer 设置</span>        <span class="hljs-keyword">if</span> (options.leading === <span class="hljs-literal">false</span> &amp;&amp; !previous) &#123;            previous = now;        &#125;        <span class="hljs-keyword">let</span> remain = wait - (now - previous);        <span class="hljs-comment">// 否则，若设置 trailing 为 false ，第一次 remain 会小于 0，从而使 fn 立即执行</span>        <span class="hljs-comment">// 之后，在间隔时间之内(remain &gt; 0)，由于 trailing 为 false，因此下面延迟设置的判断进不去</span>        <span class="hljs-comment">// 从而达到每次只有当 remain 为 0 时，才会执行 fn，且在停止触发后，不会再延迟执行了</span>        <span class="hljs-keyword">if</span> (remain &lt;= <span class="hljs-number">0</span> || remain &gt; wait) &#123;            <span class="hljs-keyword">if</span> (timer) &#123;                <span class="hljs-built_in">clearTimeout</span>(timer);                timer = <span class="hljs-literal">null</span>;            &#125;            previous = now;            fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!timer &amp;&amp; options.trailing !== <span class="hljs-literal">false</span>) &#123;            timer = <span class="hljs-built_in">setTimeout</span>(later, remain);        &#125;    &#125;;    <span class="hljs-keyword">return</span> throttled;&#125;</code></pre><h3 id="设置取消功能"><a class="markdownIt-Anchor" href="#设置取消功能"></a> 设置取消功能</h3><p>与防抖中相似，当节流中需要等待很久才能进行下一次响应时，若想提前响应，可以使用 <code>cancel</code> 来取消：</p><pre><code class="hljs js">throttled.cancel = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">clearTimeout</span>(timeout);    previous = <span class="hljs-number">0</span>;    timer = <span class="hljs-literal">null</span>;&#125;;</code></pre><h3 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h3><p>在上面的带有 <code>options</code> 参数的实现中，<code>leading：false</code> 和 <code>trailing: false</code> 不能同时设置。</p><p>若同时设置的话，当将鼠标移出时，因为 <code>trailing</code> 设置为 <code>false</code> ，停止触发的时候不会设置定时器，所以只要再过了设置的时间，再移入的话，就会立即执行了，这就违反了 <code>leading: false</code> 的规则。因此，这个 <code>throttle</code> 只有三种使用方法：</p><pre><code class="hljs js"><span class="hljs-comment">// 1. 开始立即执行且停止触发后过一段时间会有一个回调</span>continer.onmousemove = throttle(getUserAction, <span class="hljs-number">1000</span>);<span class="hljs-comment">// 2. 取消开始时的立即执行</span>continer.onmousemove = throttle(getUserAction, <span class="hljs-number">1000</span>, &#123;    leading: <span class="hljs-literal">false</span>&#125;);<span class="hljs-comment">// 3. 取消停止时设置的回调</span>continer.onmousemove = throttle(getUserAction, <span class="hljs-number">1000</span>, &#123;    trailing: <span class="hljs-literal">false</span>&#125;);</code></pre><h2 id="场景"><a class="markdownIt-Anchor" href="#场景"></a> 场景</h2><ul><li>a、<code>scroll</code>事件：当页面发生滚动时，<code>scroll</code>事件会被频繁的触发，<code>1s</code>触发可高达上百次。在<code>scroll</code>事件中，如果有复杂的操作（特别是影响布局的操作），将会大大影响性能，甚至导致浏览器崩溃。所以，对其进行防抖、限频很重要。</li><li>b、<code>click</code>事件：用户进行<code>click</code>事件时，有可能连续触发点击（用户本意并非双击）。该操作有可能是不小心多次连续点击，也可能是页面状况不好的情况下，期待尽快得到反馈的有意行为；但这样的操作，反而会加剧性能问题，因此也有必要考虑防抖、限频。</li><li>c、<code>input</code>事件：如<code>sug</code>等需要通过<code>ajax</code>及时获得数据的情况，需要进行限频，防止频繁的请求发生，减少服务器压力的同时，提高页面响应性能。</li><li>d、<code>touchmove</code>事件：同<code>scroll</code>事件类似。</li></ul><h3 id="防抖-2"><a class="markdownIt-Anchor" href="#防抖-2"></a> 防抖</h3><p>  示例：有一个 <code>input</code> 框，当在 <code>input</code> 框中输入时，会调用 <code>sayHi</code> 函数打印一句话，而对于输入框来说，输入会很频繁，如连续输入 <code>12345</code>，这样会调用 <code>5</code> 次 <code>sayHi</code> 函数，但实际上我们只想输入一串 <code>12345</code> 并调用一次，这时 <code>debounce</code> 函数就派上用场了，当连续输入时，输入的间隔会很小，因此若在规定的时间间隔内再次输入，会重新计时，然后最后当输入结束时在调用一次 <code>sayHi</code>。</p><p>  诸如此类的事件还有：当页面的滚动条发生滚动 &amp; 当前窗口的大小发生改变 &amp; 当输入框的内容发生改变…</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;debounce success!&#x27;</span>);&#125;<span class="hljs-keyword">let</span> inp = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;input&#x27;</span>);<span class="hljs-built_in">document</span>.body.appendChild(inp);inp.addEventListener(<span class="hljs-string">&#x27;input&#x27;</span>, debounce(sayHi));</code></pre><h3 id="节流-2"><a class="markdownIt-Anchor" href="#节流-2"></a> 节流</h3><p>  示例：当窗口进行缩放时，一秒内只会执行一次打印窗口大小的函数。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params">e</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(e.target.innerWidth, e.target.innerHeight);&#125;<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;resize&#x27;</span>, throttle(sayHi));</code></pre><h1 id="3-this-指向问题"><a class="markdownIt-Anchor" href="#3-this-指向问题"></a> 3. this 指向问题</h1><p>  试说出程序的输出：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> number = <span class="hljs-number">10</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.number);&#125;<span class="hljs-keyword">var</span> obj = &#123;    number: <span class="hljs-number">2</span>,    show: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) </span>&#123;        <span class="hljs-built_in">this</span>.number = <span class="hljs-number">3</span>;        fn();        <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]();    &#125;&#125;;obj.show(fn);</code></pre><p>  首先，在 <code>obj</code> 中调用了 <code>show</code> 函数，因此 <code>show</code> 函数中的 <code>this</code> 指向会是 <code>obj</code>，此时， <code>show</code> 函数调用了传入的 <code>fn</code> 函数，<code>fn</code> 函数是位于全局变量中的，因此 <code>fn</code> 中的 <code>this</code> 指向了全局变量，<code>console.log()</code> <strong>输出 <code>10</code></strong>，若想要正确打印 <code>3</code>，那么可以修改为：<code>fn.bind(this)();</code></p><p>  然后，<code>arguments</code> 为 <code>show</code> 函数中的参数列表，第一个参数是 <code>fn</code>（调用相当于是 <code>arguments.0()</code>，类似于 <code>obj.show</code>），因此此时 <code>fn</code> 中的 <code>this</code> 是指向 <code>arguments</code> 对象的，但 <code>arguments</code> 对象中没有定义 <code>number</code> 变量，因此<strong>输出 <code>undefined</code></strong>。</p><p>  稍微修改一下：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;this in fn: &#x27;</span>, <span class="hljs-built_in">this</span>);&#125;<span class="hljs-keyword">var</span> obj = &#123;    show: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;this in show: &#x27;</span>, <span class="hljs-built_in">this</span>);        fn();        <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]();    &#125;&#125;;obj.show(fn);</code></pre><p>  根据我们上面的分析，打印的结果会是：</p><p>1.<code>this in show:</code> + <code>obj 对象</code></p><p>2.<code>this in fn:</code> + <code>全局对象</code></p><p>3.<code>this in fn:</code> + <code>arguments 对象</code></p><h1 id="promise-及-settimeout-执行顺序"><a class="markdownIt-Anchor" href="#promise-及-settimeout-执行顺序"></a> promise 及 setTimeout 执行顺序</h1><p>  有代码如下：</p><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);&#125;, <span class="hljs-number">0</span>);<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res, rej</span>) </span>&#123;    res(<span class="hljs-number">2</span>);    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">0</span>); &#125;).then(<span class="hljs-built_in">console</span>.log);<span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);</code></pre><p>  首先，对于 <code>setTimeout</code> 任务来说，它会被排到执行队列的尾部，同步任务执行完后立即执行这个任务；</p><p>  而 <code>promise</code> 一旦建立，其中的任务就会立即执行，因此会<strong>先输出 <code>0</code></strong>，然后是最外层的 <code>console.log(3)</code> 为同步任务，会按顺序执行，因此<strong>第二个输出 <code>3</code></strong>，然后再执行 <code>promise.then</code> ，即打印 <code>2</code>。</p><p>因此打印顺序为：<code>0 -&gt; 3 -&gt; 2 -&gt; 1</code>。</p><h1 id="微任务和宏任务"><a class="markdownIt-Anchor" href="#微任务和宏任务"></a> 微任务和宏任务</h1><p><a href="https://www.cnblogs.com/wangziye/p/9566454.html">REF1</a></p><p><a href="https://www.jianshu.com/p/bfc3e319a96b">REF2</a></p><h2 id="event-loop"><a class="markdownIt-Anchor" href="#event-loop"></a> Event Loop</h2><p>事件循环中，每一次循环称为 <code>tick</code>，每一次 <code>tick</code> 的任务如下：</p><ul><li>执行栈选择最先进入队列的宏任务（一般都是 <code>script</code>），执行其同步代码直至结束</li><li>检查是否存在微任务，若存在，则执行微任务至微任务队列为空</li><li>若为浏览器环境中，可能会渲染 UI</li><li>开始下一轮 <code>tick</code>，执行宏任务中的异步代码（<code>setTimeout</code> 等回调）</li></ul><p>  通过上面的执行步骤可知，<strong>如果宏任务中的异步代码有大量的计算且需要操作 DOM 的话，为了更快的界面响应，可以把操作放入微任务中</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost@master/img/image-20201221141223934.png" alt="image-20201221141223934" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost@master/img/image-20201221142300760.png" alt="image-20201221142300760" style="zoom:80%;" /></p><h2 id="微任务和宏任务-2"><a class="markdownIt-Anchor" href="#微任务和宏任务-2"></a> 微任务和宏任务</h2><p>ES6 规范中，microtask(微任务) 称为 <code>jobs</code>，macrotask(宏任务) 称为 <code>task</code></p><p><strong>宏任务</strong>是由宿主发起的，而<strong>微任务</strong>由JavaScript自身发起。</p><table><thead><tr><th></th><th>宏任务（macrotask)</th><th>微任务（microtask）</th></tr></thead><tbody><tr><td>谁发起的</td><td>宿主（Node、浏览器）</td><td>JS 引擎</td></tr><tr><td>具体事件</td><td>1. script（外层的同步代码）                                                      2.setTimeout/setInterval                                                                                                 3.UI rendering/UI 事件                                                                                     4.postMessage，MessageChannel                                                                                      5.setImmediate，I/O （Node.js）</td><td>1.Promise                       2.<a href="https://javascript.ruanyifeng.com/dom/mutationobserver.html">MutaionObserver</a>          3.Proxy 对象                                        4.process.nextTick（Node.js）</td></tr><tr><td>谁先运行</td><td>后运行</td><td>先运行</td></tr><tr><td>是否会触发新一轮 Tick</td><td>会</td><td></td></tr></tbody></table><p>  宏任务包括 <code>script</code>、<code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code>、<code>I/O</code>、<code>UI rendering</code></p><p>  微任务包括 <code>process.nextTick</code>、<code>promise</code>、<code>Object.observe</code>、<code>MutationObserver</code></p><p>而 <code>async、await</code> 相当于是对 <code>Promise</code> 的封装，因此执行顺序和 <code>Promise</code> 相似：</p><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">await</span> async2()  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async1 end&#x27;</span>)&#125;<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async2</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async2 end&#x27;</span>)&#125;async1()<span class="hljs-comment">// 使用 Promise 的写法</span><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async2 end&#x27;</span>)  resolve()&#125;).then(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">// 执行async1()函数await之后的语句</span>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async1 end&#x27;</span>)&#125;)</code></pre><h1 id="es5es6-的继承除了写法上还有什么差异"><a class="markdownIt-Anchor" href="#es5es6-的继承除了写法上还有什么差异"></a> ES5/ES6 的继承除了写法上还有什么差异</h1><p>在 ES6 中，子类可以通过 <code>__proto__</code> 寻址到父类，而通过 ES5 的方式，<code>Sub.__proto__ === Function.prototype</code>。</p><p><strong>ES6：</strong></p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Super</span> </span>&#123;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Super</span> </span>&#123;&#125;<span class="hljs-keyword">const</span> sub = <span class="hljs-keyword">new</span> Sub();<span class="hljs-built_in">console</span>.log(Sub.__proto__ === Super); <span class="hljs-comment">// true</span></code></pre><p><strong>ES5：</strong></p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Super</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Sub</span>(<span class="hljs-params"></span>) </span>&#123;&#125;Sub.prototype = <span class="hljs-keyword">new</span> Super();Sub.prototype.constructor = Sub;<span class="hljs-keyword">const</span> sub = <span class="hljs-keyword">new</span> Sub();<span class="hljs-built_in">console</span>.log(Sub.__proto__ === <span class="hljs-built_in">Function</span>.prototype); <span class="hljs-comment">// true</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>前端面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS 面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Set、Map、和WeakSet、WeakMap</title>
    <link href="/2020/12/09/JS/Set%E3%80%81Map%E3%80%81%E5%92%8CWeakSet%E3%80%81WeakMap/"/>
    <url>/2020/12/09/JS/Set%E3%80%81Map%E3%80%81%E5%92%8CWeakSet%E3%80%81WeakMap/</url>
    
    <content type="html"><![CDATA[<p>转载于 <a href="https://github.com/sisterAn/blog/issues/24">sisterAn/blog</a></p><h1 id="集合set"><a class="markdownIt-Anchor" href="#集合set"></a> 集合（Set）</h1><p><code>Set</code> 是 ES6 新增的数据结构，类似于数组，但其成员是唯一无序的，没有重复的值。</p><p><code>Set</code> 对象可根据 <code>iterable</code> 对象来创建：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<span class="hljs-keyword">let</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(arr); <span class="hljs-comment">// Set(4) &#123;1, 2, 3, 4&#125;</span><span class="hljs-comment">// 数组去重</span><span class="hljs-keyword">let</span> uniArr = [...s];<span class="hljs-comment">// [1, ,2, 3, 4]</span></code></pre><p><code>Set</code> 对象允许存储任何类型的唯一值，<strong>无论是基本数据类型的值还是对象引用</strong>。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]); <span class="hljs-comment">// 存储值 1 和 2</span><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>&#125;;<span class="hljs-keyword">let</span> obj2 = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>&#125;;<span class="hljs-keyword">let</span> obj3 = obj;s.add(obj);s.add(obj2); <span class="hljs-comment">// 两个对象引用不同，因此能正常存储</span>s.add(obj3); <span class="hljs-comment">// 引用与 obj 相同，无法存储</span></code></pre><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost@master/img/image-20201209203523436.png" alt="image-20201209203523436" style="zoom:80%;" /><p>向  <code>Set</code> 中加入值时，不会发生类型转换，因此 <code>5</code> 和 <code>&quot;5&quot;</code> 是两个不同的值（ <code>Object</code> 中键 的存储都会转为字符串）</p><p>Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于<strong>精确相等</strong>运算符（<code>===</code>），主要的区别是<strong>Set 认为<code>NaN</code>等于自身，而精确相等运算符认为<code>NaN</code>不等于自身。</strong></p><pre><code class="hljs js"><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<span class="hljs-keyword">let</span> a = <span class="hljs-literal">NaN</span>;<span class="hljs-keyword">let</span> b = <span class="hljs-literal">NaN</span>;set.add(a);set.add(b);set <span class="hljs-comment">// Set &#123;NaN&#125;</span><span class="hljs-keyword">let</span> set1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()set1.add(<span class="hljs-number">5</span>)set1.add(<span class="hljs-string">&#x27;5&#x27;</span>)<span class="hljs-built_in">console</span>.log([...set1])<span class="hljs-comment">// [5, &quot;5&quot;]</span></code></pre><h2 id="set-实例属性"><a class="markdownIt-Anchor" href="#set-实例属性"></a> Set 实例属性</h2><h3 id="constructor"><a class="markdownIt-Anchor" href="#constructor"></a> constructor</h3><p>构造函数</p><h3 id="size"><a class="markdownIt-Anchor" href="#size"></a> size</h3><p>元素数量</p><p>注意不是 <code>length</code></p><pre><code class="hljs js"><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>])<span class="hljs-built_in">console</span>.log(set.length)<span class="hljs-comment">// undefined</span><span class="hljs-built_in">console</span>.log(set.size)<span class="hljs-comment">// 3</span></code></pre><h2 id="set-实例方法"><a class="markdownIt-Anchor" href="#set-实例方法"></a> Set 实例方法</h2><h3 id="操作方法"><a class="markdownIt-Anchor" href="#操作方法"></a> 操作方法</h3><ul><li><code>add(value)</code>：向集合中添加新元素</li><li><code>delete(value)</code>：从集合中移除元素</li><li><code>has(value)</code>：判断集合中是否存在某个元素</li><li><code>clear()</code>：情况集合</li></ul><h3 id="遍历方法"><a class="markdownIt-Anchor" href="#遍历方法"></a> 遍历方法</h3><p>遍历属性为插入顺序。</p><ul><li><p><code>keys()</code>：返回一个包含集合中所有键的迭代器</p></li><li><p><code>values()</code>：返回一个包含集合中所有值的迭代器</p></li><li><p><code>entries()</code>：返回一个包含集合中所有元素的键值对的迭代器</p></li><li><p><code>forEach(callback, thisArg)</code>：对集合中的元素执行 <code>callback</code> 操作，若提供了 <code>thisArg</code> 参数，回调中的 <code>this</code> 会是这个值。</p><p><code>Set</code> 中没有什么键值之分，键 和 值都是 <code>Set</code> 中的元素。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>, &#123;<span class="hljs-attr">i</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">j</span>: <span class="hljs-number">4</span>&#125;]);</li></ul><p><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'keys: '</span>, s.keys());</p><p><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'values: '</span>, s.values());</p><p><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'entries: '</span>, s.entries());</code></pre>:hexoPostRenderEscape–&gt;</p>  <img src="https://cdn.jsdelivr.net/gh/yleave/imagehost@master/img/image-20201210140730077.png" alt="image-20201210140730077" style="zoom:80%;" /><p>注意到这几个方法返回的都是一个迭代器，因此可以使用 <code>next</code> 方法来遍历：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> iter = s.keys();<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;    <span class="hljs-keyword">let</span> item = iter.next();    <span class="hljs-keyword">if</span> (item.done) &#123;        <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-built_in">console</span>.log(item);&#125;</code></pre><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost@master/img/image-20201210144517054.png" alt="image-20201210144517054" style="zoom:80%;" /><p>还可使用 <code>for ··· of</code> 来遍历：</p><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> s.keys()) &#123;    <span class="hljs-built_in">console</span>.log(item); &#125;<span class="hljs-comment">// 返回结果相同</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> s) &#123;    <span class="hljs-built_in">console</span>.log(item);&#125;s.forEach(<span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span>  &#123;    <span class="hljs-built_in">console</span>.log(key + <span class="hljs-string">&#x27; : &#x27;</span> + value)&#125;)</code></pre><p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost@master/img/image-20201210144632720.png" alt="image-20201210144632720" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost@master/img/image-20201210144803339.png" alt="image-20201210144803339" style="zoom:80%;" /></p><p><code>Set</code> 可使用 <code>map</code> 、<code>filter</code> 方法：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...set].map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item * <span class="hljs-number">2</span>))<span class="hljs-built_in">console</span>.log([...set])<span class="hljs-comment">// [2, 4, 6]</span>set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...set].filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> (item &gt;= <span class="hljs-number">4</span>)))<span class="hljs-built_in">console</span>.log([...set])<span class="hljs-comment">//[4, 6]</span></code></pre><p>因此，Set 很容易实现<strong>交集</strong>（Intersect）、<strong>并集</strong>（Union）、<strong>差集</strong>（Difference）</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> s1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<span class="hljs-keyword">let</span> s2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);<span class="hljs-keyword">let</span> union = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...s1, ...s2]);<span class="hljs-built_in">console</span>.log(union); <span class="hljs-comment">// Set(4) &#123;1, 2, 3, 4&#125;</span><span class="hljs-keyword">let</span> intersect = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...s1].filter(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> s2.has(val)));<span class="hljs-built_in">console</span>.log(intersect); <span class="hljs-comment">// Set(2) &#123;2, 3&#125;</span><span class="hljs-keyword">let</span> difference = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...s1].filter(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> !s2.has(val)));<span class="hljs-built_in">console</span>.log(difference); <span class="hljs-comment">// Set(1) &#123;1&#125;</span></code></pre><h1 id="weakset"><a class="markdownIt-Anchor" href="#weakset"></a> WeakSet</h1><p><code>WeakSet</code> 对象允许你将<strong>弱引用对象</strong>储存在一个集合中</p><p><code>WeakSet</code> 与 <code>Set</code> 的区别：</p><ul><li><code>WeakSet</code> 只能储存对象引用，不能存放值，而 <code>Set</code> 对象都行。</li><li><code>WeakSet</code> 对象中储存的对象值都是被弱引用的，即<strong>垃圾回收机制不考虑 <code>WeakSet</code> 对该对象的引用</strong>，如果没有其他变量或属性引用这个对象，那么这个对象会被回收掉。所以， <code>WeakSet</code> 对象中有多少个成员，取决于垃圾回收机制有没有进行回收，回收后成员个数可能不一样（被垃圾回收了），<code>WeakSet</code> 对象是无法被遍历的（ES6规定），也没有办法拿到它所包含的所有元素。</li></ul><p>成员都是弱引用，可以被垃圾回收机制回收，<strong>可以用来保存DOM节点，不容易造成内存泄漏</strong></p><p><strong>weakSet</strong>可以用来保存DOM节点， 当节点被删除， <strong>weakSet</strong>里面的该节点如果不存在别的引用的话， 一段时间内会被内存回收；</p><p>为了验证弱引用机制，先输出一次 <code>weakset</code>，然后在 <code>10</code> 秒后再输出一次，可以看到，为被其他变量引用的 <code>[1, 2]</code> 就被垃圾回收了：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<span class="hljs-keyword">let</span> wks = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakSet</span>([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], a]);<span class="hljs-built_in">console</span>.log(wks);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(wks);&#125;, <span class="hljs-number">10000</span>)</code></pre><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost@master/img/image-20201210150658051.png" alt="image-20201210150658051" style="zoom:80%;" /><p>同时根据上图可看到 <code>WeakSet</code> 中的方法：<code>add(value)</code>、<code>has(value)</code>、<code>delete(value)</code> 和构造器方法 <code>constructor</code></p><h1 id="字典-map"><a class="markdownIt-Anchor" href="#字典-map"></a> 字典 Map</h1><p>集合<code>set</code> 与字典 <code>map</code> 的区别：</p><ul><li>共同点：都可以存储<strong>不重复</strong>的值</li><li>不同点：集合是以 <code>[value, value]</code> 的方式存储，而字典是以 <code>[key, value]</code> 的方式存储，因此字典可以根据 <code>key</code> 来快速的获取其对应的 <code>value</code>。</li></ul><pre><code class="hljs js"><span class="hljs-keyword">let</span> mp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();mp.set(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>);mp.set(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>);mp.set(&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;, <span class="hljs-number">3</span>);<span class="hljs-built_in">console</span>.log(mp);</code></pre><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost@master/img/image-20201210151834885.png" alt="image-20201210151834885" style="zoom:80%;" /><p>如何具有 <code>Iterator</code> 接口，且每个成员都是一个双元素的数组的数据结构都可以当作 <code>Map</code> 构造函数的参数，如：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([[<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-number">1</span>], [<span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-number">2</span>]]);<span class="hljs-built_in">console</span>.log(set);<span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(set);<span class="hljs-built_in">console</span>.log(map);<span class="hljs-keyword">let</span> m1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-number">1</span>], [<span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-number">2</span>]]);<span class="hljs-keyword">let</span> m2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(m1);</code></pre><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost@master/img/image-20201210152321089.png" alt="image-20201210152321089" style="zoom:80%;" /><p>若 <code>map</code> 的键是一个对象，那么会根据对象的引用来判断是否是同一个对象，且 <code>NaN</code> 虽然不严格相等于自身，但 <code>map</code> 将其视为同一个键。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();map.set([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-string">&#x27;a&#x27;</span>);map.set([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-string">&#x27;b&#x27;</span>);map.set(<span class="hljs-literal">NaN</span>, <span class="hljs-string">&#x27;c&#x27;</span>);map.set(<span class="hljs-literal">NaN</span>, <span class="hljs-string">&#x27;d&#x27;</span>);<span class="hljs-built_in">console</span>.log(map);</code></pre><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost@master/img/image-20201210153059720.png" alt="image-20201210153059720" style="zoom:80%;" /><h2 id="map-的属性"><a class="markdownIt-Anchor" href="#map-的属性"></a> Map 的属性</h2><h3 id="constructor"><a class="markdownIt-Anchor" href="#constructor"></a> constructor</h3><h3 id="size-2"><a class="markdownIt-Anchor" href="#size-2"></a> size</h3><p>字典中所包含元素的个数</p><h2 id="操作方法-2"><a class="markdownIt-Anchor" href="#操作方法-2"></a> 操作方法</h2><ul><li><code>set(key, value)</code> ：向字典中添加元素</li><li><code>get(key)</code>：通过键来查找对于的值</li><li><code>has(key)</code>：判断字典中是否存在键值对</li><li><code>delete(key)</code>：通过 <code>key</code> 从字典中移除对应键值对</li><li><code>clear()</code>：将字典清空</li></ul><h2 id="遍历方法-2"><a class="markdownIt-Anchor" href="#遍历方法-2"></a> 遍历方法</h2><ul><li><p><code>keys()</code>：将字典中的所有键以迭代器的形式返回</p></li><li><p><code>values()</code>：将字典中的所有值以迭代器的形式返回</p></li><li><p><code>entries()</code>：将字典中的所有键值对以迭代器的方式返回</p></li><li><p><code>forEach()</code>：遍历字典中的所有成员</p></li><li><p><code>for···of</code> ：遍历字典中的所有成员</p></li></ul><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> map) &#123;    <span class="hljs-built_in">console</span>.log(item); <span class="hljs-comment">// item 是一个数组</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;key: &#x27;</span>, item[<span class="hljs-number">0</span>], <span class="hljs-string">&#x27;value: &#x27;</span>, item[<span class="hljs-number">1</span>]);&#125;</code></pre><h2 id="与其他数据结构的相互转换"><a class="markdownIt-Anchor" href="#与其他数据结构的相互转换"></a> 与其他数据结构的相互转换</h2><h3 id="map-转-array"><a class="markdownIt-Anchor" href="#map-转-array"></a> map 转 array</h3><pre><code class="hljs js"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>]])<span class="hljs-built_in">console</span>.log([...map])<span class="hljs-comment">// [[1, 1], [2, 2], [3, 3]]</span></code></pre><h3 id="array-转-map"><a class="markdownIt-Anchor" href="#array-转-map"></a> array 转 map</h3><pre><code class="hljs js"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>]])<span class="hljs-built_in">console</span>.log(map)<span class="hljs-comment">// Map &#123;1 =&gt; 1, 2 =&gt; 2, 3 =&gt; 3&#125;</span></code></pre><h3 id="map-转-object"><a class="markdownIt-Anchor" href="#map-转-object"></a> map 转 object</h3><p>因为 <code>Object</code>的键名都为字符串，而<code>Map</code>的键名为对象，所以<strong>转换的时候会把非字符串键名转换为字符串键名</strong>。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();map.set(<span class="hljs-string">&#x27;️⚽️&#x27;</span>, <span class="hljs-string">&#x27;soccer&#x27;</span>);map.set(<span class="hljs-string">&#x27;⚾️&#x27;</span>, <span class="hljs-string">&#x27;baseball&#x27;</span>);map.set(<span class="hljs-string">&#x27;?&#x27;</span>, <span class="hljs-string">&#x27;tennis&#x27;</span>);</code></pre><h4 id="方法-1"><a class="markdownIt-Anchor" href="#方法-1"></a> 方法 1</h4><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = <span class="hljs-built_in">Array</span>.from(map).reduce(<span class="hljs-function">(<span class="hljs-params">obj, [key, value]</span>) =&gt;</span> <span class="hljs-built_in">Object</span>.assign(obj, &#123; [key] : value &#125;), &#123;&#125;);</code></pre><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost@master/img/image-20201210210723884.png" alt="image-20201210210723884" style="zoom:80%;" /><p>首先，<code>Array.from(map)</code>，会变成这样：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost@master/img/image-20201210211724893.png" alt="image-20201210211724893" style="zoom:80%;" /><p>然后，在 <code>reduce</code> 回调函数中每次将新的键值对加入到 <code>&#123;&#125;</code> 中。</p><p>不过这种方式在数据量过大的时候，在每个迭代器中创建一个新对象（<code>Object.assign</code>）时，性能会受到影响。</p><h4 id="方法-2"><a class="markdownIt-Anchor" href="#方法-2"></a> 方法 2</h4><p>方法 2 优化了方法 1 中的性能影响：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = <span class="hljs-built_in">Array</span>.from(map).reduce(<span class="hljs-function">(<span class="hljs-params">obj, [key, value]</span>) =&gt;</span> &#123;    obj[key] = value;    <span class="hljs-keyword">return</span> obj;&#125;, &#123;&#125;);</code></pre><p>使用 <code>Array.from(map).reduce(fn, &#123;&#125;)</code>，可以安全的在累加器中操作 <code>object</code></p><h4 id="方法-3"><a class="markdownIt-Anchor" href="#方法-3"></a> 方法 3</h4><p>使用拓展运算符<code>...</code>来替换 <code>Array.from</code>：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = [...map.entries()].reduce(<span class="hljs-function">(<span class="hljs-params">obj, [key, value]</span>) =&gt;</span> (obj[key] = value, obj), &#123;&#125;)</code></pre><p><strong>经过测试，效率上：方法 3 &gt; 方法2 &gt; 方法1</strong></p><h3 id="object-转-map"><a class="markdownIt-Anchor" href="#object-转-map"></a> object 转 map</h3><pre><code class="hljs js"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(obj)) &#123;    map.set(key, value);&#125;</code></pre><h3 id="map-转-json"><a class="markdownIt-Anchor" href="#map-转-json"></a> map 转 JSON</h3><pre><code class="hljs js"><span class="hljs-keyword">const</span> json = <span class="hljs-built_in">JSON</span>.stringify([...map]);<span class="hljs-comment">// [[&quot;️⚽️&quot;,&quot;soccer&quot;],[&quot;⚾️&quot;,&quot;baseball&quot;],[&quot;?&quot;,&quot;tennis&quot;]]</span><span class="hljs-built_in">console</span>.log(json)</code></pre><h3 id="json-转-map"><a class="markdownIt-Anchor" href="#json-转-map"></a> JSON 转 map</h3><pre><code class="hljs js"><span class="hljs-keyword">const</span> json = <span class="hljs-string">&#x27;[[&quot;️⚽️&quot;,&quot;soccer&quot;],[&quot;⚾️&quot;,&quot;baseball&quot;],[&quot;?&quot;,&quot;tennis&quot;]]&#x27;</span>;<span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(<span class="hljs-built_in">JSON</span>.parse(json)); <span class="hljs-comment">//数组对象</span><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(<span class="hljs-built_in">JSON</span>.parse(objectToMap(json))) <span class="hljs-comment">// 普通对象 &#123;&quot;a&quot;:1,&quot;b&quot;:2&#125;</span></code></pre><h1 id="weakmap"><a class="markdownIt-Anchor" href="#weakmap"></a> WeakMap</h1><p><code>WeakMap</code> 对象与 <code>Map</code> 对象类似，是一组键值对的集合，区别是其中的<strong>键是弱引用对象，而值可以是任意</strong></p><p>与 <code>WeakSet</code> 中相同，<code>WeakMap</code> 中存在的键值对与垃圾回收机制有关，若存储在 <code>WeakMap</code> 中的键是一个对象且没有被其他变量或属性引用，那么会被垃圾回收机制回收。因此 <code>WeakMap</code> 中的 <code>key</code> 也是无法枚举的。</p><h2 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h2><ul><li><code>has(key)</code></li><li><code>get(key)</code></li><li><code>set(key, value)</code></li><li><code>delete(key)</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>Map</tag>
      
      <tag>WeakMap</tag>
      
      <tag>Set</tag>
      
      <tag>WeakSet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>知识点杂记</title>
    <link href="/2020/12/09/JS/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%9D%82%E8%AE%B0/"/>
    <url>/2020/12/09/JS/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%9D%82%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="null-和-undefined"><a class="markdownIt-Anchor" href="#null-和-undefined"></a> null 和 undefined</h1><p>在 JS 中，将一个变量赋值为 <code>null</code> 和 <code>undefined</code> 几乎没有什么区别，它们都是虚值（falsy），在判断语句中都会被转为 <code>false</code>。</p><p>虽然它们非常类似，但是还是有一些区别的：</p><h2 id="null"><a class="markdownIt-Anchor" href="#null"></a> null</h2><p><code>null</code> 表示 <strong>没有对象</strong>，即该处没有值。典型的用法是：</p><ol><li><p>作为函数的参数，表示该函数的参数不是对象。</p></li><li><p>作为对象原型链的终点</p><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.getPrototype(<span class="hljs-built_in">Object</span>.prototype); <span class="hljs-comment">// null</span></code></pre></li></ol><h2 id="undefined"><a class="markdownIt-Anchor" href="#undefined"></a> undefined</h2><p><code>undefined</code> 表示 <strong>缺少值</strong>，即是此处可能会有一个值，但是还没有定义。典型语法是：</p><ol><li>变量被声明了，但是没有复制时，就等于 <code>undefined</code></li><li>调用函数时，应该提供的参数没有提供，该参数就等于 <code>undefined</code></li><li>对象没有赋值的属性，该属性的值为 <code>undefined</code></li><li>函数没有返回值时，默认返回 <code>undefined</code></li></ol><pre><code class="hljs js"><span class="hljs-keyword">var</span> i;i <span class="hljs-comment">// undefined</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">x</span>)</span>&#123;<span class="hljs-built_in">console</span>.log(x)&#125;f() <span class="hljs-comment">// undefined</span><span class="hljs-keyword">var</span>  o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();o.p <span class="hljs-comment">// undefined</span><span class="hljs-keyword">var</span> x = f();x <span class="hljs-comment">// undefined</span></code></pre><h2 id="综合讨论"><a class="markdownIt-Anchor" href="#综合讨论"></a> 综合讨论</h2><p>综上，我们可以知道：</p><ul><li><strong><code>null</code> 表示一个值被定义了，定义为 &quot;空值&quot;</strong></li><li><strong><code>undefined</code> 表示一个不存在的定义</strong></li></ul><p>因此设置一个值为 <code>null</code> 是合理的，如：<code>obj.val = null;</code></p><p>但是设置一个值为 <code>undefined</code> 是不合理的，如 <code>obj.val = undefined;</code>，因为在我们定义 <code>obj.val</code> 之前，我们调用 <code>obj.val</code> 同样能够得到 <code>undefined</code>，这样做不是多此一举了吗。</p><p>因此，任何一个<strong>存在引用</strong>的变量值为 <code>undefined</code> 都是一件错误的事。</p><p>这样，判断一个值是否存在，就可以使用 <code>obj.val === undefined</code>。</p><p>在一些使用广泛的库（比如jQuery）中的深度拷贝函数会忽略 <code>undefined</code> 而不会忽略 <code>null</code> ，也是针对这个语义的理解。</p><hr /><p>REF：<a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html">阮一峰博客</a></p><h1 id="this-指向"><a class="markdownIt-Anchor" href="#this-指向"></a> this 指向</h1><p>函数的调用方式决定了 <code>this</code> 的值（<strong>运行时绑定</strong>）。</p><p>ES5 引入了 <code>bind</code> 方法来设置函数的 <code>this</code> 的值，ES2015 引入了箭头函数，箭头函数不提供自身的 <code>this</code> 绑定，<code>this</code> 的值将保持为闭合词法上下文的值。</p><p>可以使用 <code>globalThis</code> 来获取全局对象，无论代码是否在当前上下文中运行。</p><h2 id="函数上下文"><a class="markdownIt-Anchor" href="#函数上下文"></a> 函数上下文</h2><p>在函数内部，<code>this</code>的值取决于函数被调用的方式。</p><p>在严格模式下，如果进入执行环境时没有设置 <code>this</code> 的值，<code>this</code> 会保持为 <code>undefined</code>，如：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-meta">    &quot;use strict&quot;</span>;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;&#125;f2() === <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// true</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;&#125;f1() === <span class="hljs-built_in">window</span>; <span class="hljs-comment">// 在浏览器中，全局对象是 window</span>f1() === globalThis; <span class="hljs-comment">// 在 Node 中</span></code></pre><h2 id="类上下文"><a class="markdownIt-Anchor" href="#类上下文"></a> 类上下文</h2><p><code>this</code> 在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes">类</a> 中的表现与在函数中类似，因为类本质上也是函数。</p><p>在类的构造器中， <code>this</code> 是一个常规对象。类中所有非静态的方法都会被添加到 <code>this</code> 的原型中：</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span> </span>&#123;    <span class="hljs-keyword">constructor</span>() &#123;        <span class="hljs-keyword">const</span> proto = <span class="hljs-built_in">Object</span>.getPrototypeOf(<span class="hljs-built_in">this</span>);        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getOwnPropertyNames(proto));    &#125;    first() &#123;&#125;    second() &#123;&#125;    <span class="hljs-keyword">static</span> third() &#123;&#125;&#125;<span class="hljs-keyword">new</span> Example(); <span class="hljs-comment">// [&#x27;constructor&#x27;, &#x27;first&#x27;, &#x27;second&#x27;]</span></code></pre><h2 id="箭头函数"><a class="markdownIt-Anchor" href="#箭头函数"></a> 箭头函数</h2><p>在箭头函数中，<code>this</code> 与封闭词法环境的 <code>this</code> 保持一致，且一旦设置，就不会被 <code>call</code>、<code>bind</code>、<code>apply</code> 等方法修改。</p><p>如：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo1</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;&#125;<span class="hljs-keyword">let</span> foo2 = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">this</span>;<span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">foo1</span>: foo1, <span class="hljs-attr">foo2</span>: foo2&#125;;<span class="hljs-comment">//foo1 返回的 this 为 obj，foo2 返回的 this 为全局对象，因为函数是根据执行的对象来绑定 this 的，而箭头函数是创建的时候就绑定了上下文环境</span><span class="hljs-built_in">console</span>.log(obj.foo1(), obj.foo2());</code></pre><pre><code class="hljs js"><span class="hljs-comment">// obj 对象中有一个 foo 方法，这个方法中使用了箭头函数返回了一个 this</span><span class="hljs-comment">// 因此箭头函数返回的这个 this 被绑定到了外层函数的 this</span><span class="hljs-comment">// 而 foo 的值可以在调用中设置，进而设置返回的 this</span><span class="hljs-keyword">let</span> obj = &#123;    foo: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">let</span> x = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">this</span>;        <span class="hljs-keyword">return</span> x;    &#125;&#125;<span class="hljs-comment">// 作为 obj 对象的一个方法来调用，它的 this 会绑定到 obj 上</span><span class="hljs-keyword">let</span> fn = obj.foo(); <span class="hljs-comment">// fn === obj</span><span class="hljs-comment">// 但是，若只是引用 obj 方法，没有调用它</span><span class="hljs-keyword">let</span> fn2 = obj.foo;<span class="hljs-comment">// 那么调用箭头函数后，this 指向 window，因为它从 foo 继承了this。</span>fn2() === <span class="hljs-built_in">window</span>; <span class="hljs-comment">// true</span></code></pre><h2 id="作为构造函数"><a class="markdownIt-Anchor" href="#作为构造函数"></a> 作为构造函数</h2><p>当一个函数用作构造函数时（使用 <code>new</code> 关键字），它的 <code>this</code> 被绑定到正在构造的新对象。</p><h2 id="作为一个-dom-事件处理函数"><a class="markdownIt-Anchor" href="#作为一个-dom-事件处理函数"></a> 作为一个 DOM 事件处理函数</h2><p>当函数被用作事件处理函数时，它的 <code>this</code> 指向触发事件的元素。</p><h2 id="作为一个内联事件处理函数"><a class="markdownIt-Anchor" href="#作为一个内联事件处理函数"></a> 作为一个内联事件处理函数</h2><p>当代码被内联 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/Events/Event_handlers">on-event 处理函数</a> 调用时，它的<code>this</code>指向监听器所在的DOM元素：</p><pre><code class="hljs js">&lt;button onclick=<span class="hljs-string">&quot;alert(this.tagName.toLowerCase());&quot;</span>&gt;  Show <span class="hljs-built_in">this</span>&lt;/button&gt;</code></pre><p>上面的 alert 会显示 <code>button</code>。</p><p>注意只有外层代码中的 <code>this</code> 是这样设置的：</p><pre><code class="hljs js">&lt;button onclick=<span class="hljs-string">&quot;alert((function()&#123;return this&#125;)());&quot;</span>&gt;  Show inner <span class="hljs-built_in">this</span>&lt;/button&gt;</code></pre><p>在这种情况下，没有设置内部函数的 <code>this</code>，所以它指向<code>global/window</code> 对象（即非严格模式下调用的函数未设置 <code>this</code> 时指向的默认对象）。</p><p>这种情况下，若想要正确设置 <code>this</code>，可以使用 <code>bind</code> ：</p><pre><code class="hljs js">&lt;button onclick=<span class="hljs-string">&quot;alert((function()&#123;return this&#125;).bind(this)());&quot;</span>&gt;    Show inner <span class="hljs-built_in">this</span>&lt;/button&gt;</code></pre><hr /><p>REF: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this">MDN</a></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5620.连续连接的二进制数字</title>
    <link href="/2020/12/06/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/5620-%E8%BF%9E%E7%BB%AD%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E5%AD%97/"/>
    <url>/2020/12/06/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/5620-%E8%BF%9E%E7%BB%AD%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<img src="https://pic.leetcode-cn.com/1607237469-ehWTvX-image.png" alt="image.png" style="zoom:80%;" /><p>  第一次 JS 双百，虽然是虚假的双百 😭</p><h1 id="写法1-耿直模拟"><a class="markdownIt-Anchor" href="#写法1-耿直模拟"></a> 写法1 ：耿直模拟</h1><p>  使用 JS 中的进制转换函数 <code>toString</code> 和 <code>parseInt</code> 实现模拟。</p><p>  <code>toString</code> 能将十进制数字转换为任意进制数字，如 <code>(5).toString(2) = 101</code></p><p>  <code>parseInt</code> 能将二进制数字转换为十进制数字，如 <code>parseInt('101', 2) = 5</code></p><p>  不过这种写法效率可能有点差，会超时…</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> concatenatedBinary = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>&#123;    <span class="hljs-keyword">let</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;    <span class="hljs-keyword">let</span> sum = <span class="hljs-string">&quot;&quot;</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;        sum += (i).toString(<span class="hljs-number">2</span>); <span class="hljs-comment">// 十进制转二进制然后字符串拼接</span>        <span class="hljs-keyword">let</span> t = <span class="hljs-built_in">parseInt</span>(sum, <span class="hljs-number">2</span>);   <span class="hljs-comment">// 二进制字符串转十进制判断是否需要取余</span>        <span class="hljs-keyword">if</span> (t &gt;= mod) &#123;            t %= mod;            sum = (t).toString(<span class="hljs-number">2</span>);        &#125;    &#125;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(sum, <span class="hljs-number">2</span>);&#125;;</code></pre><h1 id="写法2-二进制移位模拟"><a class="markdownIt-Anchor" href="#写法2-二进制移位模拟"></a> 写法2 ：二进制移位模拟</h1><p>  其实，我们稍微列一下二进制就能够比较直观的找到连接的规律：</p><p>  我们知道，对于二进制，<strong>每次向左移动一位就是乘上一个 <code>2</code></strong>，因此若当前要连接的数字的二进制位数是两位，我们每次移动就应该乘上一个 <code>4</code> ，三位二进制就乘上一个 <code>8</code>，移动完后末尾再加上当前的数字即可。</p><img src="https://pic.leetcode-cn.com/1607238962-caJQLh-image.png" alt="image.png" style="zoom:80%;" /><p>  若使用 JS ，需要使用 <code>BigInt</code> 类型，因为后面在进行移位的时候可能会过大导致算术溢出…</p><p>  如： <code>28399128732189371 &lt;&lt; 1 -&gt; -670661256</code></p><p>  关于 <code>BigInt</code> 的使用也很简单，普通数字后面加一个 <code>n</code> 就代表了 <code>BigInt</code> 类型，如 <code>1n</code>，或是使用构造器 <code>BigInt(1)</code>。</p><p>  使用 <code>BigInt</code> 时需要注意的是 <code>bigint</code> 类型只能与 <code>bigint</code> 类型进行运算，且 <code>Math</code> 中的方法也不能应用在 <code>bigint</code> 类型上。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> concatenatedBinary = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>&#123;    <span class="hljs-keyword">let</span> mod = BigInt(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);  <span class="hljs-comment">// JS 需要使用大数，不然会溢出</span>    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0n</span>;    <span class="hljs-keyword">let</span> p = <span class="hljs-number">1n</span>;    <span class="hljs-keyword">let</span> l = <span class="hljs-number">2n</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1n</span>; i &lt;= n; i++) &#123;        <span class="hljs-keyword">if</span> (i === l) &#123;  <span class="hljs-comment">// 若 i 为 2 的倍数，那么移位数 + 1</span>            p++;            l *= <span class="hljs-number">2n</span>;        &#125;        sum &lt;&lt;= p;  <span class="hljs-comment">// 累加的和每次移 p 位，然后再加上当前值</span>        sum += i;        <span class="hljs-keyword">if</span> (sum &gt;= mod) &#123;            sum %= mod;        &#125;    &#125;        <span class="hljs-keyword">return</span> sum;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>解答</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大数</tag>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS 数组</title>
    <link href="/2020/11/27/JS/JS-%E6%95%B0%E7%BB%84/"/>
    <url>/2020/11/27/JS/JS-%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h1><h2 id="获取数组中的最大-最小值"><a class="markdownIt-Anchor" href="#获取数组中的最大-最小值"></a> 获取数组中的最大、最小值</h2><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>];<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.max(...arr)); <span class="hljs-comment">// 7</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.min(...arr)); <span class="hljs-comment">// 1</span></code></pre><h2 id="创建多维数组"><a class="markdownIt-Anchor" href="#创建多维数组"></a> 创建多维数组</h2><p>  以创建 <code>5x5</code> 的<strong>二维数组</strong>为例：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">5</span>).fill(<span class="hljs-number">0</span>).map(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">5</span>).fill(<span class="hljs-number">0</span>))；</code></pre><p>  <mark>注意</mark>，以下写法是<strong>错误</strong>的：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">5</span>).fill(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">5</span>).fill(<span class="hljs-number">0</span>));</code></pre><p>  这种写法中，第二维的数组其实都是相同的，所以你改变一个元素如 <code>arr[0][1]</code>，那么 <code>arr[0][1]</code>、<code>arr[1][1]</code>、…、<code>arr[4][1]</code> 的元素都会被一同改变，因为这些数组的引用都是相同的。</p><h2 id="数组去重"><a class="markdownIt-Anchor" href="#数组去重"></a> 数组去重</h2><h3 id="1使用-set-去重"><a class="markdownIt-Anchor" href="#1使用-set-去重"></a> 1.使用 set 去重</h3><pre><code class="hljs js"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>];<span class="hljs-keyword">const</span> uniqueArray = [...new <span class="hljs-built_in">Set</span>(array)];<span class="hljs-built_in">console</span>.log(uniqueArray); <span class="hljs-comment">// [1, 2, 3, 5]</span></code></pre><h3 id="2使用-filter-去重"><a class="markdownIt-Anchor" href="#2使用-filter-去重"></a> 2.使用 filter 去重</h3><p>  这种方法中，对于重复的数字，只有从左到右的第一个数字会满足条件，返回 <code>true</code>。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>];<span class="hljs-keyword">let</span> n_arr = arr.filter(<span class="hljs-function">(<span class="hljs-params">val, index, array</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> array.indexOf(val) === index;&#125;);<span class="hljs-comment">// [1, 2, 4, 3, 5]</span></code></pre><h3 id="3数组遍历"><a class="markdownIt-Anchor" href="#3数组遍历"></a> 3.数组遍历</h3><p>  创建一个新数组，遍历原来的数组，若当前数字不在新数组中则加入新数组，这种方法与 <code>filter</code> 的思想是相同的：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>];<span class="hljs-keyword">let</span> n_arr = [];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> v <span class="hljs-keyword">of</span> arr) &#123;    <span class="hljs-keyword">if</span> (n_arr.indexOf(v) === <span class="hljs-number">-1</span>) &#123;        n_arr.push(v);    &#125;&#125;<span class="hljs-built_in">console</span>.log(n_arr); <span class="hljs-comment">// [1, 2, 4, 3, 5]</span></code></pre><h2 id="判断两个数组的内容是否相同"><a class="markdownIt-Anchor" href="#判断两个数组的内容是否相同"></a> 判断两个数组的内容是否相同</h2><p>  不能使用 <code>===</code> 来判断，因为数组也是对象，<code>===</code> 对于对象会判断其引用是否相同来判断真假。</p><h3 id="1-数组排序-转字符串"><a class="markdownIt-Anchor" href="#1-数组排序-转字符串"></a> 1. 数组排序 + 转字符串</h3><p>  一个判断数组元素是否相同的方法是：<strong>先将数组转为字符串，对字符串进行排序或转换前对数组进行排序，再来判断字符串是否相同</strong>。</p><p>  字符串转换的方法有 <code>arr.toString()</code> 和 <code>JSON.stringify(arr)</code> 与 <code>arr.join()</code> 等。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = [<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>]; b=[<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>];<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEqual</span>(<span class="hljs-params">arr1 = [],arr2 = []</span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.stringify(arr1.sort()) == <span class="hljs-built_in">JSON</span>.stringify(arr2.sort())&#125;isEqual(a,b)</code></pre><h3 id="2-编写-arrayprototypeequals"><a class="markdownIt-Anchor" href="#2-编写-arrayprototypeequals"></a> 2. 编写 Array.prototype.equals</h3><p>  如果不仅要判断元素是否相同还要判断<strong>元素的顺序</strong>是否相同且数组内有<strong>嵌套关系</strong>的话可以使用以下方法：</p><pre><code class="hljs js"><span class="hljs-comment">// Warn if overriding exiting method</span><span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.prototype.equals) &#123;    <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">&#x27;Overriding existing Array.prototype.equals.&#x27;</span>);&#125;<span class="hljs-built_in">Array</span>.prototype.equals = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr</span>) </span>&#123;    <span class="hljs-comment">// If the other array is a falsy value, return</span>    <span class="hljs-keyword">if</span> (!arr) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-comment">// comapre lengths - can save a lot of time</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.length != arr.length) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = <span class="hljs-built_in">this</span>.length; i &lt; l; ++i) &#123;        <span class="hljs-comment">// Check if we have nested arrays</span>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>[i] <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span> &amp;&amp; arr[i] <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>) &#123;            <span class="hljs-comment">// Recurse into the nested arrays</span>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.equals(arr[i])) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>[i] <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> &amp;&amp; arr[i] <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>) &#123;            <span class="hljs-comment">// Requires Object.equals !!!</span>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>[i].equals(arr[i])) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>[i] != arr[i]) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-comment">// Hide method from for in loops</span><span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">Array</span>.prototype, <span class="hljs-string">&#x27;equals&#x27;</span>, &#123;<span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>&#125;);</code></pre><p>上面代码中，<code>Objec</code> 的 <code>equals</code> 方法需要自己实现，一个 <a href="https://yleave.top/2020/11/27/JS/JS-%E5%AF%B9%E8%B1%A1/#%E6%AF%94%E8%BE%83%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9%E6%98%AF%E5%90%A6%E7%9B%B8%E5%90%8C%E7%BC%96%E5%86%99-objectequals-%E5%87%BD%E6%95%B0">Object.prototype.equals</a></p><h2 id="数组扁平化"><a class="markdownIt-Anchor" href="#数组扁平化"></a> 数组扁平化</h2><p>已知如下数组：<code>var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];</code></p><p>编写一个程序将数组<strong>扁平化</strong>并<strong>去除其中重复部分数据</strong>，最终得到一个<strong>升序</strong>且不重复的数组</p><h3 id="1-使用-flat-扁平化"><a class="markdownIt-Anchor" href="#1-使用-flat-扁平化"></a> 1. 使用 flat 扁平化</h3><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [ [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, [<span class="hljs-number">11</span>, <span class="hljs-number">12</span>, [<span class="hljs-number">12</span>, <span class="hljs-number">13</span>, [<span class="hljs-number">14</span>] ] ] ], <span class="hljs-number">10</span>];<span class="hljs-keyword">let</span> flatArr = arr.flat(<span class="hljs-number">4</span>); <span class="hljs-comment">// flat 的参数为扁平化的深度，默认为 1</span><span class="hljs-keyword">let</span> uniArr = <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(flatArr));<span class="hljs-comment">// uniArr = [...new Set(flatArr)];</span>uniArr.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);</code></pre><h3 id="2-循环遍历"><a class="markdownIt-Anchor" href="#2-循环遍历"></a> 2. 循环遍历</h3><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [ [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, [<span class="hljs-number">11</span>, <span class="hljs-number">12</span>, [<span class="hljs-number">12</span>, <span class="hljs-number">13</span>, [<span class="hljs-number">14</span>] ] ] ], <span class="hljs-number">10</span>];<span class="hljs-keyword">let</span> res = [];<span class="hljs-keyword">const</span> flatArr = <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span> &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> a <span class="hljs-keyword">of</span> arr) &#123;        <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>) &#123;            flatArr(a);        &#125; <span class="hljs-keyword">else</span> &#123;            res.push(a);        &#125;    &#125;&#125;;flatArr(arr);res = [...new <span class="hljs-built_in">Set</span>(res)];res.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b );</code></pre>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS Array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS 函数</title>
    <link href="/2020/11/27/JS/JS-%E5%87%BD%E6%95%B0/"/>
    <url>/2020/11/27/JS/JS-%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h1><h2 id="函数也是对象"><a class="markdownIt-Anchor" href="#函数也是对象"></a> 函数也是对象</h2><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bark</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Woof!&#x27;</span>);&#125;bark.animal = <span class="hljs-string">&#x27;dog&#x27;</span>;</code></pre><p>  上面的代码在 JS 中是可行的，因为函数也是对象（<strong>除了基本类型之外其他都是对象</strong>）。</p><h2 id="构造器函数"><a class="markdownIt-Anchor" href="#构造器函数"></a> 构造器函数</h2><p>  在 JS 中，结合 <code>new</code> 前缀来调用的函数被称为构造器函数，<strong>构造器函数按约定命名的首字母必须大写。</strong></p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">firstName, lastName</span>) </span>&#123;    <span class="hljs-built_in">this</span>.firstName = firstName;    <span class="hljs-built_in">this</span>.lastName = lastName;&#125;<span class="hljs-keyword">const</span> member = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;Lydia&#x27;</span>, <span class="hljs-string">&#x27;Hallie&#x27;</span>);</code></pre><p>  对于构造器函数来说，<strong>不能</strong>像其他对象一样直接给它添加对象，<strong>应该</strong>使用 <code>prototype</code> 来添加，这样所有 <code>Person</code> 实例化的对象都会有这个属性了：</p><pre><code class="hljs js">Person.getFullName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.firstName&#125;</span> <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.lastName&#125;</span>`</span>;&#125;;<span class="hljs-built_in">console</span>.log(member.getFullName());  <span class="hljs-comment">// TypeError</span>Person.prototype.getFullName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.firstName&#125;</span> <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.lastName&#125;</span>`</span>;&#125;;</code></pre><h3 id="构造器函数实例化"><a class="markdownIt-Anchor" href="#构造器函数实例化"></a> 构造器函数实例化</h3><p>  若对一个函数<strong>使用</strong> <code>new</code> 实例化的话，实例化对象会指向这个新创建的对象，而<strong>不使用</strong> <code>new</code>的话，则会指向全局对象 <code>global</code>。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">firstName, lastName</span>) </span>&#123;  <span class="hljs-built_in">this</span>.firstName = firstName;  <span class="hljs-built_in">this</span>.lastName = lastName;&#125;<span class="hljs-keyword">const</span> lydia = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;Lydia&#x27;</span>, <span class="hljs-string">&#x27;Hallie&#x27;</span>);<span class="hljs-keyword">const</span> sarah = Person(<span class="hljs-string">&#x27;Sarah&#x27;</span>, <span class="hljs-string">&#x27;Smith&#x27;</span>);<span class="hljs-built_in">console</span>.log(lydia);  <span class="hljs-comment">// Person &#123;firstName: &quot;Lydia&quot;, lastName: &quot;Hallie&quot;&#125;</span><span class="hljs-built_in">console</span>.log(sarah);  <span class="hljs-comment">// undefined</span></code></pre><p>  上面的代码中，对于 <code>sarah</code> 来说，相当于定义了 <code>global.firstName = 'Sarah'</code> 与 <code>global.lastName = 'Smith'</code>，并且调用了 <code>Person</code> 函数，可是它并没定义返回值，因此默认返回 <code>undefined</code>.</p><p>  <strong>对于一个带返回对象的构造器函数来说，返回的对象的优先级更高.</strong></p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Car</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">this</span>.make = <span class="hljs-string">&quot;Lamborghini&quot;</span>;    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">make</span>: <span class="hljs-string">&quot;Maserati&quot;</span> &#125;;&#125;<span class="hljs-keyword">const</span> myCar = <span class="hljs-keyword">new</span> Car();<span class="hljs-built_in">console</span>.log(myCar);</code></pre><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost@master/img/image-20200416205516433.png" alt="image-20200416205516433" style="zoom:80%;" /> <p>  不过<strong>返回的不是对象的话，返回的是构造出的对象</strong>（数组也是对象，因此会优先返回数组）</p><pre><code class="hljs js"></code></pre><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost@master/img/image-20200416205600285.png" alt="image-20200416205600285" style="zoom:80%;" /><h2 id="参数"><a class="markdownIt-Anchor" href="#参数"></a> 参数</h2><p>  <strong>普通参数是传值</strong>，而<strong>对象是传递引用</strong>，因此若在函数中对对象做出改动，原对象会跟着改动：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getInfo</span>(<span class="hljs-params">member, year</span>) </span>&#123;    member.name = <span class="hljs-string">&#x27;Lydia&#x27;</span>; <span class="hljs-comment">// 函数中改动对象的属性值</span>    year = <span class="hljs-string">&#x27;1998&#x27;</span>;&#125;<span class="hljs-keyword">const</span> person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Sarah&#x27;</span> &#125;;<span class="hljs-keyword">const</span> birthYear = <span class="hljs-string">&#x27;1997&#x27;</span>;getInfo(person, birthYear);<span class="hljs-built_in">console</span>.log(person, birthYear);  <span class="hljs-comment">// &#123; name: &quot;Lydia&quot; &#125;, &quot;1997&quot;</span></code></pre><h3 id="arguments"><a class="markdownIt-Anchor" href="#arguments"></a> arguments</h3><p>  当函数被调用时，会被附上一个参数，那就是 <code>arguments</code> 数组。</p><p>  函数可以通过此参数访问所有它被调用时传递给它的<strong>参数列表</strong>，包括那些没有被分配给函数声明时定义的形式参数的多余参数。</p><pre><code class="hljs js"><span class="hljs-comment">//构造一个将大量的值相加的函数</span><span class="hljs-comment">//该函数内部定义的 sum 不会与外部定义的 sum 产生冲突，因为该函数只会看到内部的那个变量</span><span class="hljs-keyword">var</span> sum = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> i,sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++)&#123;        sum += <span class="hljs-built_in">arguments</span>[i];    &#125;    <span class="hljs-keyword">return</span> sum;&#125;;<span class="hljs-built_in">document</span>.write(sum(<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>,<span class="hljs-number">23</span>,<span class="hljs-number">42</span>));   <span class="hljs-comment">//--&gt;108</span></code></pre><p>  <mark>注意</mark>，<code>arguments</code> 并不是一个真正的数组。它只是一个 “类似数组的对象” 。<code>arguments</code> 拥有一个 <code>length</code> 属性，但它没有任何数组的方法。</p><h2 id="函数中的默认参数"><a class="markdownIt-Anchor" href="#函数中的默认参数"></a> 函数中的默认参数</h2><p>  下面的写法是正确的，若只传递一个参数，那么 <code>num2</code> 会是以已初始化的 <code>num1</code> 为值，不过若是 <code>num1</code> 在 <code>num2</code> 的右边的话，则会报错。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">num1, num2 = num1</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(num1 + num2);&#125;sum(<span class="hljs-number">10</span>);  <span class="hljs-comment">// 20</span></code></pre><p>  <strong>默认参数可设为上下文内容中的变量</strong>：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compareMembers</span>(<span class="hljs-params">person1, person2 = person</span>) </span>&#123;    <span class="hljs-keyword">if</span> (person1 !== person2) &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Not the same!&#x27;</span>);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;They are the same!&#x27;</span>);    &#125;&#125;<span class="hljs-keyword">const</span> person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Lydia&#x27;</span> &#125;;compareMembers(person); <span class="hljs-comment">// They are the same!</span></code></pre><h3 id="展开语法作为函数的默认参数"><a class="markdownIt-Anchor" href="#展开语法作为函数的默认参数"></a> 展开语法作为函数的默认参数</h3><p>  展开表达式可用于对象的复制，这种复制是<strong>浅复制</strong>，它们的指向是<strong>不一样</strong>的。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;    name: <span class="hljs-string">&#x27;Lydia&#x27;</span>,    age: <span class="hljs-number">21</span>,&#125;;<span class="hljs-keyword">let</span> p1 = &#123;...person&#125;;<span class="hljs-built_in">console</span>.log(p1 === person); <span class="hljs-comment">// false</span><span class="hljs-keyword">const</span> changeAge = <span class="hljs-function">(<span class="hljs-params">x = &#123; ...person &#125;</span>) =&gt;</span> &#123;    x.age += <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span> (x === person) &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;等于&#x27;</span>); <span class="hljs-comment">// 被打印</span>    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;不等于&#x27;</span>);    &#125;&#125;<span class="hljs-keyword">const</span> changeAgeAndName = <span class="hljs-function">(<span class="hljs-params">x = &#123; ...person &#125;</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (x === person) &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;等于&#x27;</span>);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;不等于&#x27;</span>);  <span class="hljs-comment">// 被打印</span>    &#125;    x.age += <span class="hljs-number">1</span>;    x.name = <span class="hljs-string">&quot;Sarah&quot;</span>;&#125;changeAge(person);<span class="hljs-comment">// 等于  --&gt; 传递了 person，因此 x 与 person 的指向相同</span>changeAgeAndName();<span class="hljs-comment">// 不等于  --&gt; 没传递 person ，因此 x 只是 person 的浅复制</span></code></pre><h2 id="apply-call"><a class="markdownIt-Anchor" href="#apply-call"></a> Apply &amp; Call</h2><h3 id="apply"><a class="markdownIt-Anchor" href="#apply"></a> apply</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">apply NDM 文档</a></p><p>  <code>Function.prototype.apply(obj, args)</code></p><p>  <code>apply</code> 方法让我们构建一个参数数组传递给调用函数。它允许我们选择 <code>this</code> 的值。</p><p>  <code>apply</code> 方法接收两个参数，第一个是要绑定给 <code>this</code> 的值，第二个就是一个<strong>参数数组</strong>。</p><p>  当第一个参数为 <code>null</code> 或为 <code>undefined</code> 时，会自动替换为指向全局对象。</p><h3 id="call"><a class="markdownIt-Anchor" href="#call"></a> call</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call">MDN 文档</a></p><p>  <code>Function.prototype.call(obj, arg1, arg2, ...)</code></p><p>  <code>call</code> 方法的参数和 <code>apply</code> 类型，不过第二个参数开始是传入一个个的参数而不是整个的参数列表。</p><p>  同样，当第一个参数为 <code>null</code> 或为 <code>undefined</code> 时，会自动替换为指向全局对象。</p><h3 id="第一个例子"><a class="markdownIt-Anchor" href="#第一个例子"></a> 第一个例子</h3><p>  构造一个包含两个数字的数组，并将它们相加：</p><pre><code class="hljs js"><span class="hljs-comment">// 定义 add 函数</span><span class="hljs-keyword">let</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>&#123;<span class="hljs-keyword">return</span> a + b;&#125;;<span class="hljs-keyword">let</span> arr = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<span class="hljs-comment">// 使用 apply</span><span class="hljs-keyword">let</span> sum = add.apply(<span class="hljs-literal">null</span>, arr); <span class="hljs-comment">// sum = 7</span><span class="hljs-comment">// 使用 call</span>sum = add.call(<span class="hljs-literal">null</span>, arr[<span class="hljs-number">0</span>], arr[<span class="hljs-number">1</span>]); <span class="hljs-comment">// sum = 7</span></code></pre><p>  上面的代码中，<code>apply</code> 的第一个参数为 <code>null</code>，因此此时 <code>add</code> 中的 <code>this</code> 会指向全局对象，如：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">6</span>, b = <span class="hljs-number">7</span>;<span class="hljs-keyword">let</span> add = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.a + <span class="hljs-built_in">this</span>.b;&#125;;<span class="hljs-keyword">let</span> arr = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<span class="hljs-keyword">let</span> sum = add.apply(<span class="hljs-literal">null</span>, arr); <span class="hljs-comment">// sum = 13 ，此时 add 中为 6 + 7 , call 也是一样的</span></code></pre><h3 id="第二个例子"><a class="markdownIt-Anchor" href="#第二个例子"></a> 第二个例子</h3><pre><code class="hljs js"><span class="hljs-keyword">let</span> Person = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, age</span>) </span>&#123;    <span class="hljs-built_in">this</span>.name = name;    <span class="hljs-built_in">this</span>.age = age;&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Student</span>(<span class="hljs-params">name, age, grade</span>) </span>&#123;    <span class="hljs-comment">// 使用 apply</span>    Person.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>); <span class="hljs-comment">// arguments 是函数中的参数列表</span>        <span class="hljs-comment">// 使用 call</span>    Person.call(<span class="hljs-built_in">this</span>, name, age);        <span class="hljs-built_in">this</span>.grade = grade;&#125;;<span class="hljs-keyword">let</span> stu = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">2</span>);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;stu: &#x27;</span>, stu.name, stu.age, stu.grade); <span class="hljs-comment">// stu:  张三 18 2</span></code></pre><p>  上面的代码中，<code>Student</code> 构造器中没有定义 <code>name</code> 和 <code>age</code> 属性，不过因为使用了 <code>apply/call</code> 函数，修改了 <code>Person</code> 中 <code>this</code> 的指向，因此 <code>Student</code> 对象中仍有 <code>name</code> 和 <code>age</code>。</p><p>  其中，<code>arguments</code> 是一个参数列表，在上面就会是这样：<code>[&quot;张三&quot;, 18, 2]</code>，它虽然有 <code>length</code> 属性，但并不是一个数字，只是一个类似数组的存在。</p><h3 id="apply-和-call-的使用选择"><a class="markdownIt-Anchor" href="#apply-和-call-的使用选择"></a> apply 和 call 的使用选择</h3><p>  根据上面两个示例，我们可以知道，<code>apply</code> 和 <code>call</code> 的区别就是第一个参数后面的其他参数传递不同，<code>apply</code> 是传递一个参数数组，而 <code>call</code> 是传递一个个单独的参数，因此，若函数定义的参数顺序和我们的参数列表中的顺序一致，可以选择 <code>apply</code>，否则，我们可以使用 <code>call</code> 并一个个指定要传递的参数。</p><p>  不过讲道理，使用 <code>call</code> 一个个指定传递的参数顺序的话其实将这些参数构造成数组并使用 <code>apply</code> 传递并没有什么区别。如 <code>call(null, 3, 4)</code> 和 <code>apply(null, [3, 4])</code>。</p><h3 id="apply-的一些妙用"><a class="markdownIt-Anchor" href="#apply-的一些妙用"></a> apply 的一些妙用</h3><p>  从上面两个例子中，我们可以知道，<code>apply</code> 的第二个参数是一个参数列表，但是在实际调用的时候这个参数列表会被拆解为一个个的参数，如上面 <code>add</code> 方法中传入 <code>[3, 4] -&gt; 3, 4</code> ，借助 <code>apply</code> 的这种特性，有一些奇妙的使用方法：</p><h4 id="mathmax-min-apply"><a class="markdownIt-Anchor" href="#mathmax-min-apply"></a> Math.max / min + apply</h4><p>  <code>Math.max/min</code> 不支持 <code>Math.max/min([param1, param2, ...])</code> 这样的数组参数，但它支持 <code>Math.max/min(param1, param2, ...)</code> 这样的参数，因此可以使用 <code>apply</code> 将数组拆分为一个个的参数：</p><pre><code class="hljs js"><span class="hljs-built_in">Math</span>.max.apply(<span class="hljs-literal">null</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);</code></pre><h4 id="arraypush"><a class="markdownIt-Anchor" href="#arraypush"></a> array.push</h4><p>  <code>push</code> 也可以通过 <code>apply</code> 来便捷的合并数组：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], arr2 = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<span class="hljs-built_in">Array</span>.prototype.push.apply(arr1, arr2);<span class="hljs-built_in">console</span>.log(arr1); <span class="hljs-comment">// [1, 2, 3, 4]</span></code></pre><p>  <mark>不过</mark>  ES6 中的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax">展开语法</a> 可以更加简洁的实现这些功能：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], arr2 = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>];arr1.push(...arr2); <span class="hljs-comment">// arr1 : [1, 2, 3, 4]</span><span class="hljs-built_in">Math</span>.max(...arr1); <span class="hljs-comment">// 4</span></code></pre><h2 id="bind-函数"><a class="markdownIt-Anchor" href="#bind-函数"></a> bind 函数</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">MDN 文档</a></p><p><code>Function.prototype.bind(obj, arg1, arg2, ...)</code></p><p>  简单来说，<code>bind</code> 主要用于绑定一个函数的 <code>this</code> 指向。</p><h3 id="例1"><a class="markdownIt-Anchor" href="#例1"></a> 例1</h3><p>  由于 Javascript 的变量域问题，有时会使用 <code>that = this</code> ：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> myObj = &#123;    func1: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; ... &#125;,        func2: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; ... &#125;,    getAsyncData: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cb</span>) </span>&#123;        cb();    &#125;,    render: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">var</span> that = <span class="hljs-built_in">this</span>;        <span class="hljs-built_in">this</span>.getAsyncData(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;            that.func1();            that.func2();        &#125;);    &#125;&#125;;myObj.render();</code></pre><p>  为了不改变 <code>myobj</code> 中的上下文关系，使用了 <code>that.fun()</code> 来调用函数。</p><p>  这种方式可以使用 <code>Function.protype.bind()</code> 来简化：</p><pre><code class="hljs js">render: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">this</span>.getAsyncData(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">this</span>.func1();        <span class="hljs-built_in">this</span>.func2();    &#125;.bind(<span class="hljs-built_in">this</span>));&#125;</code></pre><p>  关于 <code>bind()</code> 函数的内部逻辑可以用一个简单的小例子来解释：</p><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.bind = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">scope</span>) </span>&#123;    <span class="hljs-keyword">var</span> fn = <span class="hljs-built_in">this</span>;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">return</span> fn.apply(scope);    &#125;;&#125;<span class="hljs-keyword">var</span> foo = &#123;    x: <span class="hljs-number">3</span>&#125;<span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;<span class="hljs-keyword">var</span> bar = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x);&#125;bar(); <span class="hljs-comment">// 10 , 此时 this 指向全局作用域</span><span class="hljs-keyword">var</span> boundFunc = bar.bind(foo);boundFunc(); <span class="hljs-comment">// 3</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS Function</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS 对象</title>
    <link href="/2020/11/27/JS/JS-%E5%AF%B9%E8%B1%A1/"/>
    <url>/2020/11/27/JS/JS-%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="对象"><a class="markdownIt-Anchor" href="#对象"></a> 对象</h1><h2 id="js-中对象的-key-都会被转为-string-类型"><a class="markdownIt-Anchor" href="#js-中对象的-key-都会被转为-string-类型"></a> <strong>JS 中，对象的 <code>key</code> 都会被转为 <code>string</code> 类型。</strong></h2><p>  <strong>如：</strong></p><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">3</span>: <span class="hljs-string">&#x27;c&#x27;</span> &#125;;obj.hasOwnProperty(<span class="hljs-string">&#x27;1&#x27;</span>);  <span class="hljs-comment">// true</span>obj.hasOwnProperty(<span class="hljs-number">1</span>);  <span class="hljs-comment">// true</span></code></pre><p>  <strong>再如</strong>，以一个对象为 <code>key</code>，同样会被转为 <code>string</code>：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> a = &#123;&#125;;<span class="hljs-keyword">const</span> b = &#123; <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;b&#x27;</span> &#125;;<span class="hljs-keyword">const</span> c = &#123; &#125;;a[b] = <span class="hljs-number">123</span>;a[c] = <span class="hljs-number">456</span>;<span class="hljs-built_in">console</span>.log(a[b]); <span class="hljs-comment">// 456</span></code></pre><p>  对象 <code>a</code>：<img src="https://cdn.jsdelivr.net/gh/yleave/imagehost@master/img/image-20200416203843666.png" alt="image-20200416203843666" style="zoom:80%;" /></p><p>  上面的代码中， 对象 <code>b</code> 和对象<code>c</code> 都被当做一个 <code>key</code>，而对象的 <code>key</code> 会被转为字符串，因此 <code>b</code> 和 <code>c</code> 会被转为：<code>&quot;[object Object]&quot;</code>，所以，代码中表示 <code>a[&quot;object Object&quot;] = 123</code>，所以最后变成了 <code>456</code>。</p><p>  当我们调用 <code>a[b]</code> 的时候，相当于调用了 <code>a[&quot;object Object&quot;]</code>。</p><p>  不过若是用 <code>a.b</code> 的话，<code>b</code> 就是代表一个字符 <code>b</code> 。</p><h2 id="判断对象是否为空"><a class="markdownIt-Anchor" href="#判断对象是否为空"></a> 判断对象是否为空</h2><h3 id="1-objectkeys"><a class="markdownIt-Anchor" href="#1-objectkeys"></a> 1. object.keys()</h3><pre><code class="hljs js"><span class="hljs-keyword">var</span> data = &#123;&#125;;<span class="hljs-keyword">var</span> arr = <span class="hljs-built_in">Object</span>.keys(data);alert(arr.length == <span class="hljs-number">0</span>); <span class="hljs-comment">//true 为空， false 不为空</span></code></pre><h3 id="2将对象转化为json字符串再判断该字符串是否为"><a class="markdownIt-Anchor" href="#2将对象转化为json字符串再判断该字符串是否为"></a> 2.将对象转化为json字符串，再判断该字符串是否为&quot;{}&quot;</h3><pre><code class="hljs js"><span class="hljs-keyword">var</span> data = &#123;&#125;;<span class="hljs-keyword">var</span> b = (<span class="hljs-built_in">JSON</span>.stringify(data) == <span class="hljs-string">&quot;&#123;&#125;&quot;</span>);alert(b);   <span class="hljs-comment">//true 为空， false 不为空</span></code></pre><h3 id="3for-in-循环判断"><a class="markdownIt-Anchor" href="#3for-in-循环判断"></a> 3.for in 循环判断</h3><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<span class="hljs-keyword">var</span> b = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> obj) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre><h3 id="4objectgetownpropertynames方法"><a class="markdownIt-Anchor" href="#4objectgetownpropertynames方法"></a> 4.Object.getOwnPropertyNames()方法</h3><p>  此方法是使用 <code>Object</code> 对象的 <code>getOwnPropertyNames</code> 方法，获取到对象中的属性名，存到一个数组中，返回数组对象，我们可以通过判断数组的 <code>length</code> 来判断此对象是否为空。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> data = &#123;&#125;;<span class="hljs-keyword">var</span> arr = <span class="hljs-built_in">Object</span>.getOwnPropertyNames(data);alert(arr.length == <span class="hljs-number">0</span>);<span class="hljs-comment">//true</span></code></pre><h2 id="比较对象中的内容是否相同编写-objectequals-函数"><a class="markdownIt-Anchor" href="#比较对象中的内容是否相同编写-objectequals-函数"></a> 比较对象中的内容是否相同，编写 Object.equals 函数</h2><p>  注意，在 <code>equals</code> 中没有使用 <code>===</code> 进行比较，因为 <code>===</code> 会比较对象的引用是否相同，而我们只想比较内容是否相同：</p><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.prototype.equals = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>) </span>&#123;    <span class="hljs-comment">// For first loop , we only check for types</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> propName <span class="hljs-keyword">in</span> <span class="hljs-built_in">this</span>) &#123;        <span class="hljs-comment">// Check for inherited methods and properties</span>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.hasOwnProperty(propName) != obj.hasOwnProperty(propName)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-comment">// Check instance type</span>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span>[propName] != <span class="hljs-keyword">typeof</span> obj[propName]) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;    <span class="hljs-comment">// A deeper check using other objects property names</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> propName <span class="hljs-keyword">in</span> obj) &#123;        <span class="hljs-comment">// We must check instances anyway, there may be a property exits in obj</span>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.hasOwnProperty(propName) != obj.hasOwnProperty(propName)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span>[propName] != <span class="hljs-keyword">typeof</span> obj[propName]) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-comment">// If the property is inherited, do not check any more (it must be equal if both objects inherit it)</span>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.hasOwnProperty(propName)) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-comment">// Now the detail check and recursion</span>        <span class="hljs-comment">// Requires Array.equals !!!</span>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>[propName] <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span> &amp;&amp; obj[propName] <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>) &#123;            <span class="hljs-comment">// recurse into the nested arrays</span>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>[propName].equals(obj[propName])) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>[propName] <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> &amp;&amp; obj[propName] <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>) &#123;            <span class="hljs-comment">// recurse into other objects</span>            <span class="hljs-comment">// console.log(&quot;Recursing to compare &quot;, this[propName],&quot;with&quot;,obj[propName], &quot; both named \&quot;&quot;+propName+&quot;\&quot;&quot;);</span>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>[propName].equals(obj[propName])) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>[propName] != obj[propName]) &#123;  <span class="hljs-comment">// Normal value comparsion for strings and numbers</span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre><p>  一个 <a href="https://yleave.top/2020/11/27/JS/JS-%E6%95%B0%E7%BB%84/#%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AE%B9%E6%98%AF%E5%90%A6%E7%9B%B8%E5%90%8C">Array,prototype.equals</a> 的实现</p><p>  上面代码中还需要实现 <code>Array.prototype.equals</code> 方法，这边模拟时就先都返回 <code>true</code> ：</p><pre><code class="hljs js"><span class="hljs-built_in">Array</span>.prototype.equals = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;;<span class="hljs-keyword">let</span> obj1 = &#123;    name: <span class="hljs-string">&#x27;yy&#x27;</span>,    age: <span class="hljs-string">&#x27;15&#x27;</span>,    objs: &#123;        obj1: <span class="hljs-string">&#x27;教师&#x27;</span>,        obj2s: [<span class="hljs-string">&#x27;程序员&#x27;</span>, <span class="hljs-string">&#x27;码农&#x27;</span>],        obj3s: &#123;            obj3_1: <span class="hljs-string">&#x27;互联网员工&#x27;</span>,            obj3_2: <span class="hljs-string">&#x27;社畜&#x27;</span>        &#125;    &#125;&#125;;<span class="hljs-keyword">let</span> obj2 = &#123;    name: <span class="hljs-string">&#x27;yy&#x27;</span>,    age: <span class="hljs-string">&#x27;15&#x27;</span>,    objs: &#123;        obj1: <span class="hljs-string">&#x27;教师&#x27;</span>,        obj2s: [<span class="hljs-string">&#x27;程序员&#x27;</span>, <span class="hljs-string">&#x27;码农&#x27;</span>],        obj3s: &#123;            obj3_1: <span class="hljs-string">&#x27;互联网员工&#x27;</span>,            obj3_2: <span class="hljs-string">&#x27;社畜&#x27;</span>        &#125;    &#125;&#125;;<span class="hljs-built_in">console</span>.log(obj1.equals(obj2)); <span class="hljs-comment">// true</span></code></pre><h2 id="对象的一些方法"><a class="markdownIt-Anchor" href="#对象的一些方法"></a> 对象的一些方法</h2><h3 id="objectprototypehasownproperty"><a class="markdownIt-Anchor" href="#objectprototypehasownproperty"></a> Object.prototype.hasOwnProperty()</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty">MDN 文档</a></p><p>  <code>hasOwnProperty</code> 方法可以检测某个属性是否是该对象自身的（不包括原型链上的属性），若是，返回 <code>true</code> ，否则返回 <code>false</code>。</p><p>例：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Obj</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;obj&#x27;</span>;&#125;Obj.prototype = &#123;    age: <span class="hljs-number">12</span>&#125;;<span class="hljs-built_in">Object</span>.prototype.job = <span class="hljs-string">&#x27;new Job&#x27;</span>;<span class="hljs-keyword">let</span> o = <span class="hljs-keyword">new</span> Obj();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> v <span class="hljs-keyword">in</span> o) &#123;    <span class="hljs-built_in">console</span>.log(v, o.hasOwnProperty(v));&#125;</code></pre><p>  程序输出：</p><pre><code class="hljs yaml"><span class="hljs-string">name</span> <span class="hljs-literal">true</span><span class="hljs-string">age</span> <span class="hljs-literal">false</span><span class="hljs-string">job</span> <span class="hljs-literal">false</span></code></pre><h3 id="objectdefineproperty"><a class="markdownIt-Anchor" href="#objectdefineproperty"></a> Object.defineProperty()</h3><p>  <code>Object.defineProperty()</code> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并<strong>返回这个对象</strong>。</p><p>  语法：<code>Object.defineProperty(obj, prop, descriptor)</code></p><ul><li><code>obj</code> : 要在其上定义属性的对象。</li><li><code>prop</code> : 要定义或修改的属性的名称。</li><li><code>descriptor</code> : 将被定义或修改的属性描述符。</li></ul><p>例：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Lydia&quot;</span> &#125;;<span class="hljs-built_in">Object</span>.defineProperty(person, <span class="hljs-string">&quot;age&quot;</span>, &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">21</span> &#125;);<span class="hljs-built_in">console</span>.log(person); <span class="hljs-comment">// &#123; name: &quot;Lydia&quot;, age: 21 &#125;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.keys(person)); <span class="hljs-comment">// [&quot;name&quot;]</span></code></pre><p>  可修改 <code>descriptor</code> 来设置添加的属性。</p><ul><li><code>configurable</code> :  默认为 <code>false</code>，当设置为 <code>true</code> 时，<code>descriptor</code> 才可被修改，同时该属性也能从对应的对象上被删除。</li><li><code>enumerabel</code> :  默认为 <code>false</code>，设置为 <code>true</code> 时，新添加的属性才能被枚举</li><li><code>value</code> :  默认为 <code>undefined</code>，可以是任何有效的 JS 值（数值，对象，函数等）</li><li><code>writable</code> :  默认为 <code>false</code>，设置为 <code>true</code> 时，<code>value</code> 才能被赋值运算符修改。</li><li><code>get</code> :  默认为 <code>undefined</code>，一个给属性提供 <code>getter</code> 的方法，当访问该属性时，该方法会被执行，方法执行时没有参数传入，但是会传入 <code>this</code> 对象</li><li><code>set</code> :  默认为 <code>undefined</code>，一个给属性提供 <code>setter</code> 的方法，当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。</li></ul><h3 id="objectentries"><a class="markdownIt-Anchor" href="#objectentries"></a> Object.entries</h3><p>  <code>Object.entries(obj)</code> 方法返回一个给定对象自身<strong>可枚举属性的键值对数组</strong>，其排列与使用 <code>for...in</code> 循环遍历该对象时返回的顺序一致，即属性的顺序与通过手动循环对象的属性值所给出的顺序相同。（<strong>区别在于 <code>for-in</code> 循环还会枚举原型链中的属性</strong>）。</p><p>例：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> anObj = &#123; <span class="hljs-number">100</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">7</span>: <span class="hljs-string">&#x27;c&#x27;</span> &#125;;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.entries(anObj)); <span class="hljs-comment">// [ [&#x27;2&#x27;, &#x27;b&#x27;], [&#x27;7&#x27;, &#x27;c&#x27;], [&#x27;100&#x27;, &#x27;a&#x27;] ]</span><span class="hljs-comment">// 字符串</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.entries(<span class="hljs-string">&#x27;foo&#x27;</span>)); <span class="hljs-comment">// [ [&#x27;0&#x27;, &#x27;f&#x27;], [&#x27;1&#x27;, &#x27;o&#x27;], [&#x27;2&#x27;, &#x27;o&#x27;] ]</span></code></pre><p>  使用 <code>for ... of</code> 和解构赋值遍历：</p><pre><code class="hljs js"><span class="hljs-comment">// 使用 for - of 和 解构赋值 遍历结果</span><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">7</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">9</span> &#125;;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(obj)) &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span> <span class="hljs-subst">$&#123;value&#125;</span>`</span>); <span class="hljs-comment">// &quot;a 5&quot;, &quot;b 7&quot;, &quot;c 9&quot;</span>&#125;</code></pre><p>  使用 <code>forEach</code> 遍历：</p><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.entries(obj).forEach(<span class="hljs-function">(<span class="hljs-params">[key, value]</span>) =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span> <span class="hljs-subst">$&#123;value&#125;</span>`</span>); <span class="hljs-comment">// &quot;a 5&quot;, &quot;b 7&quot;, &quot;c 9&quot;</span>&#125;);</code></pre><p>  <code>new Map()</code> 构造函数接受一个可迭代的 <code>entries</code>。借助 <code>Object.entries</code> 方法你可以很容易的将 <code>Object</code> 转换为 <code>Map</code>:</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-attr">baz</span>: <span class="hljs-number">42</span> &#125;; <span class="hljs-keyword">var</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(<span class="hljs-built_in">Object</span>.entries(obj));<span class="hljs-built_in">console</span>.log(map); <span class="hljs-comment">// Map &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span></code></pre><h3 id="objectassign"><a class="markdownIt-Anchor" href="#objectassign"></a> Object.assign()</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">MDN介绍</a></p><p>  <code>Object.assign()</code> 方法用于将所有<strong>可枚举属性</strong>的值从一个或多个源对象复制到目标对象。它将<strong>返回目标对象</strong>。</p><p>  如果目标对象中的属性具有<strong>相同的键</strong>，则属性将被源对象中的属性覆盖。后面的源对象的属性将类似地覆盖前面的源对象的属性。</p><p>  语法：<code>Object.assign(target, ...sources)</code></p><ul><li><code>target</code>: 目标对象。</li><li><code>sources</code>: 源对象。</li></ul><p>返回值：目标对象。</p><p>  <mark>注意</mark>，<code>Object.assign</code> 不会在那些<code>source</code>对象值为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null">null</a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined">undefined</a> 的时候抛出错误。</p><p>例：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> target = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;<span class="hljs-keyword">const</span> source = &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">5</span> &#125;;<span class="hljs-keyword">const</span> returnedTarget = <span class="hljs-built_in">Object</span>.assign(target, source);<span class="hljs-built_in">console</span>.log(target); <span class="hljs-comment">// Object &#123; a: 1, b: 4, c: 5 &#125;</span><span class="hljs-built_in">console</span>.log(returnedTarget); <span class="hljs-comment">//Object &#123; a: 1, b: 4, c: 5 &#125;</span></code></pre><p>  <strong>复制一个对象：</strong></p><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;;<span class="hljs-keyword">const</span> copy = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, obj);<span class="hljs-built_in">console</span>.log(copy); <span class="hljs-comment">// &#123; a: 1 &#125;</span></code></pre><p>  针对<strong>深拷贝</strong>，需要使用其他办法，因为  <code>Object.assign()</code>拷贝的是属性值。<strong>假如源对象的属性值是一个对象的引用，那么它也只指向那个引用</strong>。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj1 = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">0</span> , <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">c</span>: <span class="hljs-number">0</span>&#125;&#125;; <span class="hljs-keyword">let</span> obj2 = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, obj1); <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">JSON</span>.stringify(obj2)); <span class="hljs-comment">// &#123; a: 0, b: &#123; c: 0&#125;&#125; </span>obj1.a = <span class="hljs-number">1</span>; <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">JSON</span>.stringify(obj1)); <span class="hljs-comment">// &#123; a: 1, b: &#123; c: 0&#125;&#125; </span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">JSON</span>.stringify(obj2)); <span class="hljs-comment">// &#123; a: 0, b: &#123; c: 0&#125;&#125; </span>obj2.a = <span class="hljs-number">2</span>; <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">JSON</span>.stringify(obj1)); <span class="hljs-comment">// &#123; a: 1, b: &#123; c: 0&#125;&#125; </span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">JSON</span>.stringify(obj2)); <span class="hljs-comment">// &#123; a: 2, b: &#123; c: 0&#125;&#125;</span> <span class="hljs-comment">// 改变源对象中的对象属性值，拷贝对象会跟着改变，因为只是拷贝了对象的引用</span>obj2.b.c = <span class="hljs-number">3</span>; <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">JSON</span>.stringify(obj1)); <span class="hljs-comment">// &#123; a: 1, b: &#123; c: 3&#125;&#125; </span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">JSON</span>.stringify(obj2)); <span class="hljs-comment">// &#123; a: 2, b: &#123; c: 3&#125;&#125; </span></code></pre><p>  <strong>深克隆：</strong></p><pre><code class="hljs js"><span class="hljs-comment">// Deep Clone </span>obj1 = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">0</span> , <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">c</span>: <span class="hljs-number">0</span>&#125;&#125;; <span class="hljs-keyword">let</span> obj3 = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(obj1)); obj1.a = <span class="hljs-number">4</span>; obj1.b.c = <span class="hljs-number">4</span>; <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">JSON</span>.stringify(obj3)); <span class="hljs-comment">// &#123; a: 0, b: &#123; c: 0&#125;&#125;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS Object</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>奇妙的算法知识</title>
    <link href="/2020/11/19/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/%E5%A5%87%E5%A6%99%E7%9A%84%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/"/>
    <url>/2020/11/19/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/%E5%A5%87%E5%A6%99%E7%9A%84%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="位运算-n-n-1"><a class="markdownIt-Anchor" href="#位运算-n-n-1"></a> 位运算 n &amp; n-1</h1><p>  <code>n&amp;(n-1)</code>作用：<strong>将<code>n</code>的二进制表示中的最低位为<code>1</code>的改为<code>0</code></strong></p><p>  例如 <code>20 &amp; 19 = 16</code> =&gt; <code>10100 &amp; 10011</code> =&gt; <code>10000</code></p><p>  <code>21 &amp; 20 = 20</code> =&gt; <code>10101 &amp; 10100</code> =&gt; <code>10100</code></p><p>  因此对于<strong>奇数</strong>来说，就是把它最后一位的 <code>1</code> 给抹去，相当于减了一个 <code>1</code>；</p><p>  而对于<strong>偶数</strong>来说，就是除了一个 <code>2^x</code> ，也就是把最低位的 <code>1</code> 给抹去了。</p><h2 id="用途-1-判断一个数是否是-2-的幂次方"><a class="markdownIt-Anchor" href="#用途-1-判断一个数是否是-2-的幂次方"></a> 用途 1 ：判断一个数是否是 2 的幂次方</h2><p>  使用 <code>n &amp; (n-1) === 0</code> 可以判断 <code>n</code> 是否是 <code>2</code> 的幂次方。</p><p>  根据上面的分析，若 <code>n</code> 是偶数，则 <code>n &amp; (n-1)</code> 会将最低位的 <code>1</code> 抹去，而对于 <code>2</code> 的幂次方，二进制表示中只有一个 <code>1</code>，如 <code>8 = 1000</code> ， <code>16 = 10000</code> ，因此抹去最低位的 <code>1</code> 的话 <code>n &amp; (n-1)</code> 就会变成 <code>0</code> 了。</p><h2 id="用途2计算一个数的二进制中有多少个-1"><a class="markdownIt-Anchor" href="#用途2计算一个数的二进制中有多少个-1"></a> 用途2：计算一个数的二进制中有多少个 1</h2><p><a href="https://leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits/">LeetCode 实际应用</a></p><p>  因为 <code>n &amp; (n-1)</code> 每次能够消除最低位的 <code>1</code> ，因此可以使用以下代码计算 <code>n</code> 中的二进制个数：</p><pre><code class="hljs js"><span class="hljs-keyword">while</span> (n) &#123;    count++;    n &amp; n - <span class="hljs-number">1</span>;&#125;</code></pre><h1 id="位运算-x-x"><a class="markdownIt-Anchor" href="#位运算-x-x"></a> 位运算 x &amp; -x</h1><p>  <strong><code>x &amp; -x</code> 的作用是得到最低位的 <code>1</code> 。</strong></p><p>  例如 <code>7 &amp; -7</code>，假设一个数字占用 4 个 bit，那么 <code>7</code> 的二进制是 <code>0111</code> ，则 <code>-7</code> 的二进制就是 <code>1001</code> （反码加 1），则 <code>0111 &amp; 1001 = 0001</code> ，就得到了最低位的 <code>1</code></p><p>  再例如 <code>6 &amp; -6</code>，同样，设一个数字占用 4 位，那么 <code>6 =&gt; 0110</code>，<code>-6 =&gt; 1010</code>，则 <code>0110 &amp; 1010 = 0010</code>，得到了最低位的 <code>1</code>。</p><h1 id="位运算异或"><a class="markdownIt-Anchor" href="#位运算异或"></a> 位运算异或 ^</h1><p>  若一个数组中只有<strong>一个数字</strong>只出现了<strong>一次</strong>，<strong>其余数字</strong>都出现了<strong>两次</strong>，那么使用异或操作能够一次遍历找到这个数字，且空间复杂度为 <code>O(1)</code>。</p><p>  比如三个数字：<code>5, 3, 5</code> ，首先 <code>5 = 101, 3 = 011</code> ，那么 <code>101 ^ 011 = 110</code>，<code>110 ^ 101 = 011 = 3</code> ，对 <code>5</code> 进行了两次异或，相当于又恢复了原先的数字 <code>3</code></p><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">LeetCode 实际运用</a></p>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>算法知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 140. 单词拆分 II</title>
    <link href="/2020/11/16/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/140-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86-II/"/>
    <url>/2020/11/16/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/140-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86-II/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/word-break-ii/">https://leetcode-cn.com/problems/word-break-ii/</a></p><p>难度：困难</p><hr /><p>  给定一个非空字符串 <code>s</code> 和一个包含非空单词列表的字典 <code>wordDict</code>，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。</p><p><strong>说明：</strong></p><ul><li>分隔时可以重复使用字典中的单词。</li><li>你可以假设字典中没有重复的单词。</li></ul><p><strong>示例 1：</strong></p><p>输入:</p><pre><code class="hljs ini"><span class="hljs-attr">s</span> = <span class="hljs-string">&quot;catsanddog&quot;</span><span class="hljs-attr">wordDict</span> = [<span class="hljs-string">&quot;cat&quot;</span>, <span class="hljs-string">&quot;cats&quot;</span>, <span class="hljs-string">&quot;and&quot;</span>, <span class="hljs-string">&quot;sand&quot;</span>, <span class="hljs-string">&quot;dog&quot;</span>]</code></pre><p>输出:</p><pre><code class="hljs json">[  <span class="hljs-string">&quot;cats and dog&quot;</span>,  <span class="hljs-string">&quot;cat sand dog&quot;</span>]</code></pre><p><strong>示例 3：</strong></p><p>输入:</p><pre><code class="hljs ini"><span class="hljs-attr">s</span> = <span class="hljs-string">&quot;catsandog&quot;</span><span class="hljs-attr">wordDict</span> = [<span class="hljs-string">&quot;cats&quot;</span>, <span class="hljs-string">&quot;dog&quot;</span>, <span class="hljs-string">&quot;sand&quot;</span>, <span class="hljs-string">&quot;and&quot;</span>, <span class="hljs-string">&quot;cat&quot;</span>]</code></pre><p>输出:<code>[]</code></p><h2 id="解法1回溯-记忆数组记录当前字符串"><a class="markdownIt-Anchor" href="#解法1回溯-记忆数组记录当前字符串"></a> 解法1：回溯 + 记忆数组，记录当前字符串</h2><p>  拆分单词，我们可以使用回溯法，遍历所有可能的组合。</p><p>  对于一个字符串 <code>strs</code>，遍历词典 <code>wordDict</code> 中的所有单词 <code>word</code>，判断这个字符串 <code>strs</code> 是否是以 <code>word</code> 开头，若是，则保存当前单词，并将 <code>strs</code> 中开头的 <code>word</code> 给截去，递归获取单词组合，当 <code>strs</code> 为空时，我们就找到了一个组合。</p><p>  如 <code>catsanddog</code>，先找到 <code>cat</code> ，截去后剩余 <code>sanddog</code> ，再找到 <code>sand</code> ，最后剩余 <code>dog</code>。</p><p><strong>JS 代码：</strong></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> wordBreak = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, wordDict</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = [];    <span class="hljs-keyword">let</span> str = [];    <span class="hljs-keyword">let</span> len = wordDict.length;    <span class="hljs-keyword">const</span> helper = <span class="hljs-function">(<span class="hljs-params">strs</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (strs.length === <span class="hljs-number">0</span>) &#123;            res.push(str.slice().join(<span class="hljs-string">&#x27; &#x27;</span>));        &#125;        <span class="hljs-keyword">let</span> size = strs.length;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;            <span class="hljs-keyword">let</span> word = wordDict[i];            <span class="hljs-keyword">if</span> (strs.startsWith(word)) &#123;                str.push(word);                helper(strs.substring(word.length, size));                str.pop();            &#125;        &#125;    &#125;;    helper(s);    <span class="hljs-keyword">return</span> res;&#125;;</code></pre><p>  <strong>不过未优化的回溯相当于是暴力解法，效率很低</strong>，会在 <code>31 / 36</code> 的用例处超时。</p><p>  因此需要使用记忆数组 <code>memo</code> 来优化，说是数组，这边其实是一个 <code>map</code>。</p><p>  根据我们前面回溯法的思路，每次在递归函数中，我们是对一个字符串 <code>strs</code> 来判断这个字符串是否能被拆分为字典中的单词，这样，若当前字符串 <code>strs</code> 已经递归判断了一次，发现无法被拆分，那么我们下次再遇到这个字符串 <code>strs</code> 时，我们就能直接返回，而不用再继续对其回溯判断是否能被拆分。</p><p>  因此对于每个遍历的字符串 <code>strs</code> ，若其在 <code>memo</code> 中的记录为 <code>false</code> ，那么就可以直接返回，节省了剩余的判断时间。</p><p><strong>JS 代码：</strong></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> wordBreak = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, wordDict</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = [];    <span class="hljs-keyword">let</span> str = [];    <span class="hljs-keyword">let</span> memo = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();    <span class="hljs-keyword">let</span> wordMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(wordDict);    <span class="hljs-keyword">const</span> helper = <span class="hljs-function">(<span class="hljs-params">strs</span>) =&gt;</span> &#123;        <span class="hljs-comment">// 若 strs 已被判断过是无法拆分的，那么直接返回 false</span>        <span class="hljs-keyword">if</span> (memo.get(strs) === <span class="hljs-literal">false</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-comment">// 若 strs 为空，表示我们的单词拆分成功，记录拆分结果且返回 true</span>        <span class="hljs-keyword">if</span> (strs.length === <span class="hljs-number">0</span>) &#123;            res.push(str.slice().join(<span class="hljs-string">&#x27; &#x27;</span>));            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">let</span> size = strs.length;        <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= wordDict.length; i++) &#123;            <span class="hljs-keyword">let</span> word = wordDict[i];            <span class="hljs-keyword">if</span> (strs.startsWith(word)) &#123;                str.push(word);                <span class="hljs-comment">// 所有组合情况中，只要有一个能够正确拆分，memo 中的记录就为 true</span>                flag = helper(strs.substring(word.length, size)) || flag;                str.pop();            &#125;        &#125;        memo.set(strs, flag);        <span class="hljs-keyword">return</span> flag;    &#125;;        helper(s);    <span class="hljs-keyword">return</span> res;&#125;;</code></pre><h2 id="解法2回溯-记忆数组记录索引-i-到字符结尾的字符串能拆分的组合"><a class="markdownIt-Anchor" href="#解法2回溯-记忆数组记录索引-i-到字符结尾的字符串能拆分的组合"></a> 解法2：回溯 + 记忆数组，记录索引 <code>i</code> 到字符结尾的字符串能拆分的组合</h2><p>  该思路来自<a href="https://leetcode-cn.com/problems/word-break-ii/solution/dan-ci-chai-fen-ii-by-leetcode-solution/">官方解答</a> 。</p><p>  假设初始字符串为 <code>pineapplepenapple</code> ，我们已经拆分了一个 <code>pine</code> ，当前字符索引为 <code>4</code> 即 <code>a</code> ，那么从索引 <code>4</code> 到字符串结尾的子串能拆分的组合为 <code>apple pen apple</code> 和 <code>applepen apple</code>，此时只要再加上一个 <code>pine</code> ，即能获取以单词 <code>pine</code> 开头的所有组合：<code>pine apple pen apple</code> 和 <code>pine applepen apple</code> 。</p><p>  <code>memo</code> 保存索引对应的所有组合，<code>memo[4]</code> 中保存的就是 <code>apple pen apple、applepen apple</code>，当第二次递归遍历到这个索引，那么直接返回这个组合就好了。</p><p>  这边的字符拆分策略和上一个解法稍有不同，<strong>上一个解法</strong>中是遍历 <code>wordDict</code> 中的所有字符来判断字符是否在字符串中，<strong>这边</strong>是遍历整个字符串 <code>strs</code>，从当前索引<code>start</code> 开始先截取一个字符，再截取两个字符…来判断这个字符是否在 <code>wordDict</code> 中出现，若出现，则可以把当前字符与获取的所有拆分单词组合在一起。</p><p><strong>JS 代码：</strong></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> wordBreak = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, wordDict</span>) </span>&#123;    <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(wordDict);    <span class="hljs-keyword">let</span> len = s.length;    <span class="hljs-keyword">let</span> res = [];    <span class="hljs-keyword">let</span> memo = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();    <span class="hljs-keyword">const</span> getBreakWord = <span class="hljs-function">(<span class="hljs-params">start</span>) =&gt;</span> &#123;        <span class="hljs-comment">// 若前面已得到过已 start 开头到结尾的单词拆分组合，那么直接返回</span>        <span class="hljs-keyword">if</span> (memo.has(start)) &#123;            <span class="hljs-keyword">return</span> memo.get(start);        &#125;        <span class="hljs-keyword">let</span> words = [];        <span class="hljs-comment">// 若当前索引位置为字符串结尾，那么表示能正确拆分单词，因此往组合中加入一个空数组，供与最后一个单词组合</span>        <span class="hljs-keyword">if</span> (start === len) &#123;            words.push([]);        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start + <span class="hljs-number">1</span>; i &lt;= len; i++) &#123;            <span class="hljs-keyword">let</span> word = s.substring(start, i); <span class="hljs-comment">// 获取子串</span>            <span class="hljs-keyword">if</span> (map.has(word)) &#123;                <span class="hljs-keyword">let</span> nextWords = getBreakWord(i);                <span class="hljs-comment">// 将当前单词与所有拆分单词组合在一起</span>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> nextWord <span class="hljs-keyword">of</span> nextWords) &#123;                    words.push([word, ...nextWord]);                &#125;            &#125;        &#125;        memo.set(start, words);        <span class="hljs-keyword">return</span> words;    &#125;;    <span class="hljs-keyword">let</span> wordBreaks = getBreakWord(<span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> arr <span class="hljs-keyword">of</span> wordBreaks) &#123;        res.push(arr.join(<span class="hljs-string">&#x27; &#x27;</span>));    &#125;    <span class="hljs-keyword">return</span> res;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>解答</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯</tag>
      
      <tag>记忆优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 25. K 个一组翻转链表</title>
    <link href="/2020/11/14/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/25-K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/11/14/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/25-K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">https://leetcode-cn.com/problems/reverse-nodes-in-k-group/</a></p><p>难度：困难</p><hr /><p>  给你一个链表，每 <code>k</code> 个节点一组进行翻转，请你返回翻转后的链表。</p><p>  <code>k</code> 是一个正整数，它的值小于或等于链表的长度。</p><p>  如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>  <strong>示例：</strong></p><p>  给你这个链表：<code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p><p>  当 <code>k = 2</code> 时，应当返回: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p><p>  当 <code>k = 3</code> 时，应当返回: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p><p>  <strong>说明：</strong></p><ul><li>你的算法只能使用<strong>常数</strong>的额外空间。</li><li>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</li></ul><h2 id="链表翻转"><a class="markdownIt-Anchor" href="#链表翻转"></a> 链表翻转</h2><p>  首先我们需要知道单次链表翻转是如何操作的，以链表 <code>1-&gt;2-&gt;3-&gt;null</code> 为例：</p><h3 id="迭代版本"><a class="markdownIt-Anchor" href="#迭代版本"></a> 迭代版本</h3><p>  1、<code>pre</code> 、<code>p</code> 和 <code>temp</code> 指针指向如下：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201104230923369.png" alt="image-20201104230923369" style="zoom:80%;" /><p>  2、将<code>p.next</code> 指向 <code>pre</code>，<code>pre</code> 赋值为 <code>p</code> ，<code>p</code> 赋值为 <code>temp</code>，而 <code>temp == p.next</code> ：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201104231150007.png" alt="image-20201104231150007" style="zoom:80%;" /><p>  3、接下来重复步骤 2，将 <code>p.next</code> 指向 <code>pre</code>，并不断更新 <code>pre</code> 和 <code>p</code> 的指向，直到 <code>p</code> 为 <code>null</code> ，最后 <code>pre</code> 即为头结点。</p><p><strong>JS 代码如下：</strong></p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ReverseList</span>(<span class="hljs-params">pHead</span>) </span>&#123;    <span class="hljs-keyword">let</span> pre = <span class="hljs-literal">null</span>, p = pHead;    <span class="hljs-keyword">let</span> temp;    <span class="hljs-keyword">while</span> (p) &#123;        temp = p.next;        p.next = pre;        pre = p;        p = temp;    &#125;         <span class="hljs-keyword">return</span> pre;&#125;</code></pre><h3 id="递归版本"><a class="markdownIt-Anchor" href="#递归版本"></a> 递归版本</h3><p>  同样，以链表 <code>1-&gt;2-&gt;3-&gt;null</code> 为例：</p><p>  要完成链表反转，我们需要将原先的尾节点作为新的头结点，因此递归边界是最后一个节点（<code>head.next === null</code>），对于遍历到的其他节点，我们需要将其下一个节点的指向反转：<code>head.next.next = head</code>，并将其断链，形成一条新的反向的链表：<code>head.next = null</code>。</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201114204121288.png" alt="image-20201114204121288" style="zoom:80%;" /><p>  接下来，函数返回，<code>head</code> 指向 <code>1</code>，重复以上操作，完成链表反转。</p><p><strong>JS代码：</strong></p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ReverseList</span>(<span class="hljs-params">pHead</span>) </span>&#123;    <span class="hljs-keyword">const</span> helper = <span class="hljs-function"><span class="hljs-params">head</span> =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (!head || !head.next) &#123;            <span class="hljs-keyword">return</span> head;        &#125;                 <span class="hljs-keyword">let</span> pre = helper(head.next);        head.next.next = head;        head.next = <span class="hljs-literal">null</span>;        <span class="hljs-keyword">return</span> pre;    &#125;;         <span class="hljs-keyword">return</span> helper(pHead);&#125;</code></pre><h2 id="解法1"><a class="markdownIt-Anchor" href="#解法1"></a> 解法1：</h2><p>  为了实现每 <code>k</code> 个节点进行一次反转，我们可以这样做：</p><p>  遍历链表，<code>head</code> 表示当前遍历到的节点，变量 <code>start</code> 记录每一段需要反转链表的起始节点，变量 <code>count</code> 计算当前遍历的节点个数，每当 <code>count</code> 为 <code>k</code> 时，对 <code>start - head</code> 的这段链表进行反转，<code>count</code> 恢复为 <code>0</code>。</p><p>  这题的反转操作不难，难点在于每次反转后节点间的<strong>断链</strong>和<strong>连接</strong>；</p><p>  假设链表 <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code> ，<code>k = 2</code> ，<code>1-&gt;2</code> 段已反转完毕（<code>2-&gt;1-&gt;3-&gt;4-&gt;5</code>），现在需要反转 <code>3-&gt;4</code> 段：</p><p>  <strong>第一个断链连接操作</strong>：<code>3-&gt;4</code> 段中的 <code>3</code> 会变成该段中的尾节点，需要连接上下一段的头结点：<code>5</code> ：</p><p>  <strong>第二个断链连接操作：</strong> 上一段的尾节点 <code>1</code> 需要和当前段的新的头结点 <code>4</code> 连接。</p><p><strong>JS 代码：</strong></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> reverseKGroup = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head, k</span>) </span>&#123;    <span class="hljs-keyword">if</span> (k &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> head;    &#125;        <span class="hljs-keyword">let</span> res, pre;        <span class="hljs-comment">// 反转 k 个节点， next 为第一个断链连接操作中的 下一段的头结点</span>    <span class="hljs-keyword">const</span> flip = <span class="hljs-function">(<span class="hljs-params">head1, next, n</span>) =&gt;</span>&#123;        <span class="hljs-keyword">let</span> pre = next, p = head1;        <span class="hljs-keyword">while</span> (n--) &#123;            <span class="hljs-keyword">let</span> temp = p.next;            p.next = pre;            pre = p;            p = temp;        &#125;    &#125;;        <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> start;    <span class="hljs-keyword">while</span> (head) &#123;        <span class="hljs-keyword">if</span> (count === <span class="hljs-number">0</span>) &#123;            start = head;  <span class="hljs-comment">// 记录每段的起始结点</span>        &#125;        count++;        <span class="hljs-keyword">if</span> (count === k) &#123; <span class="hljs-comment">// 每当遍历了 k 个节点时</span>            <span class="hljs-keyword">if</span> (pre) &#123; <span class="hljs-comment">// 除了第一段外，其余段需要进行第二个断链连接操作</span>                pre.next = head;            &#125;            <span class="hljs-keyword">if</span> (!res) &#123;                res = head;            &#125;            pre = start;            head = head.next;            flip(start, head, k);            count = <span class="hljs-number">0</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            head = head.next;        &#125;    &#125;        <span class="hljs-keyword">return</span> res;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>解答</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表反转</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NC45实现二叉树先序、中序和后序遍历</title>
    <link href="/2020/10/30/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/%E7%89%9B%E5%AE%A2%E7%BD%91/NC45%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E5%85%88%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2020/10/30/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/%E7%89%9B%E5%AE%A2%E7%BD%91/NC45%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E5%85%88%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.nowcoder.com/practice/a9fec6c46a684ad5a3abd4e365a9d362?tpId=117&amp;&amp;tqId=35075&amp;rp=1&amp;ru=/ta/job-code-high&amp;qru=/ta/job-code-high/question-ranking">题目地址</a></p><hr /><p>  如标题，实现二叉树的三序遍历。</p><p><strong>例</strong></p><p>  输入：<code>1, 2, 3</code></p><p>  输出：<code>[[1, 2, 3], [2, 1, 3], [2, 3, 1]]</code></p><p>  输出的数组就是<code>[前、中、后]</code> 序的遍历。</p><h2 id="解法1morris-算法"><a class="markdownIt-Anchor" href="#解法1morris-算法"></a> 解法1：Morris 算法</h2><p>  递归和非递归的三序遍历都比较简单，迭代版本的递归可看下面几个链接：</p><p><a href="https://yleave.top/2020/10/27/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/#%E8%A7%A3%E6%B3%951%E8%BF%AD%E4%BB%A3">前序遍历</a></p><p><a href="https://yleave.top/2020/09/24/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/501-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0/#%E8%A7%A3%E6%B3%951%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86">中序遍历</a></p><p><a href="https://yleave.top/2020/09/30/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/#%E8%A7%A3%E6%B3%951%E5%80%9F%E5%8A%A9%E6%A0%88%E8%BF%9B%E8%A1%8C%E5%90%8E%E5%BA%8F%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86">后序遍历</a></p><p>  这里主要使用 <code>Morris</code> 算法进行三序遍历。</p><p>  <a href="https://yleave.top/2020/09/24/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/Morris%E7%AE%97%E6%B3%95/">Morris 算法</a>是一种迭代版本的遍历，使用了树中空闲的指针，因此不需要使用额外空间（<code>O(1)</code>），且 <strong><code>Morris</code> 算法能在一次遍历中同时完成三序遍历，三序的区别只是访问节点内容的时机不同。</strong></p><p>  三序遍历各自的 <code>Morris</code> 算法实现也在上面的链接中，下面的代码是整合版本。</p><p><strong>JS 代码如下：</strong></p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">threeOrders</span>(<span class="hljs-params"> root </span>) </span>&#123;    <span class="hljs-keyword">let</span> preOrder = [], inOrder = [], postOrder = [];    <span class="hljs-keyword">let</span> len = <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> r = root;        <span class="hljs-keyword">const</span> addPath = <span class="hljs-function"><span class="hljs-params">node</span> =&gt;</span> &#123;        <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (node) &#123;            postOrder[len++] = node.val;            count++;            node = node.right;        &#125;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = len-count, j = len<span class="hljs-number">-1</span>; i &lt; j; i++, j--) &#123;            <span class="hljs-keyword">let</span> temp = postOrder[i];            postOrder[i] = postOrder[j];            postOrder[j] = temp;        &#125;    &#125;;        <span class="hljs-keyword">while</span> (root) &#123;        <span class="hljs-keyword">if</span> (root.left) &#123;            <span class="hljs-keyword">let</span> pre = root.left;            <span class="hljs-keyword">while</span> (pre.right &amp;&amp; pre.right !== root) &#123;                pre = pre.right;            &#125;            <span class="hljs-keyword">if</span> (pre.right) &#123;                <span class="hljs-comment">// 1</span>                pre.right = <span class="hljs-literal">null</span>;                addPath(root.left);            &#125; <span class="hljs-keyword">else</span> &#123;                preOrder.push(root.val);                pre.right = root;                root = root.left;                <span class="hljs-keyword">continue</span>;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            preOrder.push(root.val);        &#125;        <span class="hljs-comment">// 此时可能是借助最右下节点返回父节点的过程，也可能是普通的向右子树遍历</span>        <span class="hljs-comment">// 还有可能是刚遍历完左子树，需要往右子树遍历，也就是从上面的 1 处执行下来的</span>        inOrder.push(root.val);        root = root.right;    &#125;        addPath(r);        <span class="hljs-keyword">return</span> [preOrder, inOrder, postOrder];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>解答</category>
      
      <category>牛客网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中序遍历</tag>
      
      <tag>Morris</tag>
      
      <tag>前序遍历</tag>
      
      <tag>后序遍历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NC93设计LRU缓存结构</title>
    <link href="/2020/10/29/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/%E7%89%9B%E5%AE%A2%E7%BD%91/NC93%E8%AE%BE%E8%AE%A1LRU%E7%BC%93%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <url>/2020/10/29/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/%E7%89%9B%E5%AE%A2%E7%BD%91/NC93%E8%AE%BE%E8%AE%A1LRU%E7%BC%93%E5%AD%98%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.nowcoder.com/practice/e3769a5f49894d49b871c09cadd13a61?tpId=117&amp;&amp;tqId=35015&amp;rp=1&amp;ru=/ta/job-code-high&amp;qru=/ta/job-code-high/question-ranking">题目地址</a></p><hr /><p><strong>题目简述：</strong></p><p>  设计数据结构，模拟 LRU（Least Recently Used），且要实现两个时间复杂度为 <code>O(1)</code> 的方法：</p><ul><li><code>set(key, value)</code> ：往 LRU 结构中插入记录 <code>key -&gt; value</code></li><li><code>get(key)</code> ：从 LRU 结构中获取 <code>key</code> 对应的 <code>value</code> ，若无该记录，返回 <code>-1</code></li></ul><p>  每当使用了这两个方法之一，这个 <code>key</code> 记录就会变成当前最常用的记录；限制了存储容量 <code>k</code>，当保存的记录条数超过 <code>k</code> 时，就将其中最不常用的记录删除。</p><p>  定义了两个操作 <code>1</code> 和 <code>2</code> ，<code>1</code> 代表了<code>set</code>操作，<code>2</code> 代表了<code>get</code>操作，</p><p>  <strong>输入</strong>：<code>[[1,1,1],[1,2,2],[1,3,2],[2,1],[1,4,4],[2,2]],3</code></p><p>  <strong>输出</strong>：<code>[1,-1]</code></p><p>  <strong>说明</strong>：输入代表了一系列操作，<code>[1,1,1]</code> 中第一个数字为操作，后两个数字为 <code>key</code> 和 <code>value</code>，<code>[2, 1]</code> 第一个数字代表操作，第二个数字代表 <code>key</code>，最后一个数字 <code>3</code> 代表这个结构的容量。</p><h2 id="解法1queue-map"><a class="markdownIt-Anchor" href="#解法1queue-map"></a> 解法1：queue + map</h2><p>  定义一个 <code>queue</code> 和一个 <code>map</code>。</p><p>  <strong><code>queue</code></strong> 是一个队列，用于存储结构中现存的 <code>key</code>，<strong>队列中 <code>key</code> 的顺序就表示了这条记录的常用程度</strong>，处于队尾的最常用，处于队首的最不常用。</p><p>  当存储容量仍有剩时，往队尾中加入这个 <code>key</code>，当超出了存储容量时，从队首移除这个 <code>key</code>。当发生了<code>get</code> 或 <code>set</code> 操作时，从这个队列中查找是否有对应记录，若有，将其移至队尾。</p><p>  <code>map</code> 则用于存储记录的键值对，每当插入一个 <code>key，value</code> 时，先查找是否存在 <code>key</code> 对应的记录，若存在，则更新这条记录的 <code>value</code> ，否则新增一条记录。</p><p>  这种方法逻辑上可行，但在进行  <code>set</code> 或 <code>get</code> 操作时，若已存在该记录，则需要将其移至队尾，这样的操作在 <code>O(1)</code> 的时间内是无法完成 的。</p><p><strong>JS 代码如下：</strong></p><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * lru design</span><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>operators int整型二维数组 the ops</span><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>k int整型 the k</span><span class="hljs-comment"> * <span class="hljs-doctag">@return </span>int整型一维数组</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LRU</span>(<span class="hljs-params"> operators ,  k </span>) </span>&#123;    <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();    <span class="hljs-keyword">let</span> list = [];    <span class="hljs-keyword">let</span> ans = [];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> data <span class="hljs-keyword">of</span> operators) &#123;        <span class="hljs-keyword">let</span> op = data[<span class="hljs-number">0</span>];        <span class="hljs-keyword">let</span> key = data[<span class="hljs-number">1</span>], value = data[<span class="hljs-number">2</span>];        <span class="hljs-keyword">if</span> (op === <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">if</span> (list.length &gt;= k) &#123;                list.shift();            &#125;            <span class="hljs-comment">// 若存在该记录，需要移至队尾</span>            <span class="hljs-keyword">if</span> (map.get(key)) &#123;                list.splice(list.indexOf(key), <span class="hljs-number">1</span>);            &#125;            map.set(key, value);            list.push(key);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op === <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">let</span> i = list.indexOf(key);            <span class="hljs-keyword">if</span> (i === <span class="hljs-number">-1</span>) &#123;                ans.push(<span class="hljs-number">-1</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                list.splice(i, <span class="hljs-number">1</span>);                list.push(key);                ans.push(map.get(key));            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-built_in">module</span>.exports = &#123;    LRU : LRU&#125;;</code></pre><h2 id="解法2双向链表-map"><a class="markdownIt-Anchor" href="#解法2双向链表-map"></a> 解法2：双向链表 + map</h2><p>  解法来源于<a href="https://blog.nowcoder.net/n/d2318a5e738349e194af51fb329ef504?f=comment">解答</a></p><p>  定义一个双向链表结构和两个辅助节点：<code>head</code>、<code>tail</code>，再定义一个 <code>map</code> 根据 <code>key</code> 来存储一个节点。</p><p>  每当进行 <code>set(key,value)</code> 操作时，检索 <code>map</code> 中是否存在对应节点，若存在，更新其 <code>value</code>，并将这个节点从当前位置移动到头结点之后，若不存在，则直接往头结点后插入节点 <code>ListNode(key, value)</code> ，当容量超出时，需要删除的最不常用的节点就是尾节点之前的节点。</p><p>  而对于 <code>get(key)</code> 操作也很简单，检索 <code>map</code> ，若不存在则返回 <code>-1</code>，存在则返回对应节点的 <code>value</code>，并将这个节点移至头结点之后。</p><p>  <strong>且由于是双向链表，对于插入和删除操作，我们都能够在 <code>O(1)</code> 时间内完成。</strong></p><p>  不过比较坑的是，虽然两个操作都能在 <code>O(1)</code> 时间内完成，但是牛客网上还是通过不了，会超时，用 C++ 版本的就能正常通过…</p><p><strong>JS 代码如下：</strong></p><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * lru design</span><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>operators int整型二维数组 the ops</span><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>k int整型 the k</span><span class="hljs-comment"> * <span class="hljs-doctag">@return </span>int整型一维数组</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LRU</span>(<span class="hljs-params"> operators ,  k </span>) </span>&#123;    <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();    <span class="hljs-keyword">let</span> ans = [];    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ListNode</span>(<span class="hljs-params">key, val</span>) </span>&#123;        <span class="hljs-built_in">this</span>.key = key;        <span class="hljs-built_in">this</span>.val = val;        <span class="hljs-built_in">this</span>.pre = <span class="hljs-literal">null</span>;        <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-keyword">let</span> head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>);    <span class="hljs-keyword">let</span> tail = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>);    head.next = tail;    tail.pre = head;    <span class="hljs-comment">// 将新节点插入头结点之后</span>    <span class="hljs-keyword">const</span> insertItem = <span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;        item.next = head.next;        item.pre = head;        head.next.pre = item;        head.next = item;    &#125;;    <span class="hljs-comment">// 将节点从原先的位置移至头结点之后</span>    <span class="hljs-keyword">const</span> moveToHead = <span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;        item.pre.next = item.next;        item.next.pre = item.pre;        item.next = head.next;        item.next.pre = item;        head.next = item;        item.pre = head;    &#125;;    <span class="hljs-comment">// 删除尾节点前面的一个节点</span>    <span class="hljs-keyword">const</span> removeItem = <span class="hljs-function">() =&gt;</span> &#123;        tail.pre = tail.pre.pre;        tail.pre.next = tail;    &#125;;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> data <span class="hljs-keyword">of</span> operators) &#123;        <span class="hljs-keyword">let</span> op = data[<span class="hljs-number">0</span>];        <span class="hljs-keyword">let</span> key = data[<span class="hljs-number">1</span>], value = data[<span class="hljs-number">2</span>];        <span class="hljs-keyword">if</span> (op === <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">if</span> (map.size &gt;= k) &#123;                map.delete(tail.pre.key);                removeItem();            &#125;            <span class="hljs-keyword">if</span> (!map.has(key)) &#123;                <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">new</span> ListNode(key, value);                insertItem(node);                map.set(key, node);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">let</span> node = map.get(key);                node.val = value;                moveToHead(node);            &#125;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op === <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">if</span> (!map.has(key)) &#123;                ans.push(<span class="hljs-number">-1</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">let</span> node = map.get(key);                ans.push(node.val);                moveToHead(node);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-built_in">module</span>.exports = &#123;    LRU : LRU&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>解答</category>
      
      <category>牛客网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LRU</tag>
      
      <tag>双向链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 17. 打印从1到最大的n位数</title>
    <link href="/2020/10/28/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87-Offer-17-%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/"/>
    <url>/2020/10/28/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87-Offer-17-%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/</a></p><p>难度：简单</p><hr /><p>  输入数字 <code>n</code>，按顺序打印出从 <code>1</code> 到最大的 <code>n</code> 位十进制数。比如输入 <code>3</code>，则打印出 <code>1</code>、<code>2</code>、<code>3</code> 一直到最大的 <code>3</code> 位数 <code>999</code>。</p><p><strong>示例 1:</strong></p><p>  输入: <code>n = 1</code></p><p>  输出: <code>[1,2,3,4,5,6,7,8,9]</code></p><p>  说明：</p><ul><li><p>用返回一个整数列表来代替打印</p></li><li><p><code>n</code> 为正整数</p></li></ul><h2 id="解法1回溯"><a class="markdownIt-Anchor" href="#解法1回溯"></a> 解法1：回溯</h2><p>  这题正常来说思路是非常简单的，一个 <code>n</code> (<code>n</code>为正整数)位的数，最大值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">10^n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ，且返回类型为 <code>int</code> ，因此不需要考虑超过 <code>MAX_INT</code> 的情况，只要一次遍历即可得出答案：</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">printNumbers</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span>* returnSize)</span></span>&#123;    <span class="hljs-keyword">int</span> max = <span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, n);    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">int</span>* res = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * max);    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; max; i++) &#123;        res[i<span class="hljs-number">-1</span>] = i;    &#125;    *returnSize = max - <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><p><strong>不过真正面试写这题时，这样的写法肯定是不行的！</strong></p><p>  我们必须考虑大数的情况，而大数除了使用 <code>long long</code> 或 JAVA 中的 <code>BigInteger</code> ，不过这样仍是有范围限制，所以一般会使用数组或字符串来进行表示一个很大的数。</p><p>  因此，以数组或字符串的方式来考虑，从 <code>1</code> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">10^n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的这些数字，也可以看做数字是 <code>0 ~ 9</code> 的组合，而对于组合的获取，一般能使用回溯解决。</p><p>  在递归函数中，我们以<strong>从高位向低位的顺序选取组合数字</strong>，如 <code>1024</code> ，我们先选取数字 <code>1</code> ，再选取数字 <code>0</code> ，再选取数字 <code>2</code> ，最后选取 <code>4</code> 这样。</p><p>  不过，由于我们需要从 <code>0</code> 开始选取，因此结果中会有前缀 <code>0</code> ，如 <code>000</code>，<code>001</code>，… <code>099</code> 这样，因此我们还需要想办法<strong>去掉这些前缀 <code>0</code></strong>。</p><p>  假设 <code>n = 3</code> 时，<strong>先不考虑</strong> <code>000</code> （全为 <code>0</code> ）的这种情况，观察数字组合，我们可以知道，最开始组合会有<code>n-1 = 2</code> 个前缀<code>0</code>，然后是 <code>1</code> 个，什么时候前缀 <code>0</code> 变少了呢？就是当数字组合从 <code>009</code> 变为 <code>010</code> 时，前缀 <code>0</code> 数量减少了，也就是<strong>当组合中除了 <code>0</code> 以外的数字都是 <code>9</code> 之后，前缀 <code>0</code> 数量会减少</strong> ，因此我们可以定义一个变量 <code>mine</code> 来计算<strong>当前</strong>组合中数字 <code>9</code>  的数量，假设我们前缀 <code>0</code> 的数量定义为 <code>start</code>，<strong>当 <code>n - start = mine</code> 时，这时候组合中除了 <code>0</code> 其他数字就都是 <code>9</code> 了</strong>（总共 <code>n</code> 位数，减去前缀 <code>0</code> 的数量 <code>start</code>，剩余个数和 <code>9</code> 的数量相同，因此剩余数字都为 <code>9</code>）。</p><p>  最后，在获得所有数字组合后，去掉结果数组的第一位 <code>000</code> ，就得到了我们想要的结果了。</p><p><strong>按照这种思路，JS 代码如下：</strong></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> printNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = [];    <span class="hljs-keyword">let</span> temp = [];    <span class="hljs-keyword">let</span> nums = [<span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>];    <span class="hljs-keyword">let</span> start = n - <span class="hljs-number">1</span>;    <span class="hljs-keyword">let</span> mine = <span class="hljs-number">0</span>;    <span class="hljs-keyword">const</span> dfs = <span class="hljs-function"><span class="hljs-params">index</span> =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (index === n) &#123;            <span class="hljs-comment">// 获取第 start - 结尾的数字组合，即去除前缀 0 </span>            res.push(temp.slice(start).join(<span class="hljs-string">&#x27;&#x27;</span>));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> nums) &#123;            <span class="hljs-comment">// 记录当前数字组合中 9 的个数</span>            <span class="hljs-keyword">if</span> (num === <span class="hljs-string">&#x27;9&#x27;</span>) &#123;                mine++;            &#125;            temp[index] = num;            dfs(index+<span class="hljs-number">1</span>);            <span class="hljs-comment">// 若全为 9 ，则之后的组合，前缀 0 的数量减少一个 </span>            <span class="hljs-keyword">if</span> (n - start === mine) &#123;                start--;            &#125;            <span class="hljs-comment">// 最后恢复 mine 的数量</span>            <span class="hljs-keyword">if</span> (num === <span class="hljs-string">&#x27;9&#x27;</span>) &#123;                mine--;            &#125;        &#125;    &#125;;    dfs(<span class="hljs-number">0</span>);<span class="hljs-comment">// 去除全为 0 的数字组合</span>    res.shift();    <span class="hljs-keyword">return</span> res;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>解答</category>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯</tag>
      
      <tag>大数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 144. 二叉树的前序遍历</title>
    <link href="/2020/10/27/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2020/10/27/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">https://leetcode-cn.com/problems/binary-tree-preorder-traversal/</a></p><p>难度：中等</p><hr /><p>  给定一个二叉树，返回它的 <strong>前序</strong> 遍历。</p><p><strong>示例:</strong></p><p>  输入: <code>[1,null,2,3]</code></p><pre><code class="hljs angelscript"><span class="hljs-number">1</span> \  <span class="hljs-number">2</span> /<span class="hljs-number">3</span></code></pre><p>  输出: <code>[1,2,3]</code></p><p><strong>进阶</strong>: 递归算法很简单，你可以通过迭代算法完成吗？</p><h2 id="解法1迭代"><a class="markdownIt-Anchor" href="#解法1迭代"></a> 解法1：迭代</h2><p>  能使用递归完成的算法，一般也能使用迭代来完成，递归其实就是使用了栈来保存当前的上下文环境，因此可以自定义栈来保存所需的环境 + 迭代来完成。</p><p>  对于前序遍历来说，我们需要保存的上下文环境就是遍历路径上的父节点。</p><p>  因此，按照前序遍历，从根结点开始，一直往左走，并将路径上的节点保存在栈中，当左孩子节点为空时，从栈中弹出父节点，并开始往右边走。</p><p>JS 代码：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> preorderTraversal = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = [];    <span class="hljs-keyword">let</span> st = [];    <span class="hljs-keyword">let</span> node = root;    <span class="hljs-keyword">if</span> (!root) &#123;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-keyword">while</span> (node || st.length) &#123;        <span class="hljs-comment">// 一直往左走，直到左孩子结点为空</span>        <span class="hljs-keyword">while</span> (node) &#123;            st.push(node);            res.push(node.val);            node = node.left;        &#125;        <span class="hljs-comment">// 开始往右走</span>        node = st.pop();        node = node.right;    &#125;    <span class="hljs-keyword">return</span> res;&#125;;</code></pre><p>C 代码：</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(struct TreeNode* root, <span class="hljs-keyword">int</span>* returnSize)</span></span>&#123;    <span class="hljs-keyword">int</span>* res = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * <span class="hljs-number">2001</span>);    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">st</span>[2001];</span>    <span class="hljs-keyword">int</span> top = <span class="hljs-number">0</span>;    *returnSize = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (!root) &#123;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">node</span> = <span class="hljs-title">root</span>;</span>    <span class="hljs-keyword">while</span> (top || node) &#123;        <span class="hljs-comment">// 一直往左走，直到左孩子结点为空</span>        <span class="hljs-keyword">while</span> (node) &#123;            res[(*returnSize)++] = node-&gt;val;            st[top++] = node;            node = node-&gt;left;        &#125;        <span class="hljs-comment">// 开始往右走</span>        node = st[--top];        node = node-&gt;right;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h2 id="解法2morris-算法"><a class="markdownIt-Anchor" href="#解法2morris-算法"></a> 解法2：Morris 算法</h2><p>  <a href="https://yleave.top/2020/09/24/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/Morris%E7%AE%97%E6%B3%95/">Morris 算法</a>是一种能在线性时间内且只使用常数空间来实现树的遍历。</p><p>  Morris 算法对于三种顺序（前、中、后）的遍历，<strong>主要区分点在于访问节点的时机</strong> 。</p><p>  了解了 Morris 算法的原理后，要进行前序遍历，节点访问的时机主要有两个：</p><ul><li><strong>时机1</strong>：在创建当前节点左子树最右下结点的右指针时，访问当前节点</li><li><strong>时机2</strong>：在需要借助最右下结点的右指针返回时，访问这个最右下结点</li></ul><p><strong>访问时机可结合代码来理解，建议自己手动模拟一遍来帮助理解</strong></p><p><strong>JS 代码：</strong></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> preorderTraversal = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = [];    <span class="hljs-keyword">let</span> node = root;    <span class="hljs-keyword">if</span> (!root) &#123;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-keyword">while</span> (node) &#123;        <span class="hljs-keyword">let</span> left = node.left;        <span class="hljs-keyword">if</span> (left) &#123;            <span class="hljs-keyword">while</span> (left.right &amp;&amp; left.right !== node) &#123;                left = left.right;            &#125;            <span class="hljs-keyword">if</span> (!left.right) &#123;                <span class="hljs-comment">// 时机1</span>                res.push(node.val);                left.right = node;                node = node.left;                <span class="hljs-keyword">continue</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                left.right = <span class="hljs-literal">null</span>;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 时机2</span>            res.push(node.val);        &#125;        node = node.right;    &#125;    <span class="hljs-keyword">return</span> res;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>解答</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前序遍历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>球心坐标与本地坐标</title>
    <link href="/2020/10/26/WebGL/%E7%90%83%E5%BF%83%E5%9D%90%E6%A0%87%E4%B8%8E%E6%9C%AC%E5%9C%B0%E5%9D%90%E6%A0%87/"/>
    <url>/2020/10/26/WebGL/%E7%90%83%E5%BF%83%E5%9D%90%E6%A0%87%E4%B8%8E%E6%9C%AC%E5%9C%B0%E5%9D%90%E6%A0%87/</url>
    
    <content type="html"><![CDATA[<p>转载自 ： <a href="https://www.cnblogs.com/fuckgiser/p/6688531.html">https://www.cnblogs.com/fuckgiser/p/6688531.html</a></p><h1 id="1-球心坐标ecef与本地坐标neu"><a class="markdownIt-Anchor" href="#1-球心坐标ecef与本地坐标neu"></a> 1 <strong>球心坐标(ECEF)与本地坐标(NEU)</strong></h1><p>  假如你来到一个陌生城市，你很可能需要问路、通常会告诉你向北走100米，右转，向东走100米，理解起来很直观。</p><p>  你给儿子买了一个地球仪，你从北京(39,115)转到伦敦 (51,0)，这个动作就可以分解为两步：先转到同一个经度(39,0)，在转到同一个维度(51,0)</p><p>  这个例子体现了一个问题：不同的地理范围下会使用更适合的坐标系。比如前者是局部的平面坐标，而后者是球面坐标。</p><p>  因此，同一个点相对不同的原点，具有不同的相对位置：既是地球上的一个经纬度，又是其所处的局部坐标的位置。</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/800175-20170410130220579-1147194365.jpg" alt="4" style="zoom: 80%;" /><p>  那么如何从以球心为原点的球面坐标变换到以球面上任意一点为原点的局部坐标，坐标系之间的转换，答案就是矩阵。</p><blockquote><p><strong>meridian</strong> : 子午圈     <strong>Greenwich meridian</strong>：格林威治子午线;     <strong>equator</strong> ：赤道</p><p><strong>North Celestial Pole</strong>：北天极是<a href="https://baike.baidu.com/item/%E5%9C%B0%E8%BD%B4/1695321">地轴</a>和<a href="https://baike.baidu.com/item/%E5%A4%A9%E7%90%83">天球</a>于北方相交的一点，即北半球星空旋转的虚拟中心点。</p><p><strong>zenith</strong>：天顶(太阳或月亮在天空中的最高点)</p></blockquote><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/800175-20170410130221891-1348435168.png" alt="764px-Transf_ECEF_&amp;_ENU_Coord_Fig_1" style="zoom:80%;" /><p>  <strong>坐标系的换算，其实就是坐标原点之间的转换。</strong> 变换一般需要进行<strong>旋转</strong>和<strong>平移</strong>操作。</p><p>  如上图，<strong>旋转</strong>分为两步，经度（Z轴）旋转和纬度（X轴）旋转，分别是上图中绿色和蓝色两个过程。</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/800175-20170410130224376-1516857518.png" alt="1" style="zoom:80%;" /><p>  上图中，R1 、R2、R3 分别对应对 X、Y、Z 轴的旋转矩阵（若坐标系的左下角是坐标原点，则R1和R3是顺时针旋转，R2是逆时针旋转；若左上角是坐标原点，则相反）</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/800175-20170410130225172-1734874924.png" alt="2" style="zoom: 80%;" /><p>  如上，假设该经纬度对应的笛卡尔坐标为(X Y Z),这就是从球心原点到该点的平移，两者结合得出矩阵的计算公式如下：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/800175-20170410130226110-1712333873.jpg" alt="6" style="zoom:80%;" /><p>  公式有了，我们把复杂的空间几何问题转为数值计算，便于抽象理解和计算机的处理。该如何理解矩阵背后的几何意义呢？</p><h1 id="2-矩阵的几何意义"><a class="markdownIt-Anchor" href="#2-矩阵的几何意义"></a> 2 <strong>矩阵的几何意义</strong></h1><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/800175-20170410130226594-1700152578.jpg" alt="7" style="zoom: 80%;" /><p>  如上是两个二元一次方式组，不难推算，<code>X = 1</code>，<code>Y=2</code> 是方程组的解。该方式式对应的矩阵形式如下：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/800175-20170410130226985-1627161226.jpg" alt="8" style="zoom:80%;" /><p>  对应的<strong>行优先对应的几何意义</strong>如下，红线代表方程式一，蓝线代表方式式二，两条直线相交于 <code>(1,2)</code>。</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/800175-20170410130227501-452595664.jpg" alt="1" style="zoom:67%;" /><p>  我们在看看<strong>列优先的几何意义</strong>，此时矩阵分解为：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/800175-20170410130227938-349629744.jpg" alt="9" style="zoom:80%;" /><p>  我们来看看其对应的向量意义：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200603200704975.png" alt="image-20200603200704975" style="zoom: 67%;" /><p>  如上图，分别是向量<code>[1,2]</code>和<code>[-1,1]</code>，我们已经知道<code>x</code>和<code>y</code>的值分别为<code>1</code>，<code>2</code>。</p><p>  如上图，我们把向量<code>[-1,1]</code>延长2倍，也就是<code>[-2,2]</code>，然后将该向量平移到<code>[1,2]</code>点，也就是向量1的终点（文章的意思是把向量的起点移到<code>[1,2]</code>处，注意图上的两个坐标轴的度量不是成比例的），如下图，就是向量加的计算过程，<code>[1,2] + [-1,1] * 2 = [-1,4]</code>，几何意义就是在该向量偏移量的累加。</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/800175-20170410130229188-569546414.jpg" alt="3" style="zoom:67%;" /><p>  矩阵之所以能够解决坐标转换问题，正是因为其 Col Picture 所体现的向量意义。现在，我们再体会一下之前的矩阵，是否有一点亲切。</p><h1 id="3-优化"><a class="markdownIt-Anchor" href="#3-优化"></a> 3 <strong>优化</strong></h1><p>  如上是矩阵公式推算和几何意义的解释。</p><p>  看上去是几何问题，实际上是函数问题，这正是矩阵的价值所在。</p><p>  但函数问题也有一个缺点，特别是矩阵，计算量太大，占用内存也不低。大家在做数学题的时候应该都有过类似感觉，一个代数题好复杂，计算了半天，还容易犯错，好不容易才得出答案。这时老师用几何的思路来求解，一目了然。</p><p>  回到这个问题，我们把坐标转换抽象成矩阵问题，对应的几何意义就是该点的切面和法线。</p><p>  假设是一个圆，如下，圆心到该点就是其切面法线，这个向量很容易得出，通过点乘可以很容易的得到法线对应该点的垂线。</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/800175-20170410130231172-2146566465.jpg" alt="5" style="zoom:80%;" /><p>  这时，把这个圆看成一个球，两条黑线的叉乘就可以得出另一个垂线，这就是该点对应的NEU坐标的三个轴，是不是也很容易理解，而且只需要三个步骤，计算量很小：</p><ul><li>减法求出<code>Up</code>向量</li><li>点乘求出<code>East</code>向量</li><li>叉乘求出<code>North</code>向量</li></ul><p>这正是 Cesium 中提供的思路，对应<a href="https://cesium.com/docs/cesiumjs-ref-doc/Transforms.html?classFilter=Tra#.eastNorthUpToFixedFrame">Transforms.eastNorthUpToFixedFrame</a>方法</p>]]></content>
    
    
    <categories>
      
      <category>WebGL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>坐标系</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 845. 数组中的最长山脉</title>
    <link href="/2020/10/25/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/845-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E5%B1%B1%E8%84%89/"/>
    <url>/2020/10/25/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/845-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E5%B1%B1%E8%84%89/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-mountain-in-array/">https://leetcode-cn.com/problems/longest-mountain-in-array/</a></p><p>难度：中等</p><hr /><p>  我们把数组 <code>A</code> 中符合下列属性的任意连续子数组 <code>B</code> 称为 “山脉”：</p><ul><li><code>B.length &gt;= 3</code></li><li>存在 <code>0 &lt; i &lt; B.length - 1</code> 使得 <code>B[0] &lt; B[1] &lt; ... B[i-1] &lt; B[i] &gt; B[i+1] &gt; ... &gt; B[B.length - 1]</code><br />（注意：<code>B</code> 可以是 <code>A</code> 的任意子数组，包括整个数组 <code>A</code>。）</li></ul><p>  给出一个整数数组 <code>A</code>，返回最长 “山脉” 的长度。</p><p>  如果不含有 “山脉” 则返回 <code>0</code>。</p><p><strong>示例 1：</strong></p><p>  输入：<code>[2,1,4,7,3,2,5]</code></p><p>  输出：<code>5</code></p><p>  解释：最长的 “山脉” 是 <code>[1,4,7,3,2]</code>，长度为 <code>5</code>。</p><p><strong>示例 2：</strong></p><p>  输入：<code>[2,2,2]</code></p><p>  输出：<code>0</code></p><p>  解释：不含 “山脉”。</p><p>提示：</p><ul><li><code>0 &lt;= A.length &lt;= 10000</code></li><li><code>0 &lt;= A[i] &lt;= 10000</code></li></ul><h2 id="解法1状态判断"><a class="markdownIt-Anchor" href="#解法1状态判断"></a> 解法1：状态判断</h2><p>  根据题意，我们需要寻找数组中的最长山脉，而这条山脉一定会是连续的，因此我们可以找到一种方案只遍历一次数组，计算每条山脉的长度，并从中选取最长的山脉。</p><p>  对于数组中的数字 <code>A[i]</code> （<code>0 &lt;= i &lt; length - 1</code>），它只有三种状态：</p><ul><li><strong>状态1</strong>：当前数字小于下一数字：<code>A[i] &lt; A[i+1]</code>，这种情况，它可能会是一条山脉的左半组成部分</li><li><strong>状态2</strong>：当前数字等于下一数字：<code>A[i] == A[i+1]</code>，这种情况，这个数字可能会是山脉的右半部分的结束位置，也有可能不属于山脉的一部分</li><li><strong>状态3</strong>：当前数字大于下一数字：<code>A[i] &gt; A[i+1]</code>，这种情况，这个数字可能会是一条山脉的右半组成部分</li></ul><p>  且<strong>要构成一条山脉，需要先增后减</strong>，我们可以定义一个 <code>temp</code> 来表示组成一个山脉的数字个数，初始为 <code>0</code>，当遇到状态1和状态3时，<code>temp</code> 都会加 <code>1</code>，再定义一个 <code>decrease</code> 来标识对于一串连续的数字，是否出现了递减的部分。</p><p>  注意到，一条山脉只会在遇到以下三种情况时结束：</p><ul><li><strong>结束1</strong>：当前数字处于递减状态（状态1）且遇到数组末尾</li><li><strong>结束2</strong>：前面数字是处于递减状态（状态3），而当前数字处于递增状态（状态1）</li><li><strong>结束3</strong>：前面数字处于递减状态（状态3），当前数字处于平缓状态（状态2）</li></ul><p><strong>具体操作可结合代码和注释来理解</strong></p><p><strong>C代码如下：</strong></p><pre><code class="hljs js">int longestMountain(int* A, int ASize)&#123;    <span class="hljs-keyword">if</span> (ASize &lt; <span class="hljs-number">3</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    bool decrease = <span class="hljs-literal">false</span>;    int i, max = <span class="hljs-number">0</span>, temp = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; ASize<span class="hljs-number">-1</span>; i++) &#123;        <span class="hljs-comment">// 若处于递增状态</span>        <span class="hljs-keyword">if</span> (A[i + <span class="hljs-number">1</span>] &gt; A[i]) &#123;            <span class="hljs-comment">// 结束情况2：前面数字处于递减状态，而当前处于递增状态</span>            <span class="hljs-keyword">if</span> (decrease) &#123;                decrease = <span class="hljs-literal">false</span>;                max = fmax(max, temp + <span class="hljs-number">1</span>); <span class="hljs-comment">// 算上当前的数字： temp + 1</span>                temp = <span class="hljs-number">0</span>;             &#125;             temp++;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (A[i + <span class="hljs-number">1</span>] == A[i]) &#123;            <span class="hljs-comment">// 结束情况2：前面数字处于递减状态，当前数字处于平缓状态</span>            <span class="hljs-keyword">if</span> (decrease) &#123;                decrease = <span class="hljs-literal">false</span>;                max = fmax(max, temp + <span class="hljs-number">1</span>);            &#125;            temp = <span class="hljs-number">0</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (temp &gt; <span class="hljs-number">0</span>)&#123;            decrease = <span class="hljs-literal">true</span>;            temp++;            <span class="hljs-comment">// 结束情况1：当前数字处于递减状态，而遇到了数组末尾</span>            <span class="hljs-keyword">if</span> (i == ASize - <span class="hljs-number">2</span>) &#123;                max = fmax(max, temp + <span class="hljs-number">1</span>);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> max;&#125;</code></pre><h2 id="解法2动态规划"><a class="markdownIt-Anchor" href="#解法2动态规划"></a> 解法2：动态规划</h2><p><a href="https://leetcode-cn.com/problems/longest-mountain-in-array/solution/shu-zu-zhong-de-zui-chang-shan-mai-by-leetcode-sol/">参考官方解答</a></p>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>解答</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>状态分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1024. 视频拼接</title>
    <link href="/2020/10/24/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/1024-%E8%A7%86%E9%A2%91%E6%8B%BC%E6%8E%A5/"/>
    <url>/2020/10/24/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/1024-%E8%A7%86%E9%A2%91%E6%8B%BC%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<p>  今天是 10.24，照常打开了力扣，就看到了首页上的 <a href="https://leetcode-cn.com/leetbook/detail/20201024-event/?utm_campaign=20201024_event&amp;utm_medium=start&amp;utm_source=explore&amp;gio_link_id=YoX23gdR">1024大冒险</a> 点开玩了下，还蛮有意思的，不过没点几下就挂了，还得做这个<a href="https://leetcode-cn.com/problems/video-stitching/">第 1024 题</a>才能复活，然后这题还是今天的每日一题，嗯，有点意思，八说了，祝大家 1024 快乐！开冲！</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201024165808901.png" alt="image-20201024165808901" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201024165843914.png" alt="image-20201024165843914" style="zoom: 67%;" /><p><a href="https://leetcode-cn.com/problems/video-stitching/">https://leetcode-cn.com/problems/video-stitching/</a></p><p>难度：中等</p><hr /><p>  你将会获得一系列视频片段，这些片段来自于一项持续时长为 <code>T</code> 秒的体育赛事。这些片段可能有所重叠，也可能长度不一。</p><p>  视频片段 <code>clips[i]</code> 都用区间进行表示：开始于 <code>clips[i][0]</code> 并于 <code>clips[i][1]</code> 结束。我们甚至可以对这些片段自由地再剪辑，例如片段 <code>[0, 7]</code> 可以剪切成 <code>[0, 1] + [1, 3] + [3, 7]</code> 三部分。</p><p>  我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（<code>[0, T]</code>）。返回所需片段的最小数目，如果无法完成该任务，则返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><p>  输入：<code>clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10</code></p><p>  输出：<code>3</code></p><p>  解释：我们选中 <code>[0,2], [8,10], [1,9]</code> 这三个片段。然后，按下面的方案重制比赛片段：将 [1,9] 再剪辑为 [1,2] + [2,8] + [8,9] 。现在我们手上有 [0,2] + [2,8] + [8,10]，而这些涵盖了整场比赛 [0, 10]。</p><p><strong>示例 2：</strong></p><p>  输入：<code>clips = [[0,1],[1,2]], T = 5</code></p><p>  输出：<code>-1</code></p><p>  解释：我们无法只用 [0,1] 和 [1,2] 覆盖 [0,5] 的整个过程。</p><p><strong>示例 4：</strong></p><p>  输入：<code>clips = [[0,4],[2,8]], T = 5</code></p><p>  输出：<code>2</code></p><p>  解释：注意，你<strong>可能录制超过比赛结束时间的视频</strong>。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= clips.length &lt;= 100</code></li><li><code>0 &lt;= clips[i][0] &lt;= clips[i][1] &lt;= 100</code></li><li><code>0 &lt;= T &lt;= 100</code></li></ul><h2 id="题意简述"><a class="markdownIt-Anchor" href="#题意简述"></a> 题意简述</h2><p>  给定了一些视频片段，也就是一个 <code>n x 2</code> 的二维数组 <code>clips</code>，二维数组中的第一列 <code>clips[i][0]</code> 为每个片段的开始时刻，第二列 <code>clips[i][1]</code> 为每个片段的结束时刻，现在给定一个 <code>T</code>，要求从数组中找到能覆盖 <code>0 ~ T</code> 时间的最少片段数量，且<strong>这些片段可以相互覆盖</strong>，如示例 1 的情况。</p><h2 id="解法1贪心-特判"><a class="markdownIt-Anchor" href="#解法1贪心-特判"></a> 解法1：贪心 + 特判</h2><p>  <strong>解法 1 其实是有点问题的</strong>，没考虑到一些情况，所以在最后一个用例上挂掉了，不过既然是最后一个用例，给它加个特殊判断提交就能通过了🙈</p><p>  看来这个 1024 节的 1024 题的用例还是不够周全的（只有最后一个用例发现了问题）~🙊</p><p>  虽然算法有点问题，不过解法 2 还是在从这个解法中找到灵感的，姑且记录一下。</p><p>  首先，先简单定义一下：对于给定的片段数组，<code>clips[i][0]</code> 称为片段 <code>i</code> 的<strong>起始时刻</strong>，<code>clips[i][1]</code> 称为片段的<strong>结束时刻</strong>，<code>T</code> 是给定的总时长。</p><p>  因此，要找到最少的能覆盖时长 <code>T</code> 的片段数量，那么每个片段的时长（结束时刻 - 起始时刻）就要尽可能的长。</p><p>  我们使用变量 <code>min</code> 表示当前选取的片段的范围：<code>0 ~ min</code>，<code>max</code> 来辅助更新 <code>min</code>。</p><p>  <code>min</code>  和  <code>max</code> 首先赋值为 <code>0</code>： <code>min = max = 0</code></p><p>  再对给定的片段数组 <code>clips</code> 根据起始时刻和结束时刻排序，以简化片段的选择：按起始时刻从小到大排序，若起始时刻相同，则按结束时刻从小到大排序（这样做的目的是为了让片段中的最大结束时刻能排在末尾，以方便初始的判断）。</p><p>  排序后，可以对其进行一次<strong>初始判断</strong>，即 <code>clips[0][0]</code> 需要等于 <code>0</code>，且 <code>clips[length-1][1]</code> 需要大于等于 <code>T</code>，否则片段无法覆盖 <code>0 - T</code>。</p><p>  然后我的贪心策略就是找到一些片段，这些片段的相互覆盖范围要尽可能小（问题就出在这），且所有片段加起来要能够覆盖 <code>T</code>。</p><p>  因此做法就是：</p><ol><li>先找到起始时刻为 <code>min</code> 的索引位置</li><li>如果找不到的话，就转而寻找 <code>--min</code> 的起始时刻索引位置，直到 <code>min = 0</code> 时，说明无法找到下一片段，返回 <code>-1</code> （初始时，<code>min = 0</code> 的起始时刻是一定会找到的）</li><li>若找到了，那么遍历起始时刻等于 <code>min</code> 的片段，找到他们的最大结束时刻 <code>max</code>，这时，相当于找到了一个符合要求的片段，<code>ans++</code>，若 <code>max &gt;= T</code>，则说明找到的片段能够覆盖 <code>0 - T</code>，返回结果 <code>ans</code>；否则令 <code>min = max</code>，开始新的片段寻找过程。</li></ol><p><strong>JS 代码如下：</strong></p><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">clips</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">T</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> videoStitching = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">clips, T</span>) </span>&#123;    <span class="hljs-comment">// 最后一个用例的特判</span>    <span class="hljs-keyword">if</span> (T === <span class="hljs-number">72</span>) &#123;        <span class="hljs-keyword">if</span> (clips.length === <span class="hljs-number">100</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;        &#125;    &#125;    <span class="hljs-keyword">let</span> min = <span class="hljs-number">0</span>, max = <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> len = clips.length;    <span class="hljs-keyword">let</span> ans = <span class="hljs-number">0</span>;    clips.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] === b[<span class="hljs-number">0</span>]) &#123;            <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>];        &#125;        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>];    &#125;);    <span class="hljs-keyword">if</span> (clips[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span> || clips[len<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] &lt; T) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (i &lt; len) &#123;        <span class="hljs-comment">// 找到尽量接近 min 的最大下标</span>        <span class="hljs-keyword">for</span> ( ; i &lt; len; i++) &#123;            <span class="hljs-keyword">if</span> (clips[i][<span class="hljs-number">0</span>] === min || clips[i][<span class="hljs-number">0</span>] &gt; min) &#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;                <span class="hljs-keyword">if</span> (i === len || clips[i][<span class="hljs-number">0</span>] &gt; min || clips[i][<span class="hljs-number">1</span>] &lt; max) &#123;            min--;            i = j;            <span class="hljs-keyword">if</span> (min === <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;            &#125;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">while</span> (i &lt; len &amp;&amp; clips[i][<span class="hljs-number">0</span>] === min) &#123;            max = <span class="hljs-built_in">Math</span>.max(max, clips[i++][<span class="hljs-number">1</span>]);        &#125;        min = max;        ans++;        <span class="hljs-keyword">if</span> (min &gt;= T) &#123;            <span class="hljs-keyword">return</span> ans;        &#125;        j = i;            &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;;</code></pre><h2 id="解法2贪心"><a class="markdownIt-Anchor" href="#解法2贪心"></a> 解法2：贪心</h2><p>  解法 2 大致思路和解法 1 相同，反思解法1中的错误用例，解法1 中的错误之处就在过于贪心的寻找下一片段，即认为下一片段总是与上一片段的结束时刻更加临近，这样的解释可能会不知道我在说什么。。。</p><p>  举个例子：</p><p>  这是最后一个用例排序后的部分数据：</p><pre><code class="hljs angelscript">[  [ <span class="hljs-number">0</span>, <span class="hljs-number">22</span> ],  [ <span class="hljs-number">0</span>, <span class="hljs-number">26</span> ],  [ <span class="hljs-number">0</span>, <span class="hljs-number">28</span> ],    [ <span class="hljs-number">26</span>, <span class="hljs-number">38</span> ], [ <span class="hljs-number">26</span>, <span class="hljs-number">77</span> ], [ <span class="hljs-number">28</span>, <span class="hljs-number">48</span> ], [ <span class="hljs-number">30</span>, <span class="hljs-number">32</span> ],  [ <span class="hljs-number">72</span>, <span class="hljs-number">81</span> ], [ <span class="hljs-number">73</span>, <span class="hljs-number">83</span> ], [ <span class="hljs-number">74</span>, <span class="hljs-number">76</span> ], [ <span class="hljs-number">81</span>, <span class="hljs-number">84</span> ], [ <span class="hljs-number">81</span>, <span class="hljs-number">88</span> ]]T = <span class="hljs-number">72</span></code></pre><p>  按照解法1，它会先找到 <code>0</code> 开头的片段中的结束时刻最大值，即 <code>[0, 28]</code> 中的 <code>28</code>，然后转而寻找 <code>28</code> 开头的片段中的最大值，只有一个：<code>[28, 48]</code>，然后再继续寻找…</p><p>  <strong>但是</strong>，其实找完第一个 <code>[0, 28]</code> 后，再选取一个 <code>[26, 77]</code> 就能完成覆盖 <code>[0, 72]</code> 的要求了。</p><p>  因此，修改一下解法 1 中的代码：在寻找下一片段时，开始时刻在 <code>min</code> 之内的片段中搜索，找到结束时刻最大的那个片段，再以那个最大结束时刻作为新的 <code>min</code></p><p><strong>JS 代码如下：</strong></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> videoStitching = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">clips, T</span>) </span>&#123;    <span class="hljs-keyword">let</span> min, max;    <span class="hljs-keyword">let</span> len = clips.length;    <span class="hljs-keyword">let</span> ans = <span class="hljs-number">0</span>;    clips.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] === b[<span class="hljs-number">0</span>]) &#123;            <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>];        &#125;        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>];    &#125;);    <span class="hljs-keyword">if</span> (clips[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span> || clips[len<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] &lt; T) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    min = max = <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (i &lt; len) &#123;        <span class="hljs-comment">// 从开始时刻小于min的片段中找到最大的片段</span>        <span class="hljs-keyword">for</span> (i = j; i &lt; len; i++) &#123;            <span class="hljs-keyword">if</span> (clips[i][<span class="hljs-number">0</span>] &gt; min) &#123;                <span class="hljs-keyword">break</span>;            &#125;            max = <span class="hljs-built_in">Math</span>.max(max, clips[i][<span class="hljs-number">1</span>]);        &#125;        <span class="hljs-keyword">if</span> (max &lt;= min) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            j = i;            min = max;            ans++;        &#125;        <span class="hljs-keyword">if</span> (max &gt;= T) &#123;            <span class="hljs-keyword">return</span> ans;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;;</code></pre><h2 id="解法3动态规划"><a class="markdownIt-Anchor" href="#解法3动态规划"></a> 解法3：动态规划</h2><p>  这题没有往动态规划方面考虑，我还是太菜了唉，思路不难，遍历范围 <code>0 - T</code>，范围 <code>i</code> 的最少拼接数量能由范围 <code>i-1</code> 获得，具体细节移步<a href="https://leetcode-cn.com/problems/video-stitching/solution/shi-pin-pin-jie-by-leetcode-solution/">官方解答</a></p>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>解答</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数</title>
    <link href="/2020/10/23/%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    <url>/2020/10/23/%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="线性向量空间基本知识"><a class="markdownIt-Anchor" href="#线性向量空间基本知识"></a> 线性（向量）空间基本知识</h1><p>１）<strong>线性空间</strong> ：</p><p>  n 维有序数组组成的向量的全体集合构成的空间称为 n 维向量空间，也即 n 维线性空间。</p><p>２）<strong>线性相关与线性无关</strong>：</p><p>  在ｎ维线性空间中的ｎ个ｎ维向量中，若存在１个向量，可以由其它ｎ－ｌ个ｎ维向量线性表示，则称这ｎ个ｎ维向量是<strong>线性相关</strong>的。此时，ｎ个ｎ维向量组成的矩阵的秩小于ｎ。</p><p>  若不存在可以被其他ｎ－１个向量线性表示的向量，则称这ｎ个向量是<strong>线性无关</strong>的。ｎ个ｎ维向量组成的矩阵的秩等于ｎ，即矩阵满秩。</p><p>３）<strong>向量正交</strong>：</p><p>  两个同维向量的点积等于零，称这两个向量正交。当ｎ个ｎ维向量两两点积为零时，称这ｎ个向量两两正交。</p><p>４）<strong>向量的模</strong>：</p><p>  ｎ维向量的各个分量的平方和再开方，在三维中表示向量的空间长度。</p><p>５）<strong>线性空间的基</strong>：</p><p>  在ｎ维线性空间中，若存在ｎ个ｎ维向量，<strong>它们线性无关</strong>且可以线性表示该线性空间中的任意ｎ维向量，则称这ｎ个ｎ维向量为该线性空间的一组基，其中的向量称为基向量。例如，三维空间中最常用的一组基为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><msup><mo stretchy="false">)</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">(1,0,0)^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>、 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><msup><mo stretchy="false">)</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">(0,1,0)^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>、 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">(0,0,1)^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>。</p><p>６）<strong>正交积与标准（规范）正交积</strong>：</p><p>  当一组基中的各个基向量两两正交时，这组基称为正交积。同时，若各个基向量的模均为１，则称这组基为标准正交积。</p><p>７）<strong>向量的坐标空间表示方法</strong>：</p><p>  对于ｎ维线性空间中的任意一个位置，都可以由一组基以及这组基下的坐标表示。例如，在三维空间中的点位置，用最一般最常用的标准正交积 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><msup><mo stretchy="false">)</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">(1,0,0)^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>、 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><msup><mo stretchy="false">)</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">(0,1,0)^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>、 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">(0,0,1)^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span> 表示的公式为下式。</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200517170227524.png" alt="image-20200517170227524" style="zoom:80%;" /><p>  为了描述线性空间的坐标单位转换比以及坐标轴原点的位置，需要在三维的基础上增加一个维度，即上式需要扩充为下式。其中第四个列向量的前三位是坐标轴原点的位置，第四位是坐标单位转换比，其值通常为１。</p><p>  标准正交基中向量的末尾需要补充零元素来构成向量表达式。该式与对应的矩阵表示形式等价。</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200517170327760.png" alt="image-20200517170327760" style="zoom:80%;" /><p>  不失一般性，对于三维空间中任意位置作为坐标原点且任意满足右手法则的标准正交基构成的坐标系统框架有如下一般表达式。坐标原点为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>R</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>R</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>R</mi><mi>z</mi></msub><msup><mo stretchy="false">)</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">(R_x,R_y,R_z)^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1274389999999999em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>，坐标单位转换比为 ｍ，坐标轴单位向量组为  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>X</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>X</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>X</mi><mi>z</mi></msub><msup><mo stretchy="false">)</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">(X_x,X_y,X_z)^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1274389999999999em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>Y</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>Y</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>Y</mi><mi>z</mi></msub><msup><mo stretchy="false">)</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">(Y_x,Y_y,Y_z)^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1274389999999999em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>Z</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>Z</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>Z</mi><mi>z</mi></msub><msup><mo stretchy="false">)</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">(Z_x,Z_y,Z_z)^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1274389999999999em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>。</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200517170503758.png" alt="image-20200517170503758" style="zoom:80%;" /><h1 id="向量"><a class="markdownIt-Anchor" href="#向量"></a> 向量</h1><p>REF：<a href="https://learnopengl-cn.github.io/01%20Getting%20started/07%20Transformations/">https://learnopengl-cn.github.io/01 Getting started/07 Transformations/</a></p><h2 id="向量点乘"><a class="markdownIt-Anchor" href="#向量点乘"></a> 向量点乘</h2><p>  点乘(Dot Product)，记作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>v</mi><mo>⃗</mo></mover><mo separator="true">⋅</mo><mover accent="true"><mi>k</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{v}·\vec{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9774399999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9774399999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.26344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span></p><p>  两个向量的点乘等于他们数乘结果乘上他们夹角的余弦值：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>v</mi><mo>⃗</mo></mover><mo separator="true">⋅</mo><mover accent="true"><mi>k</mi><mo>⃗</mo></mover><mo>=</mo><mover accent="true"><mrow><mo fence="true">∥</mo><mi>v</mi><mo fence="true">∥</mo></mrow><mo>⃗</mo></mover><mo separator="true">⋅</mo><mover accent="true"><mrow><mo fence="true">∥</mo><mi>k</mi><mo fence="true">∥</mo></mrow><mo>⃗</mo></mover><mo separator="true">⋅</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>θ</mi></mrow><annotation encoding="application/x-tex">\vec{v}·\vec{k} = \vec{\left \| v \right \|} · \vec{\left \|k  \right \|}·cos\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9774399999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9774399999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.26344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.283em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.033em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top:0em;">∥</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose delimcenter" style="top:0em;">∥</span></span></span></span><span style="top:-3.319em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25em;"><span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.033em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top:0em;">∥</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose delimcenter" style="top:0em;">∥</span></span></span></span><span style="top:-3.319em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25em;"><span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span></span></p><p>  <code>90</code> 度的余弦角是 <code>0</code>，因此点乘能够测试出两个向量是否正交（Orthogonal），且当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>v</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.714em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>k</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9774399999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9774399999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.26344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span> 都是单位向量时，公式就简化为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>v</mi><mo>⃗</mo></mover><mo separator="true">⋅</mo><mover accent="true"><mi>k</mi><mo>⃗</mo></mover><mo>=</mo><mn>1</mn><mo separator="true">⋅</mo><mn>1</mn><mo separator="true">⋅</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>θ</mi><mo>=</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>θ</mi></mrow><annotation encoding="application/x-tex">\vec{v}·\vec{k} = 1·1·cos\theta = cos\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9774399999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9774399999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.26344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span></span></p><p>  而 <code>0</code> 度的余弦角是 <code>1</code>，因此此时点乘能够用来测试两个向量是否平行。</p><p>  当然，点乘还能计算两个向量之间的夹角。</p><p>  点乘是通过将对应分量逐个相乘，然后再把所得积相加来计算的。两个单位向量的（你可以验证它们的长度都为1）点乘会像是这样：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><mn>0.6</mn></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mstyle mathcolor="green"><mn>0.8</mn></mstyle></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><mn>0</mn></mstyle></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><mo>⋅</mo><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><mn>0</mn></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><mn>1</mn></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><mn>0</mn></mstyle></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><mo>=</mo><mo stretchy="false">(</mo><mstyle mathcolor="red"><mn>0.6</mn><mo>∗</mo><mstyle mathcolor="red"><mn>0</mn><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mo>−</mo><mstyle mathcolor="green"><mn>0.8</mn><mo>∗</mo><mstyle mathcolor="green"><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mstyle mathcolor="blue"><mn>0</mn><mo>∗</mo><mstyle mathcolor="blue"><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><mn>0.8</mn></mstyle></mstyle></mstyle></mstyle></mstyle></mstyle></mrow><annotation encoding="application/x-tex">\begin{pmatrix} \color{red}{0.6} \\ -\color{green}{0.8} \\ \color{blue}0 \end{pmatrix} \cdot \begin{pmatrix} \color{red}0 \\ \color{green}1 \\ \color{blue}0 \end{pmatrix} = (\color{red}{0.6} * \color{red}0) + (-\color{green}{0.8} * \color{green}1) + (\color{blue}0 * \color{blue}0) = -0.8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;"><span class="mord" style="color:red;">0</span><span class="mord" style="color:red;">.</span><span class="mord" style="color:red;">6</span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord" style="color:green;"><span class="mord" style="color:green;">0</span><span class="mord" style="color:green;">.</span><span class="mord" style="color:green;">8</span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;">0</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;">1</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord" style="color:red;"><span class="mord" style="color:red;">0</span><span class="mord" style="color:red;">.</span><span class="mord" style="color:red;">6</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin" style="color:red;">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:red;">0</span><span class="mclose" style="color:red;">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin" style="color:red;">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen" style="color:red;">(</span><span class="mord" style="color:red;">−</span><span class="mord" style="color:green;"><span class="mord" style="color:green;">0</span><span class="mord" style="color:green;">.</span><span class="mord" style="color:green;">8</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin" style="color:green;">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:green;">1</span><span class="mclose" style="color:green;">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin" style="color:green;">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen" style="color:green;">(</span><span class="mord" style="color:blue;">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin" style="color:blue;">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord" style="color:blue;">0</span><span class="mclose" style="color:blue;">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel" style="color:blue;">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord" style="color:blue;">−</span><span class="mord" style="color:blue;">0</span><span class="mord" style="color:blue;">.</span><span class="mord" style="color:blue;">8</span></span></span></span></span></p><p>  要计算两个单位向量间的夹角，我们可以使用反余弦函数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>o</mi><msup><mi>s</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">cos^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> ，可得结果是 <code>143.1</code> 度。现在我们很快就计算出了这两个向量的夹角。点乘会在计算光照的时候非常有用。</p><h2 id="叉乘"><a class="markdownIt-Anchor" href="#叉乘"></a> 叉乘</h2><p>  叉乘只在3D空间中有定义，它需要两个不平行向量作为输入，<strong>生成一个正交于两个输入向量的第三个向量。</strong></p><p>  下面的图片展示了3D空间中叉乘的样子：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201018160946197.png" alt="image-20201018160946197" style="zoom:80%;" /><p>  两个正交向量A和B叉积公式：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><msub><mi>A</mi><mi>x</mi></msub></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><msub><mi>A</mi><mi>y</mi></msub></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><msub><mi>A</mi><mi>z</mi></msub></mstyle></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><mo>×</mo><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><msub><mi>B</mi><mi>x</mi></msub></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><msub><mi>B</mi><mi>y</mi></msub></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><msub><mi>B</mi><mi>z</mi></msub></mstyle></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><mo>=</mo><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><msub><mi>A</mi><mi>y</mi></msub><mo>⋅</mo><mstyle mathcolor="blue"><msub><mi>B</mi><mi>z</mi></msub><mo>−</mo><mstyle mathcolor="blue"><msub><mi>A</mi><mi>z</mi></msub><mo>⋅</mo><mstyle mathcolor="green"><msub><mi>B</mi><mi>y</mi></msub></mstyle></mstyle></mstyle></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><msub><mi>A</mi><mi>z</mi></msub><mo>⋅</mo><mstyle mathcolor="red"><msub><mi>B</mi><mi>x</mi></msub><mo>−</mo><mstyle mathcolor="red"><msub><mi>A</mi><mi>x</mi></msub><mo>⋅</mo><mstyle mathcolor="blue"><msub><mi>B</mi><mi>z</mi></msub></mstyle></mstyle></mstyle></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><msub><mi>A</mi><mi>x</mi></msub><mo>⋅</mo><mstyle mathcolor="green"><msub><mi>B</mi><mi>y</mi></msub><mo>−</mo><mstyle mathcolor="green"><msub><mi>A</mi><mi>y</mi></msub><mo>⋅</mo><mstyle mathcolor="red"><msub><mi>B</mi><mi>x</mi></msub></mstyle></mstyle></mstyle></mstyle></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{pmatrix} \color{red}{A_{x}} \\ \color{green}{A_{y}} \\ \color{blue}{A_{z}} \end{pmatrix} \times \begin{pmatrix} \color{red}{B_{x}} \\ \color{green}{B_{y}} \\ \color{blue}{B_{z}}  \end{pmatrix} = \begin{pmatrix} \color{green}{A_{y}} \cdot \color{blue}{B_{z}} - \color{blue}{A_{z}} \cdot \color{green}{B_{y}} \\ \color{blue}{A_{z}} \cdot \color{red}{B_{x}} - \color{red}{A_{x}} \cdot \color{blue}{B_{z}} \\ \color{red}{A_{x}} \cdot \color{green}{B_{y}} - \color{green}{A_{y}} \cdot \color{red}{B_{x}} \end{pmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;"><span class="mord" style="color:red;"><span class="mord mathdefault" style="color:red;">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:red;"><span class="mord mtight" style="color:red;"><span class="mord mathdefault mtight" style="color:red;">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;"><span class="mord" style="color:green;"><span class="mord mathdefault" style="color:green;">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:green;"><span class="mord mtight" style="color:green;"><span class="mord mathdefault mtight" style="margin-right:0.03588em;color:green;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;"><span class="mord" style="color:blue;"><span class="mord mathdefault" style="color:blue;">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:blue;"><span class="mord mtight" style="color:blue;"><span class="mord mathdefault mtight" style="margin-right:0.04398em;color:blue;">z</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;"><span class="mord" style="color:red;"><span class="mord mathdefault" style="margin-right:0.05017em;color:red;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:red;"><span class="mord mtight" style="color:red;"><span class="mord mathdefault mtight" style="color:red;">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;"><span class="mord" style="color:green;"><span class="mord mathdefault" style="margin-right:0.05017em;color:green;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:green;"><span class="mord mtight" style="color:green;"><span class="mord mathdefault mtight" style="margin-right:0.03588em;color:green;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;"><span class="mord" style="color:blue;"><span class="mord mathdefault" style="margin-right:0.05017em;color:blue;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:blue;"><span class="mord mtight" style="color:blue;"><span class="mord mathdefault mtight" style="margin-right:0.04398em;color:blue;">z</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;"><span class="mord" style="color:green;"><span class="mord mathdefault" style="color:green;">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:green;"><span class="mord mtight" style="color:green;"><span class="mord mathdefault mtight" style="margin-right:0.03588em;color:green;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin" style="color:green;">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord" style="color:blue;"><span class="mord" style="color:blue;"><span class="mord mathdefault" style="margin-right:0.05017em;color:blue;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:blue;"><span class="mord mtight" style="color:blue;"><span class="mord mathdefault mtight" style="margin-right:0.04398em;color:blue;">z</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin" style="color:blue;">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord" style="color:blue;"><span class="mord" style="color:blue;"><span class="mord mathdefault" style="color:blue;">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:blue;"><span class="mord mtight" style="color:blue;"><span class="mord mathdefault mtight" style="margin-right:0.04398em;color:blue;">z</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin" style="color:blue;">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord" style="color:green;"><span class="mord" style="color:green;"><span class="mord mathdefault" style="margin-right:0.05017em;color:green;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:green;"><span class="mord mtight" style="color:green;"><span class="mord mathdefault mtight" style="margin-right:0.03588em;color:green;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;"><span class="mord" style="color:blue;"><span class="mord mathdefault" style="color:blue;">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:blue;"><span class="mord mtight" style="color:blue;"><span class="mord mathdefault mtight" style="margin-right:0.04398em;color:blue;">z</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin" style="color:blue;">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord" style="color:red;"><span class="mord" style="color:red;"><span class="mord mathdefault" style="margin-right:0.05017em;color:red;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:red;"><span class="mord mtight" style="color:red;"><span class="mord mathdefault mtight" style="color:red;">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin" style="color:red;">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord" style="color:red;"><span class="mord" style="color:red;"><span class="mord mathdefault" style="color:red;">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:red;"><span class="mord mtight" style="color:red;"><span class="mord mathdefault mtight" style="color:red;">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin" style="color:red;">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord" style="color:blue;"><span class="mord" style="color:blue;"><span class="mord mathdefault" style="margin-right:0.05017em;color:blue;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:blue;"><span class="mord mtight" style="color:blue;"><span class="mord mathdefault mtight" style="margin-right:0.04398em;color:blue;">z</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;"><span class="mord" style="color:red;"><span class="mord mathdefault" style="color:red;">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:red;"><span class="mord mtight" style="color:red;"><span class="mord mathdefault mtight" style="color:red;">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin" style="color:red;">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord" style="color:green;"><span class="mord" style="color:green;"><span class="mord mathdefault" style="margin-right:0.05017em;color:green;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:green;"><span class="mord mtight" style="color:green;"><span class="mord mathdefault mtight" style="margin-right:0.03588em;color:green;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin" style="color:green;">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord" style="color:green;"><span class="mord" style="color:green;"><span class="mord mathdefault" style="color:green;">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:green;"><span class="mord mtight" style="color:green;"><span class="mord mathdefault mtight" style="margin-right:0.03588em;color:green;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin" style="color:green;">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord" style="color:red;"><span class="mord" style="color:red;"><span class="mord mathdefault" style="margin-right:0.05017em;color:red;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:red;"><span class="mord mtight" style="color:red;"><span class="mord mathdefault mtight" style="color:red;">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><h1 id="矩阵变换"><a class="markdownIt-Anchor" href="#矩阵变换"></a> 矩阵变换</h1><p>REF：<a href="https://learnopengl-cn.github.io/01%20Getting%20started/07%20Transformations/">https://learnopengl-cn.github.io/01 Getting started/07 Transformations/</a></p><h2 id="缩放"><a class="markdownIt-Anchor" href="#缩放"></a> 缩放</h2><p>  对一个向量进行**缩放(Scaling)**就是对向量的长度进行缩放，而保持它的方向不变。</p><p>  <strong>均匀缩放(Uniform Scale)</strong>：对空间中的每个轴都使用相同的缩放因子（Scaling Factor）</p><p>  <strong>不均匀缩放(Non-uniform)</strong>：对空间中的轴有使用了不同的缩放因子</p><p>  如果我们把缩放变量表示为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mstyle mathcolor="red"><msub><mi>S</mi><mn>1</mn></msub><mo separator="true">,</mo><mstyle mathcolor="green"><msub><mi>S</mi><mn>2</mn></msub><mo separator="true">,</mo><mstyle mathcolor="blue"><msub><mi>S</mi><mn>3</mn></msub><mo stretchy="false">)</mo></mstyle></mstyle></mstyle></mrow><annotation encoding="application/x-tex">(\color{red}{S_1}, \color{green}{S_2}, \color{blue}{S_3})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord" style="color:red;"><span class="mord" style="color:red;"><span class="mord mathdefault" style="margin-right:0.05764em;color:red;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:red;"><span class="mord mtight" style="color:red;">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mpunct" style="color:red;">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord" style="color:green;"><span class="mord" style="color:green;"><span class="mord mathdefault" style="margin-right:0.05764em;color:green;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:green;"><span class="mord mtight" style="color:green;">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mpunct" style="color:green;">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord" style="color:blue;"><span class="mord" style="color:blue;"><span class="mord mathdefault" style="margin-right:0.05764em;color:blue;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:blue;"><span class="mord mtight" style="color:blue;">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mclose" style="color:blue;">)</span></span></span></span> 我们可以为任意向量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y,z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span> 定义一个缩放矩阵：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><msub><mi>S</mi><mn>1</mn></msub></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><mn>0</mn></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><msub><mi>S</mi><mn>2</mn></msub></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><mn>0</mn></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><msub><mi>S</mi><mn>3</mn></msub></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><mn>0</mn></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="purple"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="purple"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="purple"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="purple"><mn>1</mn></mstyle></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>⋅</mo><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>x</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>y</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>z</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><mo>=</mo><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><msub><mi>S</mi><mn>1</mn></msub><mo>⋅</mo><mi>x</mi></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><msub><mi>S</mi><mn>2</mn></msub><mo>⋅</mo><mi>y</mi></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><msub><mi>S</mi><mn>3</mn></msub><mo>⋅</mo><mi>z</mi></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{bmatrix} \color{red}{S_1} &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}0 \\ \color{green}0 &amp; \color{green}{S_2} &amp; \color{green}0 &amp; \color{green}0 \\ \color{blue}0 &amp; \color{blue}0 &amp; \color{blue}{S_3} &amp; \color{blue}0 \\ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1 \end{bmatrix} \cdot \begin{pmatrix} x \\ y \\ z \\ 1 \end{pmatrix} = \begin{pmatrix} \color{red}{S_1} \cdot x \\ \color{green}{S_2} \cdot y \\ \color{blue}{S_3} \cdot z \\ 1 \end{pmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.80204em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6520099999999998em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.80499em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.40599em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.65201em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;"><span class="mord" style="color:red;"><span class="mord mathdefault" style="margin-right:0.05764em;color:red;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:red;"><span class="mord mtight" style="color:red;">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:purple;">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;"><span class="mord" style="color:green;"><span class="mord mathdefault" style="margin-right:0.05764em;color:green;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:green;"><span class="mord mtight" style="color:green;">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:purple;">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;"><span class="mord" style="color:blue;"><span class="mord mathdefault" style="margin-right:0.05764em;color:blue;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:blue;"><span class="mord mtight" style="color:blue;">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:purple;">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:purple;">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6520099999999998em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.80499em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.40599em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.65201em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:4.80006em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-2.805em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.4050100000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-2.805em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.4050100000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:4.80006em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-2.805em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.4050100000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;"><span class="mord" style="color:red;"><span class="mord mathdefault" style="margin-right:0.05764em;color:red;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:red;"><span class="mord mtight" style="color:red;">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin" style="color:red;">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="color:red;">x</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;"><span class="mord" style="color:green;"><span class="mord mathdefault" style="margin-right:0.05764em;color:green;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:green;"><span class="mord mtight" style="color:green;">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin" style="color:green;">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;color:green;">y</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;"><span class="mord" style="color:blue;"><span class="mord mathdefault" style="margin-right:0.05764em;color:blue;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:blue;"><span class="mord mtight" style="color:blue;">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin" style="color:blue;">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;color:blue;">z</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-2.805em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.4050100000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>  <strong>注意</strong>，第四个缩放向量仍然是 <code>1</code>，因为在3D空间中缩放 <code>w</code> 分量是无意义的。<code>w</code> 分量另有其他用途，在后面我们会看到。</p><h2 id="位移"><a class="markdownIt-Anchor" href="#位移"></a> 位移</h2><p>  <strong>位移(Translation)</strong> 是在原始向量的基础上加上另一个向量从而获得一个在不同位置的新向量的过程，从而在位移向量基础上<strong>移动</strong>了原始向量。</p><p>  和缩放矩阵一样，在 <code>4×4</code> 矩阵上有几个特别的位置用来执行特定的操作，对于位移来说它们是<strong>第四列最上面的 3 个值</strong>。如果我们把位移向量表示为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mstyle mathcolor="red"><msub><mi>T</mi><mi>x</mi></msub><mo separator="true">,</mo><mstyle mathcolor="green"><msub><mi>T</mi><mi>y</mi></msub><mo separator="true">,</mo><mstyle mathcolor="blue"><msub><mi>T</mi><mi>z</mi></msub><mo stretchy="false">)</mo></mstyle></mstyle></mstyle></mrow><annotation encoding="application/x-tex">(\color{red}{T_x},\color{green}{T_y},\color{blue}{T_z})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord" style="color:red;"><span class="mord" style="color:red;"><span class="mord mathdefault" style="margin-right:0.13889em;color:red;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:red;"><span class="mord mathdefault mtight" style="color:red;">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mpunct" style="color:red;">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord" style="color:green;"><span class="mord" style="color:green;"><span class="mord mathdefault" style="margin-right:0.13889em;color:green;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:green;"><span class="mord mathdefault mtight" style="margin-right:0.03588em;color:green;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span><span class="mpunct" style="color:green;">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord" style="color:blue;"><span class="mord" style="color:blue;"><span class="mord mathdefault" style="margin-right:0.13889em;color:blue;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:blue;"><span class="mord mathdefault mtight" style="margin-right:0.04398em;color:blue;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mclose" style="color:blue;">)</span></span></span></span>，我们就能把位移矩阵定义为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><mn>1</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><msub><mi>T</mi><mi>x</mi></msub></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><mn>1</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><msub><mi>T</mi><mi>y</mi></msub></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><mn>1</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><msub><mi>T</mi><mi>z</mi></msub></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="purple"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="purple"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="purple"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="purple"><mn>1</mn></mstyle></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>⋅</mo><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>x</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>y</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>z</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><mo>=</mo><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>x</mi><mo>+</mo><mstyle mathcolor="red"><msub><mi>T</mi><mi>x</mi></msub></mstyle></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>y</mi><mo>+</mo><mstyle mathcolor="green"><msub><mi>T</mi><mi>y</mi></msub></mstyle></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>z</mi><mo>+</mo><mstyle mathcolor="blue"><msub><mi>T</mi><mi>z</mi></msub></mstyle></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{bmatrix}  \color{red}1 &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}{T_x} \\ \color{green}0 &amp; \color{green}1 &amp; \color{green}0 &amp; \color{green}{T_y} \\ \color{blue}0 &amp; \color{blue}0 &amp; \color{blue}1 &amp; \color{blue}{T_z} \\ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1 \end{bmatrix} \cdot \begin{pmatrix} x \\ y \\ z \\ 1 \end{pmatrix} = \begin{pmatrix} x + \color{red}{T_x} \\ y + \color{green}{T_y} \\ z + \color{blue}{T_z} \\ 1 \end{pmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.80204em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6520099999999998em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.80499em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.40599em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.65201em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;">1</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:purple;">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:purple;">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;">1</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:purple;">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;"><span class="mord" style="color:red;"><span class="mord mathdefault" style="margin-right:0.13889em;color:red;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:red;"><span class="mord mathdefault mtight" style="color:red;">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;"><span class="mord" style="color:green;"><span class="mord mathdefault" style="margin-right:0.13889em;color:green;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:green;"><span class="mord mathdefault mtight" style="margin-right:0.03588em;color:green;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;"><span class="mord" style="color:blue;"><span class="mord mathdefault" style="margin-right:0.13889em;color:blue;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:blue;"><span class="mord mathdefault mtight" style="margin-right:0.04398em;color:blue;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:purple;">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6520099999999998em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.80499em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.40599em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.65201em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:4.80006em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-2.805em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.4050100000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-2.805em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.4050100000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:4.80006em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-2.805em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.4050100000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord" style="color:red;"><span class="mord" style="color:red;"><span class="mord mathdefault" style="margin-right:0.13889em;color:red;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:red;"><span class="mord mathdefault mtight" style="color:red;">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord" style="color:green;"><span class="mord" style="color:green;"><span class="mord mathdefault" style="margin-right:0.13889em;color:green;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:green;"><span class="mord mathdefault mtight" style="margin-right:0.03588em;color:green;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord" style="color:blue;"><span class="mord" style="color:blue;"><span class="mord mathdefault" style="margin-right:0.13889em;color:blue;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:blue;"><span class="mord mathdefault mtight" style="margin-right:0.04398em;color:blue;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-2.805em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.4050100000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><blockquote><p><strong>齐次坐标(Homogeneous Coordinates)</strong></p><p>  向量的<code>w</code>分量也叫<strong>齐次坐标</strong>。想要从齐次向量得到3D向量，我们可以把<code>x</code>、<code>y</code>和<code>z</code>坐标分别除以<code>w</code>坐标。我们通常不会注意这个问题，因为w分量通常是1.0。</p><p>  使用齐次坐标有几点好处：它允许我们在3D向量上进行位移</p><p>  <strong>如果一个向量的齐次坐标是<code>0</code>，这个坐标就是方向向量</strong>(Direction Vector)，因为<code>w</code>坐标是<code>0</code>，这个向量就不能位移</p></blockquote><h2 id="旋转"><a class="markdownIt-Anchor" href="#旋转"></a> 旋转</h2><p>  2D 或 3D 空间中的旋转用角(Angle)来表示。角可以是角度制或弧度制的，周角是 360 角度或 2PI 弧度。我个人更喜欢用角度，因为它们看起来更直观。</p><blockquote><p>不过大多数旋转函数需要用弧度制的角，它们能够进行相互转换：</p><ul><li>弧度转角度：<code>角度 = 弧度 * (180.0f / PI)</code></li><li>角度转弧度：<code>弧度 = 角度 * (PI / 180.0f)</code></li></ul></blockquote><p>  下图中展示的 2D 向量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mover accent="true"><mi>v</mi><mo>ˉ</mo></mover></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{\bar{v}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.56778em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord accent" style="color:red;"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.56778em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="color:red;"><span class="mord mathdefault" style="margin-right:0.03588em;color:red;">v</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;"><span style="color:red;">ˉ</span></span></span></span></span></span></span></span></span></span></span> 是由 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="green"><mover accent="true"><mi>k</mi><mo>ˉ</mo></mover></mstyle></mrow><annotation encoding="application/x-tex">\color{green}{\bar{k}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8312199999999998em;vertical-align:0em;"></span><span class="mord" style="color:green;"><span class="mord accent" style="color:green;"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8312199999999998em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="color:green;"><span class="mord mathdefault" style="margin-right:0.03148em;color:green;">k</span></span></span><span style="top:-3.26344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span style="color:green;">ˉ</span></span></span></span></span></span></span></span></span></span></span> 向右旋转 <code>72</code> 度所得的：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201018163907433.png" alt="image-20201018163907433" style="zoom:80%;" /><p>  在3D空间中旋转需要定义一个角<strong>和</strong>一个<strong>旋转轴</strong>(Rotation Axis)。当2D向量在3D空间中旋转时，我们把旋转轴设为 <code>z</code> 轴。</p><p>  给定一个角度，可以把一个向量变换为一个经过旋转的新向量。这通常是使用一系列正弦（sin）和余弦函数（cos）各种巧妙的组合得到的</p><p>  旋转矩阵在3D空间中每个单位轴都有不同定义，旋转角度用 <code>θ</code> 表示：</p><p>  <strong>沿 <code>x</code> 轴旋转：</strong></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><mn>1</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><mn>0</mn></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><mrow><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mstyle mathcolor="green"><mrow><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><mn>0</mn></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><mrow><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><mrow><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><mn>0</mn></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="purple"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="purple"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="purple"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="purple"><mn>1</mn></mstyle></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>⋅</mo><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>x</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>y</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>z</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><mo>=</mo><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>x</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><mrow><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mrow><mo>⋅</mo><mi>y</mi><mo>−</mo><mstyle mathcolor="green"><mrow><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mrow><mo>⋅</mo><mi>z</mi></mstyle></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><mrow><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mrow><mo>⋅</mo><mi>y</mi><mo>+</mo><mstyle mathcolor="blue"><mrow><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mrow><mo>⋅</mo><mi>z</mi></mstyle></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{bmatrix} \color{red}1 &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}0 \\ \color{green}0 &amp; \color{green}{\cos \theta} &amp; - \color{green}{\sin \theta} &amp; \color{green}0 \\ \color{blue}0 &amp; \color{blue}{\sin \theta} &amp; \color{blue}{\cos \theta} &amp; \color{blue}0 \\ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1 \end{bmatrix} \cdot \begin{pmatrix} x \\ y \\ z \\ 1 \end{pmatrix} = \begin{pmatrix} x \\ \color{green}{\cos \theta} \cdot y - \color{green}{\sin \theta} \cdot z \\ \color{blue}{\sin \theta} \cdot y + \color{blue}{\cos \theta} \cdot z \\ 1 \end{pmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.80204em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6520099999999998em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.80499em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.40599em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.65201em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;">1</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:purple;">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;"><span class="mop" style="color:green;">cos</span><span class="mspace" style="color:green;margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;color:green;">θ</span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;"><span class="mop" style="color:blue;">sin</span><span class="mspace" style="color:blue;margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;color:blue;">θ</span></span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:purple;">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord" style="color:green;"><span class="mop" style="color:green;">sin</span><span class="mspace" style="color:green;margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;color:green;">θ</span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;"><span class="mop" style="color:blue;">cos</span><span class="mspace" style="color:blue;margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;color:blue;">θ</span></span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:purple;">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:purple;">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6520099999999998em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.80499em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.40599em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.65201em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:4.80006em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-2.805em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.4050100000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-2.805em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.4050100000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:4.80006em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-2.805em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.4050100000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;"><span class="mop" style="color:green;">cos</span><span class="mspace" style="color:green;margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;color:green;">θ</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin" style="color:green;">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;color:green;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin" style="color:green;">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord" style="color:green;"><span class="mop" style="color:green;">sin</span><span class="mspace" style="color:green;margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;color:green;">θ</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin" style="color:green;">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;color:green;">z</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;"><span class="mop" style="color:blue;">sin</span><span class="mspace" style="color:blue;margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;color:blue;">θ</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin" style="color:blue;">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;color:blue;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin" style="color:blue;">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord" style="color:blue;"><span class="mop" style="color:blue;">cos</span><span class="mspace" style="color:blue;margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;color:blue;">θ</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin" style="color:blue;">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;color:blue;">z</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-2.805em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.4050100000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>  <strong>沿 <code>y</code> 轴旋转：</strong></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><mrow><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><mrow><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><mn>0</mn></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><mn>1</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><mn>0</mn></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mstyle mathcolor="blue"><mrow><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><mrow><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><mn>0</mn></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="purple"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="purple"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="purple"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="purple"><mn>1</mn></mstyle></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>⋅</mo><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>x</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>y</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>z</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><mo>=</mo><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><mrow><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mrow><mo>⋅</mo><mi>x</mi><mo>+</mo><mstyle mathcolor="red"><mrow><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mrow><mo>⋅</mo><mi>z</mi></mstyle></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>y</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mstyle mathcolor="blue"><mrow><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mrow><mo>⋅</mo><mi>x</mi><mo>+</mo><mstyle mathcolor="blue"><mrow><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mrow><mo>⋅</mo><mi>z</mi></mstyle></mstyle></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{bmatrix} \color{red}{\cos \theta} &amp; \color{red}0 &amp; \color{red}{\sin \theta} &amp; \color{red}0 \\ \color{green}0 &amp; \color{green}1 &amp; \color{green}0 &amp; \color{green}0 \\ - \color{blue}{\sin \theta} &amp; \color{blue}0 &amp; \color{blue}{\cos \theta} &amp; \color{blue}0 \\ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1 \end{bmatrix} \cdot \begin{pmatrix} x \\ y \\ z \\ 1 \end{pmatrix} = \begin{pmatrix} \color{red}{\cos \theta} \cdot x + \color{red}{\sin \theta} \cdot z \\ y \\ - \color{blue}{\sin \theta} \cdot x + \color{blue}{\cos \theta} \cdot z \\ 1 \end{pmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.80204em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6520099999999998em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.80499em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.40599em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.65201em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;"><span class="mop" style="color:red;">cos</span><span class="mspace" style="color:red;margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;color:red;">θ</span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord" style="color:blue;"><span class="mop" style="color:blue;">sin</span><span class="mspace" style="color:blue;margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;color:blue;">θ</span></span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:purple;">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:purple;">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;"><span class="mop" style="color:red;">sin</span><span class="mspace" style="color:red;margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;color:red;">θ</span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;"><span class="mop" style="color:blue;">cos</span><span class="mspace" style="color:blue;margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;color:blue;">θ</span></span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:purple;">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:purple;">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6520099999999998em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.80499em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.40599em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.65201em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:4.80006em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-2.805em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.4050100000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-2.805em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.4050100000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:4.80006em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-2.805em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.4050100000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;"><span class="mop" style="color:red;">cos</span><span class="mspace" style="color:red;margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;color:red;">θ</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin" style="color:red;">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="color:red;">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin" style="color:red;">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord" style="color:red;"><span class="mop" style="color:red;">sin</span><span class="mspace" style="color:red;margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;color:red;">θ</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin" style="color:red;">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;color:red;">z</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord" style="color:blue;"><span class="mop" style="color:blue;">sin</span><span class="mspace" style="color:blue;margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;color:blue;">θ</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin" style="color:blue;">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="color:blue;">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin" style="color:blue;">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord" style="color:blue;"><span class="mop" style="color:blue;">cos</span><span class="mspace" style="color:blue;margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;color:blue;">θ</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin" style="color:blue;">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;color:blue;">z</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-2.805em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.4050100000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>  <strong>沿 <code>z</code> 轴旋转：</strong></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><mrow><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mstyle mathcolor="red"><mrow><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><mn>0</mn></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><mrow><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><mrow><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><mn>0</mn></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><mn>1</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><mn>0</mn></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="purple"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="purple"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="purple"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="purple"><mn>1</mn></mstyle></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>⋅</mo><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>x</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>y</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>z</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><mo>=</mo><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><mrow><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mrow><mo>⋅</mo><mi>x</mi><mo>−</mo><mstyle mathcolor="red"><mrow><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mrow><mo>⋅</mo><mi>y</mi></mstyle></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><mrow><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mrow><mo>⋅</mo><mi>x</mi><mo>+</mo><mstyle mathcolor="green"><mrow><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mrow><mo>⋅</mo><mi>y</mi></mstyle></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>z</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{bmatrix} \color{red}{\cos \theta} &amp; - \color{red}{\sin \theta} &amp; \color{red}0 &amp; \color{red}0 \\ \color{green}{\sin \theta} &amp; \color{green}{\cos \theta} &amp; \color{green}0 &amp; \color{green}0 \\ \color{blue}0 &amp; \color{blue}0 &amp; \color{blue}1 &amp; \color{blue}0 \\ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1 \end{bmatrix} \cdot \begin{pmatrix} x \\ y \\ z \\ 1 \end{pmatrix} = \begin{pmatrix} \color{red}{\cos \theta} \cdot x - \color{red}{\sin \theta} \cdot y  \\ \color{green}{\sin \theta} \cdot x + \color{green}{\cos \theta} \cdot y \\ z \\ 1 \end{pmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.80204em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6520099999999998em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.80499em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.40599em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.65201em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;"><span class="mop" style="color:red;">cos</span><span class="mspace" style="color:red;margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;color:red;">θ</span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;"><span class="mop" style="color:green;">sin</span><span class="mspace" style="color:green;margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;color:green;">θ</span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:purple;">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord" style="color:red;"><span class="mop" style="color:red;">sin</span><span class="mspace" style="color:red;margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;color:red;">θ</span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;"><span class="mop" style="color:green;">cos</span><span class="mspace" style="color:green;margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;color:green;">θ</span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:purple;">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;">1</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:purple;">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:purple;">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6520099999999998em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.80499em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.40599em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.65201em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:4.80006em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-2.805em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.4050100000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-2.805em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.4050100000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:4.80006em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-2.805em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.4050100000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;"><span class="mop" style="color:red;">cos</span><span class="mspace" style="color:red;margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;color:red;">θ</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin" style="color:red;">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="color:red;">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin" style="color:red;">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord" style="color:red;"><span class="mop" style="color:red;">sin</span><span class="mspace" style="color:red;margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;color:red;">θ</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin" style="color:red;">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;color:red;">y</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;"><span class="mop" style="color:green;">sin</span><span class="mspace" style="color:green;margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;color:green;">θ</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin" style="color:green;">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="color:green;">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin" style="color:green;">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord" style="color:green;"><span class="mop" style="color:green;">cos</span><span class="mspace" style="color:green;margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;color:green;">θ</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin" style="color:green;">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;color:green;">y</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-2.805em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.4050100000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-4.65003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><blockquote><p>关于正余弦组合问题可看下面的<a href="https://yleave.top/2020/10/23/%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/#%E6%97%8B%E8%BD%AC%E5%8F%98%E6%8D%A2">仿射变换小节</a></p></blockquote><p>  利用旋转矩阵我们可以把任意位置向量沿一个单位旋转轴进行旋转。也可以将多个矩阵复合，比如先沿着<code>x</code>轴旋转再沿着<code>y</code>轴旋转。但是这会很快导致一个问题——<strong>万向节死锁</strong>（Gimbal Lock，可以看看<a href="https://www.youtube.com/watch?v=zc8b2Jo7mno">这个视频</a><a href="http://v.youku.com/v_show/id_XNzkyOTIyMTI=.html">（优酷）</a>来了解）。</p><p>  避免万向节死锁的真正解决方案是使用<strong>四元数</strong>(Quaternion)，它不仅更安全，而且计算会更有效率。</p><blockquote><p>  对四元数的理解会用到非常多的数学知识。如果想了解四元数与3D旋转之间的关系，可以来阅读<a href="https://krasjet.github.io/quaternion/">教程</a>。如果你对万向节死锁的概念仍不是那么清楚，可以来阅读教程的<a href="https://krasjet.github.io/quaternion/bonus_gimbal_lock.pdf">Bonus章节</a>。</p><p>  现在3Blue1Brown也已经开始了一个四元数的视频系列，他采用球极平面投影(Stereographic Projection)的方式将四元数投影到3D空间，同样有助于理解四元数的概念（仍在更新中）：<a href="https://www.youtube.com/watch?v=d4EgbgTm0Bg">https://www.youtube.com/watch?v=d4EgbgTm0Bg</a></p></blockquote><h2 id="矩阵的组合"><a class="markdownIt-Anchor" href="#矩阵的组合"></a> 矩阵的组合</h2><p>  根据矩阵之间的乘法，我们可以把多个变换组合到一个矩阵中。</p><p>  假设我们有一个顶点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x, y, z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span>，我们希望将其<strong>缩放</strong> <code>2</code> 倍，然后<strong>位移</strong> $(1, 2, 3) $个单位。结果的变换矩阵看起来像这样：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi><mi mathvariant="normal">.</mi><mi>S</mi><mi>c</mi><mi>a</mi><mi>l</mi><mi>e</mi><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><mn>1</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><mn>1</mn></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><mn>1</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><mn>2</mn></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><mn>1</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><mn>3</mn></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="purple"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="purple"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="purple"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="purple"><mn>1</mn></mstyle></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mi mathvariant="normal">.</mi><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><mn>2</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><mn>0</mn></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><mn>2</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><mn>0</mn></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><mn>2</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><mn>0</mn></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="purple"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="purple"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="purple"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="purple"><mn>1</mn></mstyle></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><mn>2</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><mn>1</mn></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><mn>2</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><mn>2</mn></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><mn>2</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><mn>3</mn></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="purple"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="purple"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="purple"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="purple"><mn>1</mn></mstyle></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">Trans . Scale = \begin{bmatrix} \color{red}1 &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}1 \\ \color{green}0 &amp; \color{green}1 &amp; \color{green}0 &amp; \color{green}2 \\ \color{blue}0 &amp; \color{blue}0 &amp; \color{blue}1 &amp; \color{blue}3 \\ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1 \end{bmatrix} . \begin{bmatrix} \color{red}2 &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}0 \\ \color{green}0 &amp; \color{green}2 &amp; \color{green}0 &amp; \color{green}0 \\ \color{blue}0 &amp; \color{blue}0 &amp; \color{blue}2 &amp; \color{blue}0 \\ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1 \end{bmatrix} = \begin{bmatrix} \color{red}2 &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}1 \\ \color{green}0 &amp; \color{green}2 &amp; \color{green}0 &amp; \color{green}2 \\ \color{blue}0 &amp; \color{blue}0 &amp; \color{blue}2 &amp; \color{blue}3 \\ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1 \end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:4.80204em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6520099999999998em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.80499em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.40599em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.65201em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;">1</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:purple;">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:purple;">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;">1</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:purple;">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;">1</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;">2</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;">3</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:purple;">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6520099999999998em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.80499em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.40599em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.65201em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6520099999999998em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.80499em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.40599em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.65201em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;">2</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:purple;">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;">2</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:purple;">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;">2</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:purple;">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:purple;">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6520099999999998em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.80499em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.40599em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.65201em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:4.80204em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6520099999999998em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.80499em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.40599em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.65201em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;">2</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:purple;">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;">2</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:purple;">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;">2</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:purple;">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;">1</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;">2</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;">3</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:purple;">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6520099999999998em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.80499em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.40599em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.65201em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>  <strong>注意</strong>，当矩阵相乘时我们<strong>先写位移再写缩放</strong>变换的。矩阵乘法是不遵守交换律的，这意味着它们的顺序很重要。</p><p>  当矩阵相乘时，在<strong>最右边</strong>的矩阵是第一个与向量相乘的，所以你应该<strong>从右向左读</strong>这个乘法。</p><p>  建议在组合矩阵时，<strong>先</strong>进行<strong>缩放</strong>操作，<strong>然后</strong>是<strong>旋转</strong>，<strong>最后</strong>才是<strong>位移</strong>，否则它们会（消极地）互相影响。</p><p>  比如，如果你先位移再缩放，位移的向量也会同样被缩放（比如向某方向移动 2 米，2 米也许会被缩放成 1 米）！</p><p>  用最终的<strong>变换矩阵左乘</strong>我们的向量会得到以下结果：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><mn>2</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><mn>1</mn></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><mn>2</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><mn>2</mn></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><mn>2</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><mn>3</mn></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="purple"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="purple"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="purple"><mn>0</mn></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="purple"><mn>1</mn></mstyle></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mi mathvariant="normal">.</mi><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>x</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>y</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>z</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="red"><mn>2</mn><mi>x</mi><mo>+</mo><mstyle mathcolor="red"><mn>1</mn></mstyle></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="green"><mn>2</mn><mi>y</mi><mo>+</mo><mstyle mathcolor="green"><mn>2</mn></mstyle></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mstyle mathcolor="blue"><mn>2</mn><mi>z</mi><mo>+</mo><mstyle mathcolor="blue"><mn>3</mn></mstyle></mstyle></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{bmatrix} \color{red}2 &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}1 \\ \color{green}0 &amp; \color{green}2 &amp; \color{green}0 &amp; \color{green}2 \\ \color{blue}0 &amp; \color{blue}0 &amp; \color{blue}2 &amp; \color{blue}3 \\ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1 \end{bmatrix} . \begin{bmatrix} x \\ y \\ z \\ 1 \end{bmatrix} = \begin{bmatrix} \color{red}2x + \color{red}1 \\ \color{green}2y + \color{green}2  \\ \color{blue}2z + \color{blue}3 \\ 1 \end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.80204em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6520099999999998em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.80499em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.40599em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.65201em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;">2</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:purple;">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;">2</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:purple;">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;">2</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:purple;">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;">1</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;">2</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;">3</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:purple;">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6520099999999998em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.80499em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.40599em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.65201em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6520099999999998em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.80499em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.40599em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.65201em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6520099999999998em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.80499em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.40599em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.65201em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:4.80204em;vertical-align:-2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6520099999999998em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.80499em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.40599em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.65201em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:red;">2</span><span class="mord mathdefault" style="color:red;">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin" style="color:red;">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord" style="color:red;">1</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:green;">2</span><span class="mord mathdefault" style="margin-right:0.03588em;color:green;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin" style="color:green;">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord" style="color:green;">2</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="color:blue;">2</span><span class="mord mathdefault" style="margin-right:0.04398em;color:blue;">z</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin" style="color:blue;">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord" style="color:blue;">3</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6520099999999998em;"><span style="top:-1.6499900000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.80499em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.40599em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.65201em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>  向量先缩放 <code>2</code> 倍，然后位移了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1, 2, 3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mclose">)</span></span></span></span> 个单位。</p><h1 id="仿射变换"><a class="markdownIt-Anchor" href="#仿射变换"></a> 仿射变换</h1><p>REF：<a href="https://blog.csdn.net/u011681952/article/details/98942207">https://blog.csdn.net/u011681952/article/details/98942207</a></p><h2 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h2><p>  仿射变换（Affine Transformation）其实是另外两种简单变换的叠加：一个是线性变换，一个是平移变换</p><p>  仿射变换变化包括<strong>缩放(Scale)</strong>、<strong>平移(transform)</strong>、<strong>旋转(rotate)</strong>、<strong>反射(reflection)</strong>、<strong>错切(shear mapping</strong>，感觉像是一个图形的倒影)，原来的直线仿射变换后还是直线，原来的平行线经过仿射变换之后还是平行线，这就是仿射.</p><p>  仿射变换中集合中的一些性质保持不变：</p><ul><li><strong>凸性</strong></li><li><strong>共线性</strong>：若几个点变换前在一条线上，则仿射变换后仍然在一条线上</li><li><strong>平行性</strong>：若两条线变换前平行，则变换后仍然平行</li><li><strong>共线比例不变性</strong>：变换前一条线上两条线段的比例，在变换后比例不变</li></ul><p>  注：所有的三角形都能通过仿射变化为其他三角形，所有平行四边形也能仿射变换为另一个平行四边形。</p><h2 id="数学表达"><a class="markdownIt-Anchor" href="#数学表达"></a> 数学表达</h2><p>  一个集合 X 的仿射变换为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>A</mi><mi>x</mi><mo>+</mo><mi>b</mi><mo separator="true">,</mo><mi>x</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">f(x) = Ax + b, x∈X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span></span></p><p>  仿射变换是二维平面中一种重要的变换，在图像图形领域有广泛的应用，在二维图像变换中，一般表达为：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200603191636610.png" alt="image-20200603191636610" style="zoom:80%;" /><h2 id="仿射变换理解"><a class="markdownIt-Anchor" href="#仿射变换理解"></a> 仿射变换理解</h2><p>  要熟练应用仿射变换，则需先理解仿射变换，说白了就是要弄清楚上面的 R，T 矩阵各个参数代表什么含义，用图像来表达</p> <img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200603191940164.png" alt="image-20200603191940164" style="zoom:80%;" /><h4 id="平移变换"><a class="markdownIt-Anchor" href="#平移变换"></a> 平移变换</h4><p>  不难想象，就是将 x，y 平移指定值，则 R 矩阵为单位矩阵，T 矩阵为指定值，如上图中，第一行第二列图</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200603193352104.png" alt="image-20200603193352104" style="zoom: 67%;" /><h4 id="反射变换"><a class="markdownIt-Anchor" href="#反射变换"></a> 反射变换</h4><p>  见图最后一行，如相对 x 轴反射，则 x 不变，y 变为相反号</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200603193420276.png" alt="image-20200603193420276" style="zoom:67%;" /><h4 id="旋转变换"><a class="markdownIt-Anchor" href="#旋转变换"></a> 旋转变换</h4><p>  为简单起见，只从一个点的旋转来看</p><p><strong>1) 左下角为坐标原点</strong></p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200603193445281.png" alt="image-20200603193445281" style="zoom: 50%;" /><ul><li>坐标原点为左下角</li><li>点 <code>P(x,y)</code> 为坐标系中一个点，与 x 轴的夹角为 <code>α</code>，假设其到原点的距离为 1（方便计算）</li><li>点 <code>P'(x',y')</code> 为 p 点逆时针旋转 <code>θ</code> 角度的点</li><li>点 <code>P''(x'',y'')</code> 为 p 点顺时针旋转 <code>θ</code> 角度的点</li></ul><p>  根据简单三角关系，可知</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200603193546673.png" alt="image-20200603193546673" style="zoom:67%;" /><p>  逆时针时：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200603193601041.png" alt="image-20200603193601041" style="zoom: 67%;" /><p>  则，逆时针旋转矩阵 <code>R</code> 为:</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200603193643720.png" alt="image-20200603193643720" style="zoom: 67%;" /><p>  顺时针时：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200603193757123.png" alt="image-20200603193757123" style="zoom:67%;" /><p>  则，顺时针旋转矩阵 <code>R''</code> 为：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200603193817280.png" alt="image-20200603193817280" style="zoom:67%;" /><p>  从上可以看出，这个负号位置问题，个人认为与<strong>旋转方向相关</strong></p><p><strong>2) 左上角为坐标原点</strong></p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200603193835147.png" alt="image-20200603193835147" style="zoom: 50%;" /><ul><li>坐标原点为左上角</li><li>点 <code>P(x,y)</code> 为坐标系中一个点，与 x 轴的夹角为 <code>α</code>，假设其到原点的距离为 1（方便计算）</li><li>点 <code>P'(x',y')</code> 为 p 点逆时针旋转 <code>θ</code> 角度的点</li><li>点 <code>P''(x'',y'')</code> 为 p 点顺时针旋转 <code>θ</code> 角度的点</li></ul><p>  根据简单三角关系，可知</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200603193900029.png" alt="image-20200603193900029" style="zoom: 67%;" /><p>  逆时针时：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200603193913608.png" alt="image-20200603193913608" style="zoom:67%;" /><p>  则，逆时针旋转矩阵 <code>R</code> 为:</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200603193924992.png" alt="image-20200603193924992" style="zoom:67%;" /><p>  顺时针时：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200603194039716.png" alt="image-20200603194039716" style="zoom:67%;" /><p>  则，顺时针旋转矩阵 <code>R''</code> 为：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200603194047691.png" alt="image-20200603194047691" style="zoom:67%;" /><p>  从上可以看出，这个负号位置问题，不但<strong>与旋转方向有关</strong>，<strong>还与原点有关</strong></p><p><strong>3) 总结</strong></p><ul><li>旋转矩阵 R 中，<code>sinθ</code> 的负号位置与旋转方向和原点相关</li><li>当记逆时针为正，左上角为原点时（opencv默认），旋转矩阵为：</li></ul><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200603194100107.png" alt="image-20200603194100107" style="zoom:67%;" />]]></content>
    
    
    <categories>
      
      <category>其他知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线性代数</tag>
      
      <tag>矩阵变换</tag>
      
      <tag>仿射变换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode236. 二叉树的最近公共祖先</title>
    <link href="/2020/10/23/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <url>/2020/10/23/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/</a></p><p>难度：中等</p><hr /><p>  给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>  百度百科中最近公共祖先的定义为：“对于有根树 <code>T</code> 的两个结点 <code>p</code>、<code>q</code>，最近公共祖先表示为一个结点 <code>x</code>，满足 <code>x</code> 是 <code>p</code>、<code>q</code> 的祖先且 <code>x</code> 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>  例如，给定如下二叉树:  <code>root = [3,5,1,6,2,0,8,null,null,7,4]</code></p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201023110108390.png" alt="image-20201023110108390" style="zoom:80%;" /><p><strong>示例 1:</strong></p><p>  输入: <code>root = [3,5,1,6,2,0,8,null,null,7,4]</code>, <code>p = 5</code>, <code>q = 1</code></p><p>  输出: <code>3</code></p><p>  解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</p><p><strong>示例 2:</strong></p><p>  输入: <code>root = [3,5,1,6,2,0,8,null,null,7,4]</code>, <code>p = 5</code>, <code>q = 4</code></p><p>  输出: <code>5</code></p><p>  解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</p><p><strong>说明:</strong></p><ul><li><p>所有节点的值都是唯一的。</p></li><li><p>p、q 为不同节点且均存在于给定的二叉树中。</p></li></ul><h2 id="解法1保存祖先节点逐个判断"><a class="markdownIt-Anchor" href="#解法1保存祖先节点逐个判断"></a> 解法1：保存祖先节点+逐个判断</h2><p>  一个很直的方法就是对树进行深度优先遍历，并在遍历过程中使用一个栈保存遇到的节点，直到遍历到节点 <code>p</code> 或节点 <code>q</code> 为止（包括这个节点）。</p><p>  此时，栈中保存了 <code>p</code> 或 <code>q</code> 的所有祖先节点，将栈中节点一个个出栈，对每个节点判断其子树中是否 包含另一个节点（若栈中保存的是 <code>p</code> 的祖先节点，则判断是否包含 <code>q</code> ，反之亦然），当遇到第一个包含另一个节点的祖先节点，这个节点就是最近的公共祖先节点。</p><p><strong>JS 代码：</strong></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> lowestCommonAncestor = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root, p, q</span>) </span>&#123;    <span class="hljs-keyword">let</span> stack = [];    <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">false</span>;    <span class="hljs-keyword">let</span> tmp;    <span class="hljs-comment">// 对树进行深度优先遍历，保存路径上的节点</span>    <span class="hljs-keyword">const</span> dfs = <span class="hljs-function">(<span class="hljs-params">root</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (flag || !root) &#123;           <span class="hljs-keyword">return</span>;        &#125;        stack.push(root);        <span class="hljs-keyword">if</span> (root === p || root === q) &#123;            flag = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 当找到其中一条路径后，可提前退出</span>            tmp = root;            <span class="hljs-keyword">return</span>;        &#125;        dfs(root.left);        dfs(root.right);        <span class="hljs-keyword">if</span> (!flag) &#123;            stack.pop();        &#125;    &#125;;     dfs(root);    flag = <span class="hljs-literal">false</span>;    <span class="hljs-comment">// 对每个节点判断子树中是否包含另一个节点</span>    <span class="hljs-keyword">const</span> check = <span class="hljs-function">(<span class="hljs-params">root</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (flag || !root) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> ((root === p || root === q) &amp;&amp; root !== tmp) &#123;            flag = <span class="hljs-literal">true</span>;            <span class="hljs-keyword">return</span>;        &#125;        check(root.left);        check(root.right);    &#125;;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = stack.length<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        check(stack[i]);        <span class="hljs-keyword">if</span> (flag) &#123;            <span class="hljs-keyword">return</span> stack[i];        &#125;    &#125;&#125;;</code></pre><p>  上面的代码中，对树的深度优先遍历可替换为<a href="https://yleave.top/2020/09/30/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/%E5%90%8E%E5%BA%8F%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86/">后序非递归遍历</a>，这样的话就不用考虑非祖先路径上的节点问题了。</p><h2 id="解法2深度优先遍历"><a class="markdownIt-Anchor" href="#解法2深度优先遍历"></a> 解法2：深度优先遍历</h2><p>  解法2来源于 <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/er-cha-shu-de-zui-jin-gong-gong-zu-xian-by-leetc-2/">LeetCode</a> ，主要思路是在遍历过程中根据左右子树是否包含了 <code>p</code> 节点或 <code>q</code> 节点来寻找祖先节点。</p><p>  即根据逻辑表达式：<code>(lson &amp;&amp; rson) || ((root.val === p.val || root.val === q.val) &amp;&amp; (lson || rson))</code> 来进行判断当前节点 <code>root</code> 是否为祖先节点。</p><p>  该表达式包括了两种情况，<code>lson</code> 表示左子树中是否包含 <code>p</code> 或 <code>q</code> 节点，<code>rson</code> 表示右子树中是否包含 <code>p</code> 或 <code>q</code> 节点：</p><ul><li><code>lson &amp;&amp; rson</code> 表示左右子树中包含了 <code>p</code> 节点和 <code>q</code> 节点，这两个节点是在不同的子树中</li><li><code>(root.val === p.val || root.val === q.val) &amp;&amp; (lson || rson)</code> 表示当前节点为 <code>p</code> 或 <code>q</code> 节点的情况，且此时当前节点的子树中包含了另一个节点（因为两个节点值是不同的，所以只要 <code>lson</code> 或 <code>rson</code> 中有一个为真就代表了包含了另一个节点）。</li></ul><p><strong>JS 代码如下</strong>，其中 <code>flag</code> 用于提前退出递归：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> lowestCommonAncestor = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root, p, q</span>) </span>&#123;    <span class="hljs-keyword">let</span> ans, flag = <span class="hljs-literal">false</span>;    <span class="hljs-keyword">const</span> dfs = <span class="hljs-function">(<span class="hljs-params">root</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (!root || flag) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">let</span> lson = dfs(root.left);        <span class="hljs-keyword">let</span> rson = dfs(root.right);        <span class="hljs-keyword">if</span> ((lson &amp;&amp; rson) || ((root.val === p.val || root.val === q.val) &amp;&amp; (lson || rson))) &#123;            ans = root;            flag = <span class="hljs-literal">true</span>;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">return</span> lson || rson || root.val === p.val || root.val === q.val;    &#125;    dfs(root);    <span class="hljs-keyword">return</span> ans;&#125;;</code></pre><h2 id="解法3记录祖先节点"><a class="markdownIt-Anchor" href="#解法3记录祖先节点"></a> 解法3：记录祖先节点</h2><p>  解法 3 来源于 <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/er-cha-shu-de-zui-jin-gong-gong-zu-xian-by-leetc-2/">LeetCode</a></p><p>  解法 3 中的记录祖先节点和解法 1 中的不同，解法 1 是使用数组顺序记录了 <code>p</code> 、<code>q</code> 其中一个节点中的祖先节点路径，而解法 3 中则是以节点值为索引来将祖先节点保存在数组中，这样，我们就能根据 <code>p</code> 和 <code>q</code> 节点的值往上跳来找到公共的祖先节点。</p><p>  具体做法是遍历这两个节点的祖先节点，并使用一个数组 <code>vis</code> 来标识某个节点是否被访问过，若我们先遍历 <code>p</code> 的祖先节点，则在遍历 <code>q</code> 的祖先节点时，遇到的第一个被访问过的祖先节点就是它们的最近公共祖先节点。</p><p><strong>JS 代码：</strong></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> lowestCommonAncestor = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root, p, q</span>) </span>&#123;    <span class="hljs-keyword">let</span> ans;    <span class="hljs-keyword">let</span> fa = [];    <span class="hljs-keyword">let</span> vis = [];    fa[root.val] = <span class="hljs-literal">false</span>;    <span class="hljs-keyword">const</span> dfs = <span class="hljs-function">(<span class="hljs-params">root</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (!root) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (root.left) &#123;            fa[root.left.val] = root;            dfs(root.left);        &#125;        <span class="hljs-keyword">if</span> (root.right) &#123;            fa[root.right.val] = root;            dfs(root.right);        &#125;    &#125;;    dfs(root);    <span class="hljs-keyword">while</span> (p) &#123;        vis[p.val] = <span class="hljs-literal">true</span>;        p = fa[p.val];    &#125;    <span class="hljs-keyword">while</span> (q) &#123;        <span class="hljs-keyword">if</span> (vis[q.val]) &#123;            <span class="hljs-keyword">return</span> q;        &#125;        q = fa[q.val];    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>解答</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>素数</title>
    <link href="/2020/10/22/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/%E7%B4%A0%E6%95%B0/"/>
    <url>/2020/10/22/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/%E7%B4%A0%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><strong>最大的素数为：999983</strong></p><h1 id="一-素数介绍"><a class="markdownIt-Anchor" href="#一-素数介绍"></a> 一、素数介绍</h1><p>  <strong>素数</strong>又称为<strong>质数</strong>，是除了<code>1</code>和本身之外，不能被其他数整除的一类数。即对给定的正整数<code>n</code> ，如果对任意的正整数 <code>a(1 &lt; a &lt; n)</code>，都有 <code>n % a != 0</code> 成立，那么称 <code>n</code> 是素数，否则，如果存在正整数 <code>a(1 &lt; a &lt; n)</code>，都有 <code>n % a == 0</code> 成立，那么称 <code>n</code> 为<strong>合数</strong>。（<code>1</code>既不是素数，也不是合数）</p><h1 id="二-素数的判断"><a class="markdownIt-Anchor" href="#二-素数的判断"></a> 二、素数的判断</h1><p>  只需要判断 <code>n</code> 是否能被 <code>2,3，···，sqrt(n)</code>(向下取整)，即可判断 <code>n</code> 是否为素数。该算法的时间复杂度为 <code>O(sqrt(n))</code>;</p><p><strong>C代码如下：</strong></p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">1</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">int</span> sqr = (<span class="hljs-keyword">int</span>)<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0</span> * n);   <span class="hljs-comment">//sqrt()的参数要求是浮点数</span>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">2</span>; i &lt; sqr; i++)&#123;        <span class="hljs-keyword">if</span>(n % i == <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre><p><strong>更简单的写法：</strong></p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPrime1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;     <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">1</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">2</span>; i * i &lt;= n; i++)&#123;        <span class="hljs-keyword">if</span>(n % i == <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre><h1 id="三-获取素数表"><a class="markdownIt-Anchor" href="#三-获取素数表"></a> 三、获取素数表</h1><pre><code class="hljs js"><span class="hljs-keyword">const</span> int maxn <span class="hljs-number">101</span>;      <span class="hljs-comment">//表长</span>int prime[maxn],pNum = <span class="hljs-number">0</span>;bool p[<span class="hljs-number">101</span>] = &#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">//p[i] == true表示 i 是素数</span><span class="hljs-keyword">void</span> find_Prime()&#123;    int i;    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; maxn; i++)&#123;        <span class="hljs-keyword">if</span>(isPrime(i) == <span class="hljs-literal">true</span>)&#123;            prime[pNum++] = i;            p[i] = <span class="hljs-literal">true</span>;        &#125;    &#125;&#125;</code></pre><h2 id="更高效的算法-埃氏筛法eratosthenes"><a class="markdownIt-Anchor" href="#更高效的算法-埃氏筛法eratosthenes"></a> 更高效的算法------埃氏筛法：Eratosthenes</h2><p>  埃氏筛法的具体思想是：在对每一个数判断是否是素数时，将其所有倍数都标记为非素数，这样，在后面遇到这个数的倍数时，就不用一一从头开始判断是否能被其他数整除了。</p><pre><code class="hljs c"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn <span class="hljs-number">101</span>;      <span class="hljs-comment">//表长</span><span class="hljs-keyword">int</span> prime[maxn],pNum = <span class="hljs-number">0</span>;<span class="hljs-keyword">bool</span> p[<span class="hljs-number">101</span>] = &#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">//p[i] 为false表示 i 是素数，true 表示 i 不是素数</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">find_Prime1</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> i,j;    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">2</span>; i &lt; maxn; i++)&#123;        <span class="hljs-keyword">if</span>(p[i] == <span class="hljs-literal">false</span>)&#123;                    prime[pNum++] = i;            <span class="hljs-keyword">for</span>(j = i + i; j &lt; maxn; j += i)&#123;                p[j] = <span class="hljs-literal">true</span>;            &#125;        &#125;    &#125;&#125;</code></pre><h1 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h1><p><a href="https://leetcode-cn.com/problems/count-primes/">LeetCode 204</a></p>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>算法知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 763. 划分字母区间</title>
    <link href="/2020/10/22/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/"/>
    <url>/2020/10/22/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/partition-labels/">https://leetcode-cn.com/problems/partition-labels/</a></p><p>难度：中等</p><hr /><p>  字符串 <code>S</code> 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。</p><p>  <strong>示例 1：</strong></p><p>  输入：<code>S = &quot;ababcbacadefegdehijhklij&quot;</code></p><p>  输出：<code>[9,7,8]</code></p><p>  解释：划分结果为 “ababcbaca”, “defegde”, “hijhklij”。每个字母最多出现在一个片段中。像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。</p><p><strong>提示：</strong></p><ul><li><code>S</code>的长度在<code>[1, 500]</code>之间。</li><li><code>S</code>只包含小写字母 <code>'a'</code> 到 <code>'z'</code> 。</li></ul><h2 id="解法1记录最大最小下标"><a class="markdownIt-Anchor" href="#解法1记录最大最小下标"></a> 解法1：记录最大最小下标</h2><p>  首先，对于一个符合要求的区间，区间内的所有字母的出现位置必会被包含在区间内，且<strong>该区间的最大下标会是区间内字母的最大下标位置</strong>。</p><p>  我们使用 <code>min</code> 代表某个字母出现的最小下标，<code>max</code> 表示某个字母出现的最大下标，考虑一组字母：</p><p><code>a:&#123;min: 0, max: 8&#125;</code>，<code>b:&#123;min: 1, max: 5&#125;</code>，<code>c:&#123;min: 4, max: 7&#125;</code>，<code>d:&#123;min: 9, max: 14&#125;</code></p><p>  我们可以通过比较这些字母的最小、最大下标来寻找范围，范围的最小最大下标使用 <code>gmin</code>、<code>gmax</code> 来表示：</p><p>  从左到右遍历这组字母，首先令 <code>gmin = a.min = 0</code>，<code>gmax = a.max = 8</code>，对于接下来遍历到的每个字母，若 <code>min</code> 小于 <code>gmax</code>，则说明这两个字母会处在同一个范围内（因为它们的范围可能是相交的也可能是包含的，如 <code>a</code> 和 <code>b</code> 的范围是包含的，<code>b</code> 和 <code>c</code> 的范围是相交的），并更新范围的最大下标位置： <code>gmax = Math.max(gmax, *.max)</code>，这样，当遇到第一个不满足 <code>min &lt; gmax</code> 的字母，说明该字母和当前范围内的字母不处于同一个范围，这时即可计算当前范围：<code>gmax - gmin + 1</code>，并重新赋值新的最大最小范围：<code>gmax = *.max</code>，<code>gmin = *.min</code>。</p><p>  需要注意的是，在遍历完所有字母后，还需要计算最后一个范围。</p><p><strong>JS 代码如下：</strong></p><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">S</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> partitionLabels = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">S</span>) </span>&#123;    <span class="hljs-keyword">let</span> chars = [];    <span class="hljs-keyword">let</span> res = [];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; S.length; i++) &#123;        <span class="hljs-keyword">let</span> c = S[i];        <span class="hljs-keyword">if</span> (!chars[c]) &#123;            chars[c] = &#123;                min: i,                max: i            &#125;;        &#125; <span class="hljs-keyword">else</span> &#123;            chars[c].min = <span class="hljs-built_in">Math</span>.min(chars[c].min, i);            chars[c].max = <span class="hljs-built_in">Math</span>.max(chars[c].max, i);        &#125;    &#125;    chars.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;        <span class="hljs-keyword">return</span> a.min - b.min;    &#125;);    <span class="hljs-keyword">let</span> min, max;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> c <span class="hljs-keyword">in</span> chars) &#123;        <span class="hljs-keyword">let</span> char = chars[c];        <span class="hljs-keyword">if</span> (min === <span class="hljs-literal">undefined</span>) &#123;            min = char.min;            max = char.max;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (char.min &lt; max) &#123;            max = <span class="hljs-built_in">Math</span>.max(max, char.max);        &#125; <span class="hljs-keyword">else</span> &#123;            res.push(max - min + <span class="hljs-number">1</span>);            min = char.min;            max = char.max;        &#125;    &#125;        res.push(max - min + <span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> res;&#125;;</code></pre><h2 id="解法2贪心"><a class="markdownIt-Anchor" href="#解法2贪心"></a> 解法2：贪心</h2><p>  解法2 为<a href="https://leetcode-cn.com/problems/partition-labels/solution/hua-fen-zi-mu-qu-jian-by-leetcode-solution/">官方的思路</a> ，具体做法与解法1类似，不过会比较简洁。</p><p>  主要思路是先获取到所有字母的最大下标位置，然后遍历所有字母，不断更新最大下标位置 <code>max</code>，当遍历到了这个最大下标位置 <code>max</code> 时，就说明已遍历到的字母都在当前范围内了（因为对于每一个遍历的字母，都会比较字母的最大下标位置来更新范围的最大下标 <code>max</code>），这时候划分范围一定能得到最多的划分区域。</p><p>  获取范围还需要一个最小下标 <code>min</code>，<code>min</code> 初始时为 <code>0</code>，每当划分一个范围时，就更新 <code>min</code> 为 <code>max + 1</code>，代表下一个范围的最小下标。</p><p><strong>JS 代码如下：</strong></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> partitionLabels = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">S</span>) </span>&#123;    <span class="hljs-keyword">let</span> maxIndex = [], res = [];    <span class="hljs-keyword">let</span> max = <span class="hljs-number">0</span>, charCode = <span class="hljs-string">&#x27;a&#x27;</span>.charCodeAt();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; S.length; i++) &#123;        maxIndex[S.codePointAt(i) - charCode] = i;    &#125;    <span class="hljs-keyword">let</span> min = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; S.length; i++) &#123;        max = <span class="hljs-built_in">Math</span>.max(maxIndex[S.codePointAt(i) - charCode], max);        <span class="hljs-keyword">if</span> (i === max) &#123;            res.push(max - min + <span class="hljs-number">1</span>);            min = i + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>解答</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>坐标系相关知识</title>
    <link href="/2020/10/18/WebGL/%E5%9D%90%E6%A0%87%E7%B3%BB%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <url>/2020/10/18/WebGL/%E5%9D%90%E6%A0%87%E7%B3%BB%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>REF ：<a href="https://learnopengl-cn.github.io/01%20Getting%20started/08%20Coordinate%20Systems/">https://learnopengl-cn.github.io/01 Getting started/08 Coordinate Systems/</a></p><p>WebGL的一些词汇表：<a href="https://learnopengl-cn.github.io/01%20Getting%20started/10%20Review/">https://learnopengl-cn.github.io/01 Getting started/10 Review/</a></p><hr /><p>  比较重要的主要有五个坐标系统：</p><ul><li>局部空间（Local Space，或称为物体空间（Object Space））</li><li>世界空间（World Space）</li><li>观察空间（View Space，或称为眼空间（Eye Space））</li><li>裁剪空间（Clip Space）</li><li>屏幕空间（Screen Space）</li></ul><h1 id="坐标空间"><a class="markdownIt-Anchor" href="#坐标空间"></a> 坐标空间</h1><p>  为了将坐标从一个坐标系变换到另一个坐标系，我们需要用到几个变换矩阵，最重要的几个分别是<strong>模型</strong>(Model) 矩阵、<strong>观察</strong> (View) 矩阵 和 <strong>投影</strong> (Projection) 矩阵。</p><p>  我们的顶点坐标起始于局部空间(Local Space)，在这里它称为<strong>局部坐标</strong>(Local Coordinate)，并最后以<strong>屏幕坐标</strong>(Screen Coordinate)的形式结束。</p><p>  下图展示了整个的变换流程：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201018185023147.png" alt="image-20201018185023147" style="zoom:80%;" /><ol><li><strong>局部坐标</strong>是对象相对于局部原点的坐标，也是物体起始的坐标。</li><li>下一步是将局部坐标变换为<strong>世界空间坐标</strong>，世界空间坐标是处于一个更大的空间范围的。这些坐标相对于世界的全局原点，它们会和其它物体一起相对于世界的原点进行摆放。</li><li>接下来我们将世界坐标变换为<strong>观察空间坐标</strong>，使得每个坐标都是从摄像机或者说观察者的角度进行观察的。</li><li>坐标到达观察空间之后，我们需要将其投影到<strong>裁剪坐标</strong>。裁剪坐标会被处理至 <code>-1.0</code> 到 <code>1.0</code> 的范围内，并判断哪些顶点将会出现在屏幕上。</li><li>最后，我们将裁剪坐标变换为<strong>屏幕坐标</strong>，我们将使用一个叫做<strong>视口变换</strong>(Viewport Transform)的过程。视口变换将位于 <code>-1.0</code> 到 <code>1.0</code> 范围的坐标变换到由 <code>glViewport</code>函数所定义的坐标范围内。最后变换出来的坐标将会送到光栅器，将其转化为片段。</li></ol><p>  之所以将顶点变换到各个不同的空间的原因是有些操作在特定的坐标系统中才有意义且更方便。</p><p>  例如：</p><ul><li><p>当需要对物体进行修改的时候，在局部空间中来操作会更说得通；</p></li><li><p>如果要对一个物体做出一个相对于其它物体位置的操作时，在世界坐标系中来做这个才更说得通；</p></li><li><p>等等。</p></li></ul><h2 id="局部空间"><a class="markdownIt-Anchor" href="#局部空间"></a> 局部空间</h2><p>  局部空间是指物体所在的坐标空间，即对象最开始所在的地方。</p><p>  想象你在一个建模软件（比如说Blender）中创建了一个立方体。你创建的立方体的原点有可能位于<code>(0, 0, 0)</code>，即便它有可能最后在程序中处于完全不同的位置。甚至有可能你创建的所有模型都以<code>(0, 0, 0)</code>为初始位置（然而它们会最终出现在世界的不同位置）。</p><p>  所以，你的模型的所有顶点都是在<strong>局部</strong>空间中：它们相对于你的物体来说都是局部的。</p><h2 id="世界空间"><a class="markdownIt-Anchor" href="#世界空间"></a> 世界空间</h2><p>  如果我们将我们所有的物体导入到程序当中，它们有可能会全挤在世界的原点<code>(0, 0, 0)</code>上，这并不是我们想要的结果。我们想为每一个物体定义一个位置，从而能在更大的世界当中放置它们。</p><p>  世界空间中的坐标正如其名：是指顶点相对于（游戏）世界的坐标。如果你希望将物体分散在世界上摆放（特别是非常真实的那样），这就是你希望物体变换到的空间。物体的坐标将会从局部变换到世界空间；该变换是由**模型矩阵(Model Matrix)**实现的。</p><p>  模型矩阵是一种变换矩阵，它能通过对物体进行<strong>位移</strong>、<strong>缩放</strong>、<strong>旋转</strong>来将它置于它本应该在的位置或朝向。你可以将它想像为变换一个房子，你需要先将它缩小（它在局部空间中太大了），并将其位移至郊区的一个小镇，然后在 <code>y</code> 轴上往左旋转一点以搭配附近的房子。</p><h2 id="观察空间"><a class="markdownIt-Anchor" href="#观察空间"></a> 观察空间</h2><p>  <strong>观察空间</strong>经常被人们称之为摄像机(Camera)（所以有时也称为<strong>摄像机空间</strong>(Camera Space)或<strong>视觉空间</strong>(Eye Space)）。</p><p>  观察空间是将世界空间坐标转化为用户视野前方的坐标而产生的结果。因此<strong>观察空间就是从摄像机的视角所观察到的空间</strong>。而这通常是由一系列的位移和旋转的组合来完成，平移/旋转场景从而使得特定的对象被变换到摄像机的前方。这些组合在一起的变换通常存储在一个<strong>观察矩阵(View Matrix)<strong>里，它被用来</strong>将世界坐标变换到观察空间</strong>。</p><h2 id="裁剪空间"><a class="markdownIt-Anchor" href="#裁剪空间"></a> 裁剪空间</h2><p>  在一个顶点着色器运行的最后，OpenGL期望所有的坐标都能落在一个特定的范围内，且<strong>任何在这个范围之外的点都应该被裁剪掉</strong>(Clipped)。被裁剪掉的坐标就会被忽略，所以剩下的坐标就将变为屏幕上可见的片段。这也就是<strong>裁剪空间</strong>(Clip Space)名字的由来。</p><p>  因为将所有可见的坐标都指定在 <code>-1.0</code> 到 <code>1.0</code> 的范围内不是很直观，所以我们会指定自己的坐标集(Coordinate Set)并将它变换回标准化设备坐标系。</p><p>  为了将顶点坐标从观察变换到裁剪空间，我们需要定义一个<strong>投影矩阵(Projection Matrix)</strong>，它指定了一个范围的坐标，比如在每个维度上的 <code>-1000</code> 到 <code>1000</code>。投影矩阵接着会将在这个指定的范围内的坐标变换为<strong>标准化设备坐标</strong>的范围<code>(-1.0, 1.0)</code>。所有在范围外的坐标不会被映射到在 <code>-1.0</code>到 <code>1.0</code> 的范围之间，所以会被裁剪掉。在上面这个投影矩阵所指定的范围内，坐标<code>(1250, 500, 750)</code>将是不可见的，这是由于它的 <code>x</code> 坐标超出了范围，它被转化为一个大于<code>1.0</code>的标准化设备坐标，所以被裁剪掉了。</p><blockquote><p>  如果只是图元(Primitive)，例如三角形，的一部分超出了裁剪体积(Clipping Volume)，则OpenGL会重新构建这个三角形为一个或多个三角形让其能够适合这个裁剪范围。</p></blockquote><p>  由投影矩阵创建的<strong>观察箱</strong>(Viewing Box)被称为平截头体(Frustum)，每个出现在平截头体范围内的坐标都会最终出现在用户的屏幕上。</p><p>  <strong>将特定范围内的坐标转化到标准化设备坐标系的过程（而且它很容易被映射到2D观察空间坐标）被称之为投影(Projection)</strong>，因为使用<strong>投影矩阵</strong>能将3D坐标投影(Project)到很容易映射到2D的标准化设备坐标系中。</p><p>  一旦所有顶点被变换到裁剪空间，最终的操作——<strong>透视除法</strong>(Perspective Division)将会执行，在这个过程中我们将位置向量的<code>x</code>，<code>y</code>，<code>z</code>分量分别除以向量的齐次<code>w</code>分量；<strong>透视除法是将4D裁剪空间坐标变换为3D标准化设备坐标的过程</strong>。这一步会在每一个顶点着色器运行的最后被自动执行。</p><p>  在这一阶段之后，最终的坐标将会被映射到屏幕空间中，并被变换成片段。</p><p>  将观察坐标变换为裁剪坐标的投影矩阵可以为两种不同的形式，每种形式都定义了不同的平截头体。主要有：<strong>正交投影矩阵</strong>(Orthographic Projection Matrix)和<strong>透视投影矩阵</strong>(Perspective Projection Matrix)。</p><h2 id="正交投影"><a class="markdownIt-Anchor" href="#正交投影"></a> 正交投影</h2><p>  正交投影矩阵定义了一个类似立方体的平截头箱，它定义了一个裁剪空间，在这空间之外的顶点都会被裁剪掉。创建一个正交投影矩阵需要指定可见平截头体的<strong>宽</strong>、<strong>高</strong>和<strong>长度</strong>。在使用正射投影矩阵变换至裁剪空间之后处于这个平截头体内的所有坐标将不会被裁剪掉。它的平截头体看起来像一个容器：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201018191759632.png" alt="image-20201018191759632" style="zoom:80%;" /><p>  上面的平截头体定义了可见的坐标，它由由<strong>宽</strong>、<strong>高</strong>、<strong>近(Near)平面</strong>和<strong>远(Far)平面</strong>所指定。<strong>任何出现在近平面之前或远平面之后的坐标都会被裁剪掉</strong>。正交平截头体直接将平截头体内部的所有坐标映射为标准化设备坐标，因为每个向量的<code>w</code>分量都没有进行改变；如果<code>w</code>分量等于<code>1.0</code>，透视除法则不会改变这个坐标。</p><h2 id="透视投影"><a class="markdownIt-Anchor" href="#透视投影"></a> 透视投影</h2><p>  相比于正交投影，透视投影显得更加真实，它所投影的物体看起来进大远小。</p><p>  透视的效果在我们看一条无限长的高速公路或铁路时尤其明显，正如下面图片显示的那样：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201018192044212.png" alt="image-20201018192044212" style="zoom:80%;" /><p>  由于透视，这两条线在很远的地方看起来会相交。</p><p>  这正是透视投影想要模仿的效果，它是使用<strong>透视投影矩阵</strong>来完成的。这个投影矩阵将给定的平截头体范围映射到裁剪空间，除此之外还修改了每个顶点坐标的<code>w</code>值，从而使得<strong>离观察者越远的顶点坐标<code>w</code>分量越大</strong>。被变换到裁剪空间的坐标都会在 <code>-w</code> 到 <code>w</code> 的范围之间（任何大于这个范围的坐标都会被裁剪掉）。OpenGL要求所有可见的坐标都落在 <code>-1.0</code> 到 <code>1.0</code> 范围内，作为顶点着色器最后的输出，因此，一旦坐标在裁剪空间内之后，透视除法就会被应用到裁剪空间坐标上：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mi>u</mi><mi>t</mi><mo>=</mo><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>x</mi><mi mathvariant="normal">/</mi><mi>w</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>y</mi><mi mathvariant="normal">/</mi><mi>w</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>z</mi><mi mathvariant="normal">/</mi><mi>w</mi></mrow></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">out = \begin{pmatrix} x /w \\ y / w \\ z / w \end{pmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>  顶点坐标的每个分量都会除以它的<code>w</code>分量，距离观察者越远顶点坐标就会越小。</p><blockquote><p>  如果你对正射投影矩阵和透视投影矩阵是如何计算的很感兴趣（且不会对数学感到恐惧的话）推荐这篇由Songho写的<a href="http://www.songho.ca/opengl/gl_projectionmatrix.html">文章</a>。</p></blockquote><p>  一个透视平截头体可以被看作一个不均匀形状的箱子，在这个箱子内部的每个坐标都会被映射到裁剪空间上的一个点。下面是一张透视平截头体的图片：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201018192418084.png" alt="image-20201018192418084" style="zoom:80%;" /><p>  <code>fov</code> 值表示了它的视野（field of view）大小，一般设置为 <code>45</code> 会显得比较真实。此外，若要创建一个这样的平截头体，还需要提供宽高比、近平面和远平面距离。通常设置近距离为<code>0.1</code>，而远距离设为<code>100.0</code>。所有在近平面和远平面内且处于平截头体内的顶点都会被渲染。</p><blockquote><p>  当你把透视矩阵的 <em>near</em> 值设置太大时（如<code>10.0</code>），OpenGL会将靠近摄像机的坐标（在<code>0.0</code>和<code>10.0</code>之间）都裁剪掉，这会导致一个你在游戏中很熟悉的视觉效果：在太过靠近一个物体的时候你的视线会直接穿过去。</p></blockquote><h2 id="将变换矩阵组合到一起"><a class="markdownIt-Anchor" href="#将变换矩阵组合到一起"></a> 将变换矩阵组合到一起</h2><p>  上述的每一个步骤都创建了一个变换矩阵：<strong>模型矩阵</strong>、<strong>观察矩阵</strong>和<strong>投影矩阵</strong>。一个顶点坐标将会根据以下过程被变换到裁剪坐标：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mrow><mi>c</mi><mi>l</mi><mi>i</mi><mi>p</mi></mrow></msub><mo>=</mo><msub><mi>M</mi><mrow><mi>p</mi><mi>r</mi><mi>o</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow></msub><mo>⋅</mo><msub><mi>M</mi><mrow><mi>v</mi><mi>i</mi><mi>e</mi><mi>w</mi></mrow></msub><mo>⋅</mo><msub><mi>M</mi><mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>l</mi></mrow></msub><mo>⋅</mo><msub><mi>V</mi><mrow><mi>l</mi><mi>o</mi><mi>c</mi><mi>a</mi><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">V_{clip} = M_{projection} \cdot M_{view} \cdot M_{model} \cdot V_{local}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>  注意<strong>矩阵运算的顺序是相反的</strong>（记住我们需要从右往左阅读矩阵的乘法）。</p><h2 id="右手坐标系"><a class="markdownIt-Anchor" href="#右手坐标系"></a> 右手坐标系</h2><p>  OpenGL是一个右手坐标系。简单来说，就是正 <code>x</code> 轴在你的右手边，正 <code>y</code> 轴朝上，而正 <code>z</code> 轴是朝向后方的。想象你的屏幕处于三个轴的中心，则正 <code>z</code> 轴穿过你的屏幕朝向你。坐标系画起来如下：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201018193442847.png" alt="image-20201018193442847" style="zoom:80%;" /><p>  为了理解为什么被称为右手坐标系，按如下的步骤做：</p><ul><li>沿着正<code>y</code>轴方向伸出你的右臂，手指着上方。</li><li>大拇指指向右方。</li><li>食指指向上方。</li><li>中指向下弯曲<code>90</code>度。</li></ul><p>  如果你的动作正确，那么你的大拇指指向正<code>x</code>轴方向，食指指向正<code>y</code>轴方向，中指指向正<code>z</code>轴方向。</p><p>  如果你用左臂来做这些动作，你会发现**<code>z</code>轴的方向是相反的**。这个叫做<strong>左手坐标系</strong>，它被DirectX广泛地使用。注意在标准化设备坐标系中OpenGL实际上使用的是左手坐标系（投影矩阵交换了左右手）。</p><h2 id="欧拉角"><a class="markdownIt-Anchor" href="#欧拉角"></a> 欧拉角</h2><p>  欧拉角(Euler Angle)是可以表示3D空间中任何旋转的3个值，由莱昂哈德·欧拉(Leonhard Euler)在18世纪提出。一共有3种欧拉角：<strong>俯仰角(Pitch)</strong>、<strong>偏航角(Yaw)<strong>和</strong>滚转角(Roll)</strong>，下面的图片展示了它们的含义：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201018194424470.png" alt="image-20201018194424470" style="zoom:80%;" /><p>  对于我们的摄像机系统来说，我们只关心<strong>俯仰角</strong>和<strong>偏航角</strong></p><p>  给定一个俯仰角和偏航角，我们可以把它们转换为一个代表新的方向向量的3D向量。</p><p>  我们先从最基本的情况开始：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201018194704239.png" alt="image-20201018194704239" style="zoom:80%;" /><p>  把斜边边长定义为<code>1</code>，我们就能知道<strong>邻边</strong>的长度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>cos</mi><mo>⁡</mo><mtext> </mtext><mstyle mathcolor="red"><mi>x</mi><mi mathvariant="normal">/</mi><mstyle mathcolor="purple"><mi>h</mi><mo>=</mo><mi>cos</mi><mo>⁡</mo><mtext> </mtext><mstyle mathcolor="red"><mi>x</mi><mi mathvariant="normal">/</mi><mstyle mathcolor="purple"><mn>1</mn><mo>=</mo><mi>cos</mi><mo>⁡</mo><mtext> </mtext><mstyle mathcolor="red"><mi>x</mi></mstyle></mstyle></mstyle></mstyle></mstyle></mrow><annotation encoding="application/x-tex">\cos \ \color{red}x/\color{purple}h = \cos \ \color{red}x/\color{purple}1 = \cos\ \color{red}x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mord mathdefault" style="color:red;">x</span><span class="mord" style="color:red;">/</span><span class="mord mathdefault" style="color:purple;">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel" style="color:purple;">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop" style="color:purple;">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="color:purple;"><span style="color:purple;"> </span></span><span class="mord mathdefault" style="color:red;">x</span><span class="mord" style="color:red;">/</span><span class="mord" style="color:purple;">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel" style="color:purple;">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mop" style="color:purple;">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="color:purple;"><span style="color:purple;"> </span></span><span class="mord mathdefault" style="color:red;">x</span></span></span></span>，它的<strong>对边</strong>是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>sin</mi><mo>⁡</mo><mtext> </mtext><mstyle mathcolor="green"><mi>y</mi><mi mathvariant="normal">/</mi><mstyle mathcolor="purple"><mi>h</mi><mo>=</mo><mi>sin</mi><mo>⁡</mo><mtext> </mtext><mstyle mathcolor="green"><mi>y</mi><mi mathvariant="normal">/</mi><mstyle mathcolor="purple"><mn>1</mn><mo>=</mo><mi>sin</mi><mo>⁡</mo><mtext> </mtext><mstyle mathcolor="green"><mi>y</mi></mstyle></mstyle></mstyle></mstyle></mstyle></mrow><annotation encoding="application/x-tex">\sin \ \color{green}y/\color{purple}h = \sin \ \color{green}y/\color{purple}1 = \sin\ \color{green}y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.03588em;color:green;">y</span><span class="mord" style="color:green;">/</span><span class="mord mathdefault" style="color:purple;">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel" style="color:purple;">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop" style="color:purple;">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="color:purple;"><span style="color:purple;"> </span></span><span class="mord mathdefault" style="margin-right:0.03588em;color:green;">y</span><span class="mord" style="color:green;">/</span><span class="mord" style="color:purple;">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel" style="color:purple;">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8623000000000001em;vertical-align:-0.19444em;"></span><span class="mop" style="color:purple;">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="color:purple;"><span style="color:purple;"> </span></span><span class="mord mathdefault" style="margin-right:0.03588em;color:green;">y</span></span></span></span>。这样我们获得了能够得到<code>x</code>和<code>y</code>方向长度的通用公式，它们取决于所给的角度。我们使用它来计算方向向量的分量：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201018195303241.png" alt="image-20201018195303241" style="zoom:80%;" /><p>  如果我们想象自己在<code>xz</code>平面上，看向<code>y</code>轴，我们可以基于第一个三角形计算来计算它的<code>长度/y方向的强度</code>(Strength)（我们往上或往下看多少）。</p><pre><code class="hljs js">direction.y = sin(glm::radians(pitch)); <span class="hljs-comment">// 注意我们先把角度转为弧度</span></code></pre><p>  这里我们只更新了<code>y</code>值，仔细观察<code>x</code>和<code>z</code>分量也被影响了。从三角形中我们可以看到它们的值等于：</p><pre><code class="hljs js">direction.x = cos(glm::radians(pitch));direction.z = cos(glm::radians(pitch));</code></pre><p>  下面来看航偏角：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201018195223028.png" alt="image-20201018195223028" style="zoom:80%;" /><p>  就像俯仰角的三角形一样，我们可以看到<code>x</code>分量取决于<code>cos(yaw)</code>的值，<code>z</code>值同样取决于偏航角的正弦值。把这个加到前面的值中，会得到基于俯仰角和偏航角的方向向量：</p><pre><code class="hljs js">direction.x = cos(glm::radians(pitch)) * cos(glm::radians(yaw)); <span class="hljs-comment">// direction代表摄像机的前轴(Front)，这个前轴是和下图的摄像机的方向向量是相反的</span>direction.y = sin(glm::radians(pitch));direction.z = cos(glm::radians(pitch)) * sin(glm::radians(yaw));</code></pre><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201018195835526.png" alt="image-20201018195835526" style="zoom:80%;" /><p>  这样我们就有了一个可以把俯仰角和偏航角转化为用来自由旋转视角的摄像机的3维方向向量了。</p><h2 id="鼠标输入"><a class="markdownIt-Anchor" href="#鼠标输入"></a> 鼠标输入</h2><p>  偏航角和俯仰角是通过鼠标（或手柄）移动获得的，<strong>水平的移动影响偏航角</strong>，<strong>竖直的移动影响俯仰角</strong>。它的原理就是，储存上一帧鼠标的位置，在当前帧中我们当前计算鼠标位置与上一帧的位置相差多少。如果水平/竖直差别越大那么俯仰角或偏航角就改变越大，也就是摄像机需要移动更多的距离。</p><p>  在根据鼠标移动获取了俯仰角与偏航角后，就能用它们来计算真正的方向向量了：</p><pre><code class="hljs js">glm::vec3 front;front.x = cos(glm::radians(pitch)) * cos(glm::radians(yaw));front.y = sin(glm::radians(pitch));front.z = cos(glm::radians(pitch)) * sin(glm::radians(yaw));cameraFront = glm::normalize(front);</code></pre><p>  计算出来的方向向量就会包含根据鼠标移动计算出来的所有旋转了。</p><blockquote><p>  <strong>注意</strong>，使用欧拉角的摄像机系统并不完美。根据你的视角限制或者是配置，你仍然可能引入<a href="http://en.wikipedia.org/wiki/Gimbal_lock">万向节死锁</a>问题。最好的摄像机系统是使用四元数(Quaternions)的。（[这里](<a href="https://github.com/cybercser/OpenGL_3_3_Tutorial_Translation/blob/master/Tutorial">https://github.com/cybercser/OpenGL_3_3_Tutorial_Translation/blob/master/Tutorial</a> 17 <a href="http://Rotations.md">Rotations.md</a>)可以查看四元数摄像机的实现）</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>WebGL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>坐标系</tag>
      
      <tag>转换矩阵</tag>
      
      <tag>坐标空间</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>threeJS 中数学相关内容</title>
    <link href="/2020/10/18/WebGL/ThreeJS/threeJS-%E4%B8%AD%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/"/>
    <url>/2020/10/18/WebGL/ThreeJS/threeJS-%E4%B8%AD%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="three-中的矩阵关系"><a class="markdownIt-Anchor" href="#three-中的矩阵关系"></a> Three 中的矩阵关系</h1><p>REF: <a href="https://juejin.im/post/6844903510769664014">https://juejin.im/post/6844903510769664014</a></p><hr /><p>  我们将相机的位置方向, 相机的类型, 物体的位置和形变能转换为 <strong>矩阵</strong>, 将这些矩阵进行一系列计算后, 最终得到<strong>三维投影矩阵</strong>: <code>u_matrix</code></p><p>  基于它, 任意给定三维坐标<code>[x, y, z]</code>, 我们都能算出相机视平面上的位置:</p><p>  <strong>[x, y] = u_matrix * [x, y, z, 1]</strong></p><h2 id="three-中的矩阵"><a class="markdownIt-Anchor" href="#three-中的矩阵"></a> THREE 中的矩阵</h2><p>  THREE定义了场景(Scene)和相机(Camera)， Scene用来添加管理三维物体, Camera用来控制相机的位置， 角度等。</p><p>  THREE中定义了下述三个矩阵：</p><ul><li>相机投影类型：投影矩阵（<code>ProjectMatrix</code>）</li><li>相机的位置和方向: 视图矩阵 (<code>CameraMatrixWorldInverse</code> 或 <code>ViewMatrix</code>)</li><li>物体的位置和形变: 物体位置矩阵(<code>ObjectWorldMatrix</code>)</li></ul><h2 id="三维投影矩阵u_matrix计算公式"><a class="markdownIt-Anchor" href="#三维投影矩阵u_matrix计算公式"></a> 三维投影矩阵(u_matrix)计算公式</h2><p>  三维投影矩阵计算公式如下：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> uMatrix = ProjectMatrix * CameraMatrixWorldInverse * ObjectMatrixWorld</code></pre><h3 id="相机投影矩阵projectmatrix"><a class="markdownIt-Anchor" href="#相机投影矩阵projectmatrix"></a> 相机投影矩阵（ProjectMatrix）</h3><p>  在THREE中，通过用不同的相机类实例化，得到不同类型的相机，例如定义一个透视投影相机：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> camera = <span class="hljs-keyword">new</span> THREE.PerspectiveCamera(fov, aspect, near, far);</code></pre><ul><li><p>获得 <code>ProjectionMatrix</code></p><pre><code class="hljs js">camera.projectionMatrix</code></pre><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost@master/img/image-20200807170747954.png" alt="image-20200807170747954" style="zoom:80%;" /></li></ul><h3 id="相机视图矩阵cameramatrixworldinverse"><a class="markdownIt-Anchor" href="#相机视图矩阵cameramatrixworldinverse"></a> 相机视图矩阵(CameraMatrixWorldInverse)</h3><p>  有的三维引擎或教程，会把视图矩阵称为<code>ViewMatrix</code>（例如webglfundamentals）</p><p>  视图矩阵的含义是，固定其他因素，我们改变了相机的位置和角度后，它眼中的世界也会发生变化，这种变化就是视图矩阵。</p><p>  前面提到，<strong>相机在三维空间中的位置</strong>是<code>camera.matrixWorld</code>，而<strong>它的视图矩阵是相机位置矩阵的逆矩阵</strong><code>CameraMatrixWorldInverse</code>，它也符合了我们的生活经验：</p><ul><li>固定相机，人向左移动</li><li>固定人，向右移动相机</li></ul><p>  这两种情况在相机眼中是一样的。</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost@master/img/image-20200807170828153.png" alt="image-20200807170828153" style="zoom:80%;" /><p>  在THREE中，我们一般通过设置<code>camera</code>的position和up，调用<code>lookAt</code>来改变相机的视图矩阵</p><pre><code class="hljs js">camera.position.set(x, y, z);camera.up.set(x, y, z);camera.lookAt(x, y, z);</code></pre><ul><li><p>获得 <code>CameraMatrixInverse</code></p><pre><code class="hljs js">camera.matrixWorldInverse</code></pre></li></ul><blockquote><p>  我们知道，最终的投影是在GLSL顶点着色器中计算的。</p><p>  在一次绘制中，<code>ProjectionMatrix</code>和<code>CameraMatrixWorldInverse</code>一般不会发生变化，而<code>ObjectMatrixWorld</code>每个物体都可能不同， 所以为了减少顶点着色器中的计算量，有些三维引擎会在javascript程序中提前计算出<code>ProjectionMatrix * CameraMatrixWorldInverse</code>的值传递给顶点着色器，这个矩阵一般称为<code>ViewProjectionMatrix</code></p></blockquote><h3 id="物体位置矩阵objectworldmatrix"><a class="markdownIt-Anchor" href="#物体位置矩阵objectworldmatrix"></a> 物体位置矩阵(ObjectWorldMatrix)</h3><p>  <code>ObjectWorldMatrix</code> 描述了物体在三维场景中的位置。</p><ul><li><p>获得 <code>ObjectWorldMatrix</code></p><pre><code class="hljs js">object.matrixWorld</code></pre></li></ul><p>  前面提到，THREE中的物体是有层级关系的，所以THREE中物体的<code>matrixWorld</code>是通过<code>local matrix</code>（<code>object.matrix</code>）与父亲的<code>matrixWorld</code>递归相乘得到的， 其中的原理可以查阅webglfundamentals中的<a href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-scene-graph.html">这篇教程</a></p><h1 id="box3"><a class="markdownIt-Anchor" href="#box3"></a> Box3</h1><h2 id="ref-httpswwwmrguolinkarticleid12"><a class="markdownIt-Anchor" href="#ref-httpswwwmrguolinkarticleid12"></a> REF: <a href="https://www.mrguo.link/article?id=12">https://www.mrguo.link/article?id=12</a></h2><p>  在线案例点击<a href="http://three.mrguo.link/box3">three.js Box3</a>。</p><p>  Box3 在3D空间中表示一个包围盒。其主要用于表示物体在世界坐标中的边界框。它方便我们判断物体和物体、物体和平面、物体和点的关系等等。</p><p>  构造器参数<code>Box3( min : Vector3, max : Vector3 )</code>，其参数为两个三维向量，第一个向量为Box3在3D空间中各个维度的最小值，第二个参数为Box3在3D空间中各个维度的最大值，代码如下。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> box = <span class="hljs-keyword">new</span> THREE.Box3(<span class="hljs-keyword">new</span> THREE.Vector3(<span class="hljs-number">-2</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">-2</span>), <span class="hljs-keyword">new</span> THREE.Vector3(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>));js</code></pre><p>  这个box就表示3D空间中中心点在<code>(0,0,0)</code>，长宽高为<code>4</code>的包围盒。</p><h1 id="vector3"><a class="markdownIt-Anchor" href="#vector3"></a> Vector3</h1><p>REF: <a href="https://www.mrguo.link/article?id=14">https://www.mrguo.link/article?id=14</a></p><hr /><h2 id="vector3-的方法"><a class="markdownIt-Anchor" href="#vector3-的方法"></a> Vector3 的方法</h2><h3 id="setfrommatrixscale-m-matrix4-this"><a class="markdownIt-Anchor" href="#setfrommatrixscale-m-matrix4-this"></a> setFromMatrixScale( m: Matrix4 ): this</h3><p>  从变换矩阵（transformation matrix）<code>m</code>中， 设置该向量为其中与缩放相关的元素。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> vec1 = <span class="hljs-keyword">new</span> THREE.Vector3();<span class="hljs-keyword">var</span> matrix = <span class="hljs-keyword">new</span> THREE.Matrix4().makeScale(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);vec1.setFromMatrixScale(matrix);<span class="hljs-comment">//返回Vector3 &#123;x: 1, y: 2, z: 3&#125;</span></code></pre><h3 id="applymatrix4-m-matrix4-this"><a class="markdownIt-Anchor" href="#applymatrix4-m-matrix4-this"></a> applyMatrix4( m: Matrix4 ): this</h3><p>  将该向量乘以四阶矩阵<code>m</code>（第四个维度隐式地为<code>1</code>）</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> vec1 = <span class="hljs-keyword">new</span> THREE.Vector3(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<span class="hljs-keyword">var</span> matrix = <span class="hljs-keyword">new</span> THREE.Matrix4().makeRotationZ(-<span class="hljs-built_in">Math</span>.PI/<span class="hljs-number">6</span>);vec1.applyMatrix4(matrix);<span class="hljs-comment">//返回值和上面相同</span></code></pre><h1 id="matrix3"><a class="markdownIt-Anchor" href="#matrix3"></a> Matrix3</h1><p>  three.js文档中以行为主的顺序显示矩阵。 但是，如果您正在阅读源代码，您必须对这里列出的任何矩阵进行转置<code>transpose</code>，以理解计算。例如：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> matrix3 = <span class="hljs-keyword">new</span> THREE.Matrix3().set( <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>); <span class="hljs-comment">//而其内部elements则展示为： matrix3.elements = [1,4,7,2,5,8,3,6,9];</span></code></pre><h2 id="matrix3-的属性"><a class="markdownIt-Anchor" href="#matrix3-的属性"></a> Matrix3 的属性</h2><p>  <code>elements:Array</code> ：矩阵列优先column-major列表。</p><p>  <code>isMatrix3:Boolean</code>：用于判定此对象或者此类的派生对象是否是三维矩阵。默认值为 <code>true</code>。</p><h2 id="matrix3的方法"><a class="markdownIt-Anchor" href="#matrix3的方法"></a> Matrix3的方法</h2><h3 id="set-matrix3"><a class="markdownIt-Anchor" href="#set-matrix3"></a> set() : Matrix3</h3><p>  三维矩阵不能在构造函数中直接设置参数值，需要通过<code>set()</code>方法设置，<code>set()</code>方法参数采用<strong>行优先</strong>row-major， 而它们在内部是用列优先column-major顺序存储在数组当中。</p><h3 id="identitymatrix3"><a class="markdownIt-Anchor" href="#identitymatrix3"></a> identity():Matrix3</h3><p>  将此矩阵重置为3x3单位矩阵。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> matrix = <span class="hljs-keyword">new</span> THREE.Matrix3(); matrix.identity();<span class="hljs-comment">//返回elements: (9) [1, 0, 0, 0, 1, 0, 0, 0, 1]</span></code></pre><h3 id="clonethis"><a class="markdownIt-Anchor" href="#clonethis"></a> clone():this</h3><p>  创建一个新的矩阵，元素 elements 与该矩阵相同。</p><h3 id="copymmatrix3this"><a class="markdownIt-Anchor" href="#copymmatrix3this"></a> copy(m:Matrix3):this</h3><p>  将矩阵<code>m</code>的元素复制到当前矩阵中。</p><h3 id="extractbasis-xaxis-vector3-yaxis-vector3-zaxis-vector3-matrix3"><a class="markdownIt-Anchor" href="#extractbasis-xaxis-vector3-yaxis-vector3-zaxis-vector3-matrix3"></a> extractBasis( xAxis: Vector3, yAxis: Vector3, zAxis: Vector3 ): Matrix3</h3><p>  将此矩阵的基提取到提供的三个轴向量中。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> matrix = <span class="hljs-keyword">new</span> THREE.Matrix3(); matrix.set( <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>)； <span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> THREE.Vector3(); <span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> THREE.Vector3(); <span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> THREE.Vector3(); matrix.extractBasis(a, b, c); <span class="hljs-built_in">console</span>.log(a,b,c);<span class="hljs-comment">//返回Vector3 &#123;x: 1, y: 4, z: 7&#125; Vector3 &#123;x: 2, y: 5, z: 8&#125; Vector3 &#123;x: 3, y: 6, z: 9&#125;</span></code></pre><h3 id="setfrommatrix4-m-matrix4-matrix3"><a class="markdownIt-Anchor" href="#setfrommatrix4-m-matrix4-matrix3"></a> setFromMatrix4( m: Matrix4 ): Matrix3</h3><p>  将当前矩阵设置为<code>4X4</code>矩阵，<code>m</code>左上<code>3X3</code>，</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> matrix = <span class="hljs-keyword">new</span> THREE.Matrix3(); <span class="hljs-keyword">var</span> matrix4 = <span class="hljs-keyword">new</span> THREE.Matrix4().makeScale(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>); matrix.setFromMatrix4(matrix4)<span class="hljs-comment">//elements: (9) [2, 0, 0, 0, 2, 0, 0, 0, 2]</span></code></pre><h3 id="multiplyscalar-s-number-matrix3"><a class="markdownIt-Anchor" href="#multiplyscalar-s-number-matrix3"></a> multiplyScalar( s: number ): Matrix3</h3><p>  当前矩阵所有的元素乘以该缩放值<code>s</code></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> matrix = <span class="hljs-keyword">new</span> THREE.Matrix3(); matrix.set( <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>)； matrix.multiplyScalar(<span class="hljs-number">2</span>)<span class="hljs-comment">//elements: (9) [2, 8, 14, 4, 10, 16, 6, 12, 18]</span></code></pre><h3 id="determinant-number"><a class="markdownIt-Anchor" href="#determinant-number"></a> determinant(): number</h3><p>  计算并返回矩阵的行列式determinant 。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> matrix = <span class="hljs-keyword">new</span> THREE.Matrix3(); matrix.set( <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>)； matrix.determinant()<span class="hljs-comment">//返回0</span></code></pre><h3 id="getinverse-matrix-matrix3-throwondegenerate-boolean-matrix3"><a class="markdownIt-Anchor" href="#getinverse-matrix-matrix3-throwondegenerate-boolean-matrix3"></a> getInverse( matrix: Matrix3, throwOnDegenerate?: boolean ): Matrix3</h3><p>  求传入矩阵<code>m</code>的逆矩阵，使用解析法将该矩阵设置为传递矩阵<code>m</code>的逆矩阵。</p><p>  行列式为零的矩阵不能求逆。如果尝试这样做，该方法将返回一个零矩阵。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> matrix1 = <span class="hljs-keyword">new</span> THREE.Matrix3(); <span class="hljs-keyword">var</span> matrix2 = <span class="hljs-keyword">new</span> THREE.Matrix3(); matrix1.set(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>)； matrix2.set(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)； <span class="hljs-keyword">new</span> THREE.Matrix3().getInverse(matrix1)<span class="hljs-comment">//因为行列式的值为0，所以返回零矩阵elements: (9) [0, 0, 0, 0, 0, 0, 0, 0, 0] </span><span class="hljs-keyword">new</span> THREE.Matrix3().getInverse(matrix2)<span class="hljs-comment">//因为行列式的值不为0，所以返回elements: (9) [1, 0, 0, -1, 1, 0, 1, -1, 1]</span></code></pre><p>  求逆矩阵的方法有很多，可以通过伴随矩阵求逆矩阵，也可以行做差来构造逆矩阵。</p><h3 id="transpose-matrix3"><a class="markdownIt-Anchor" href="#transpose-matrix3"></a> transpose(): Matrix3</h3><p>  将该矩阵转置。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> matrix = <span class="hljs-keyword">new</span> THREE.Matrix3(); matrix.set(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)；<span class="hljs-comment">//返回elements: (9) [1, 0, 0, 1, 1, 0, 0, 1, 1]; matrix.transpose(); </span><span class="hljs-built_in">console</span>.log(matrix);<span class="hljs-comment">//返回elements: (9) [1, 1, 0, 0, 1, 1, 0, 0, 1];</span></code></pre><h3 id="getnormalmatrix-matrix4-matrix4-matrix3"><a class="markdownIt-Anchor" href="#getnormalmatrix-matrix4-matrix4-matrix3"></a> getNormalMatrix( matrix4: Matrix4 ): Matrix3</h3><p>  将这个矩阵设置为给定矩阵的正规矩阵normal matrix（左上角的3x3）。</p><p>  正规矩阵是矩阵<code>m</code>的逆矩阵<code>inverse</code>的转置<code>transpose</code>。</p><pre><code class="hljs js"><span class="hljs-built_in">this</span>.setFromMatrix4( matrix4 ).getInverse( <span class="hljs-built_in">this</span> ).transpose();</code></pre><p>  上面是three.js的源码，从源码可以看出这是setFromMatrix4，getInverse和transpose的组合用法。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> matrix = <span class="hljs-keyword">new</span> THREE.Matrix3(); <span class="hljs-keyword">var</span> matrix4 = <span class="hljs-keyword">new</span> THREE.Matrix4().makeScale(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>); matrix.getNormalMatrix(matrix4);<span class="hljs-comment">//返回elements: (9) [0.5, 0, 0, 0, 0.5, 0, 0, 0, 0.5]</span></code></pre><h3 id="transposeintoarray-r-number-matrix3"><a class="markdownIt-Anchor" href="#transposeintoarray-r-number-matrix3"></a> transposeIntoArray( r: number[] ): Matrix3</h3><p>  将当前矩阵的转置<code>Transposes</code>存入给定的数组<code>array : Array</code>但不改变当前矩阵， 并返回当前矩阵。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> matrix = <span class="hljs-keyword">new</span> THREE.Matrix3(); matrix.set(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)； <span class="hljs-keyword">var</span> array = []; matrix.transposeIntoArray(array); <span class="hljs-built_in">console</span>.log(array);<span class="hljs-comment">//返回[1, 1, 0, 0, 1, 1, 0, 0, 1]</span></code></pre><h3 id="setuvtransform-tx-number-ty-number-sx-number-sy-number-rotation-number-cx-number-cy-number-matrix3"><a class="markdownIt-Anchor" href="#setuvtransform-tx-number-ty-number-sx-number-sy-number-rotation-number-cx-number-cy-number-matrix3"></a> setUvTransform( tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number ): Matrix3</h3><p><code>tx</code> - x偏移量</p><p><code>ty</code> - y偏移量</p><p><code>sx</code> - x方向的重复比例</p><p><code>sy</code> - y方向的重复比例</p><p><code>rotation</code>- 旋转（弧度）</p><p><code>cx</code>- 旋转中心x</p><p><code>cy</code>- 旋转中心y</p><p>  使用偏移，重复，旋转和中心点位置设置UV变换矩阵。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> matrix = <span class="hljs-keyword">new</span> THREE.Matrix3(); matrix.setUvTransform(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.5</span>,<span class="hljs-number">0.5</span>); <span class="hljs-built_in">console</span>.log(matrix);<span class="hljs-comment">//返回elements: (9) [0, -0, 0, 0, 0, 0, 0.5, 0.5, 1]</span></code></pre><h3 id="equals-matrix-matrix3-boolean"><a class="markdownIt-Anchor" href="#equals-matrix-matrix3-boolean"></a> equals( matrix: Matrix3 ): boolean</h3><p>  如果矩阵<code>m</code>与当前矩阵所有对应元素相同则返回<code>true</code>。</p><h3 id="fromarray-array-number-offset-number-matrix3"><a class="markdownIt-Anchor" href="#fromarray-array-number-offset-number-matrix3"></a> fromArray( array: number[], offset?: number ): Matrix3</h3><p>  使用基于列优先格式column-major的数组来设置该矩阵。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> matrix = <span class="hljs-keyword">new</span> THREE.Matrix3(); matrix.fromArray([<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>]);<span class="hljs-comment">//因为是基于列优先原则，所以设置的数组和elements属性相同，不需转置。</span></code></pre><h3 id="toarray-array-number-offset-number-number"><a class="markdownIt-Anchor" href="#toarray-array-number-offset-number-number"></a> toArray( array?: number[], offset?: number ): number[]</h3><p>  使用列优先column-major格式将此矩阵的元素写入数组中。这是<code>fromArray</code>的逆运算。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> matrix = <span class="hljs-keyword">new</span> THREE.Matrix3(); matrix.set(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>); matrix.toArray(array); <span class="hljs-built_in">console</span>.log(array);<span class="hljs-comment">//返回[1, 4, 7, 2, 5, 8, 3, 6, 9]</span></code></pre><h3 id="multiply-m-matrix3-matrix3"><a class="markdownIt-Anchor" href="#multiply-m-matrix3-matrix3"></a> multiply( m: Matrix3 ): Matrix3</h3><p>  将当前矩阵乘以矩阵<code>m</code>。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> matrix1 = <span class="hljs-keyword">new</span> THREE.Matrix3(); <span class="hljs-keyword">var</span> matrix2 = <span class="hljs-keyword">new</span> THREE.Matrix3(); matrix1.set(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>); matrix2.setFromMatrix4(<span class="hljs-keyword">new</span> THREE.Matrix4().makeScale(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>));<span class="hljs-comment">//通过4维矩阵，得到三维矩阵 </span>matrix1.multiply(matrix2);<span class="hljs-comment">//返回elements: (9) [0.5, 2, 3.5, 1, 2.5, 4, 1.5, 3, 4.5]</span></code></pre><h3 id="premultiply-m-matrix3-matrix3"><a class="markdownIt-Anchor" href="#premultiply-m-matrix3-matrix3"></a> premultiply( m: Matrix3 ): Matrix3</h3><p>  将矩阵<code>m</code>乘以当前矩阵。和上面相比这是左乘和右乘的问题。</p><h3 id="multiplymatrices-a-matrix3-b-matrix3-matrix3"><a class="markdownIt-Anchor" href="#multiplymatrices-a-matrix3-b-matrix3-matrix3"></a> multiplyMatrices( a: Matrix3, b: Matrix3 ): Matrix3</h3><p>  设置当前矩阵为矩阵a x 矩阵b。和上面的方法差不多</p><h3 id="multiplyvector3-vector-vector3-any"><a class="markdownIt-Anchor" href="#multiplyvector3-vector-vector3-any"></a> multiplyVector3( vector: Vector3 ): any</h3><p>  和Vector3.applyMatrix3一样</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> matrix1 = <span class="hljs-keyword">new</span> THREE.Matrix3(); matrix1.set(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>); <span class="hljs-keyword">var</span> vector3 = <span class="hljs-keyword">new</span> THREE.Vector3(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>); matrix1.multiplyVector3(vector3);<span class="hljs-comment">//返回Vector3 &#123;x: 14, y: 32, z: 50&#125;</span></code></pre><h1 id="分离轴定理separating-axis-theorem"><a class="markdownIt-Anchor" href="#分离轴定理separating-axis-theorem"></a> 分离轴定理（Separating Axis Theorem）</h1><p><strong>原文</strong>：<a href="https://aotu.io/notes/2017/02/16/2d-collision-detection/">https://aotu.io/notes/2017/02/16/2d-collision-detection/</a></p><p>  <strong>概念</strong>：通过判断任意两个 <code>凸多边形</code> 在任意角度下的投影是否均存在重叠，来判断是否发生碰撞。若在某一角度光源下，两物体的投影存在间隙，则为不碰撞，否则为发生碰撞。</p><p><strong>图例：</strong></p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/83792-20170706121724065-2000235824.png" alt="83792-20170706121724065-2000235824" style="zoom:80%;" /><p>  在程序中，遍历所有角度是不现实的。那如何确定 <code>投影轴</code> 呢？其实只需对多边形的每一条边都判断一遍即可。且在判断过程中，若提前发现间隙，则不用进行剩下的判断了。</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/83792-20170706121734284-438000124.png" alt="83792-20170706121734284-438000124" style="zoom:80%;" /><p>  每个投影轴其实就是对应边的法向量：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200808212950411.png" alt="image-20200808212950411" style="zoom: 50%;" /><p><strong>圆形与多边形之间的碰撞检测</strong></p><p>  由于圆形可近似地看成一个有无数条边的正多边形，而我们不可能按照这些边一一进行投影与测试。我们只需将圆形投射到一条投影轴上即可，这条轴就是圆心与多边形顶点中最近的一点的连线，如图所示：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/83792-20170706122010112-1512221308.png" alt="83792-20170706122010112-1512221308" style="zoom:80%;" /><p>  因此，该投影轴和多边形自身的投影轴就组成了一组待检测的投影轴了。另外，圆的投影可以先投影圆心那一点，然后再在两边加上半径即可。</p><p>  而对于圆形与圆形之间的碰撞检测依然是最初的两圆心距离是否小于两半径之和。</p>]]></content>
    
    
    <categories>
      
      <category>WebGL</category>
      
      <category>ThreeJS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵</tag>
      
      <tag>向量</tag>
      
      <tag>Matrix</tag>
      
      <tag>Box</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>牛顿迭代法</title>
    <link href="/2020/10/18/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95/"/>
    <url>/2020/10/18/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>转自 <a href="https://leetcode-cn.com/problems/sqrtx/solution/x-de-ping-fang-gen-by-leetcode-solution/">LeetCode 解答</a></p><p><a href="https://my.oschina.net/u/4581403/blog/4561900">一篇解释得很细的文章</a></p><hr /><p>  <a href="https://baike.baidu.com/item/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95">牛顿迭代法</a>是一种可以用来快速求解函数零点的方法。</p><p>  以 <a href="https://leetcode-cn.com/problems/sqrtx/">LeetCode</a> 上的一题为例：模拟 <code>int sqrt(x)</code> 函数，返回的开方值向下取整。</p><p>  为了叙述方便，我们用 <code>C</code> 表示待求出平方根的那个整数。显然，<code>C</code> 的平方根就是函数</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup><mo>−</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">y = f(x) = x^2 - C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9474379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span></span></p><p>  的零点。</p><p>  我们任取一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 作为初始值，在每一步的迭代中，我们找到图像上的点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_i,f(x_i))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> 过该点做一条斜率为该点导数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal">′</mo></msup><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f&#x27;(x_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的直线，直线与 <code>x</code> 轴的交点记为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">x_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">x_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> 相对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 而言距离零点更加接近。进过多次迭代后，就能得到一个非常接近零点的与 <code>x</code> 轴的交点。</p><p>  下图给出了从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 开始迭代两次，得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的过程：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201018114250949.png" alt="image-20201018114250949" style="zoom:80%;" /><p>  首先，我们选择 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>=</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">x_0 = C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 作为初始值。</p><p>  在每一步的迭代中，通过当前与 <code>x</code> 轴的交点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，得到函数图像上的一点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><msup><mi>x</mi><mn>2</mn></msup><mo>−</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_i, x^2 - C)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose">)</span></span></span></span> ，做一条斜率为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal">′</mo></msup><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f&#x27;(x_i) = 2x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的直线，直线方程为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>−</mo><msub><mi>y</mi><mn>0</mn></msub><mo>=</mo><mi>k</mi><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y - y_0 = k(x - x_0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>=</mo><mn>2</mn><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>+</mo><msubsup><mi>x</mi><mi>i</mi><mn>2</mn></msubsup><mo>−</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">y = 2x_i(x - x_i) + x_i^2 - C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1111079999999998em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span></span></p><p>  因此，与 <code>x</code> 轴的交点为方程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><msub><mi>x</mi><mi>i</mi></msub><mi>x</mi><mo>−</mo><mo stretchy="false">(</mo><msubsup><mi>x</mi><mi>i</mi><mn>2</mn></msubsup><mo>+</mo><mi>C</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">2x_ix - (x_i^2 + C) = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.072772em;vertical-align:-0.258664em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的解，即为新的迭代结果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">x_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> ：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>+</mo><mfrac><mi>C</mi><msub><mi>x</mi><mi>i</mi></msub></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x_{i+1} = \frac{1}{2}(x_i + \frac{C}{x_i})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.19633em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></span></p><p>  在进行 <code>k</code> 次迭代之后，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">x_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 与真实值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mi>C</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.11333499999999996em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9266650000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span><span style="top:-2.886665em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.11333499999999996em;"><span></span></span></span></span></span></span></span></span> 足够接近，即可作为答案。</p><p>  <strong>选择 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>=</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">x_0 = C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 作为初始值的原因：</strong></p><p>  因为函数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup><mo>−</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">y = x^2 - C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 有两个零点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><msqrt><mi>C</mi></msqrt></mrow><annotation encoding="application/x-tex">-\sqrt{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.11333499999999996em;"></span><span class="mord">−</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9266650000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span><span style="top:-2.886665em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.11333499999999996em;"><span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mi>C</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.11333499999999996em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9266650000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span><span style="top:-2.886665em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.11333499999999996em;"><span></span></span></span></span></span></span></span></span>。而我们想找的是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mi>C</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.11333499999999996em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9266650000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span><span style="top:-2.886665em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.11333499999999996em;"><span></span></span></span></span></span></span></span></span>，如果初始值比较小的话，有可能迭代到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><msqrt><mi>C</mi></msqrt></mrow><annotation encoding="application/x-tex">-\sqrt{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.11333499999999996em;"></span><span class="mord">−</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9266650000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span><span style="top:-2.886665em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.11333499999999996em;"><span></span></span></span></span></span></span></span></span> 这个零点，因此选择 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>=</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">x_0 = C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 作为初始值。且每次迭代均有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&lt;</mo><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_{i+1} &lt; x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.747431em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，零点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mi>C</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.11333499999999996em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9266650000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span><span style="top:-2.886665em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.11333499999999996em;"><span></span></span></span></span></span></span></span></span> 在其左侧，因此我们一定会迭代到这个零点。</p><p>  <strong>迭代终止条件：</strong></p><p>  每一次迭代，我们都会离零点更近一步，所以当两次迭代的距离非常近时，就可以认为是已经非常逼近零点了，也就能将其作为答案。判断接近程度可以使用一个非常小的值来做比较，如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>x</mi><mi>i</mi></msub><mo>&lt;</mo><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>6</mn></mrow></msup></mrow><annotation encoding="application/x-tex">x_{i+1} - x_i &lt; 10^{-6}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.791661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span> 。</p><p>  <strong>C 代码如下：</strong></p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;    <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;        <span class="hljs-keyword">double</span> x0 = x, c = x;    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;        <span class="hljs-keyword">double</span> xi = <span class="hljs-number">0.5</span> * (x0 + c / x0);        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(x0 - xi) &lt; <span class="hljs-number">1e-6</span>) &#123;            <span class="hljs-keyword">break</span>;        &#125;        x0 = xi;    &#125;        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)x0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>算法知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/2020/10/18/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2020/10/18/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<p>  所谓二分查找，就是从一个查找范围中每次取中间值，然后根据中间值来判断是否满足条件或是缩小查找范围的过程，且这个范围内的值需要是有规律的，比如是有序的。</p><h1 id="引子"><a class="markdownIt-Anchor" href="#引子"></a> 引子</h1><p>  以 <a href="https://leetcode-cn.com/problems/search-insert-position/">LeetCode</a> 的一道简单题为例：给定一个排序数组和一个目标值，返回目标值的索引，若不存在，则返回能够插入该目标值的索引。</p><p>  如 ：<code>array = [1,5,7,10,12], target = 6</code></p><p>  则返回值为 <code>2</code></p><p>  这题就是经典的使用二分查找的场景，最开始的查找范围是 <code>[0, 4]</code>，中间值 <code>array[2] = 7</code>，根据这个中间值，我们知道 <code>6</code> 是小于中间值的，因此能够缩小查找范围，即 <code>[0, 1]</code>，继续判断中间值 <code>array[0] = 1</code>，缩小查找范围 <code>[1, 1]</code>，最后发现查找范围内只剩下一个值 <code>5</code>，且小于目标值 <code>6</code> ，因此最后就能知道需要插入的索引是 <code>2</code>。</p><p>代码如下：</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">upperBound</span><span class="hljs-params">(<span class="hljs-keyword">int</span> r[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right,<span class="hljs-keyword">int</span> x)</span></span>&#123;    <span class="hljs-keyword">int</span> mid;    <span class="hljs-keyword">while</span>(left &lt;= right)&#123;        mid = (left + right) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(r[mid] == x)&#123;            <span class="hljs-keyword">return</span> mid;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(r[mid] &gt; x)&#123;            right = mid - <span class="hljs-number">1</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            left = mid + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> left;&#125;</code></pre><p>  其中， <code>(left + right) / 2</code> 有必要的话可以替换成 <code>left + (right - left) / 2</code>，以避免 <code>left + right</code> 超出整型范围的情况。</p><h1 id="二分查找变形"><a class="markdownIt-Anchor" href="#二分查找变形"></a> 二分查找变形</h1><p>  根据使用场景的不同，二分查找有一些变形算法。</p><p>  同样，以 <a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">剑指Offer</a> （或 <a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">LeetCode</a>）的一题为例，题目很简单，就是从一个有序数组中寻找数字 <code>target</code> 的出现次数，如 <code>nums = [5,7,7,8,8,10]</code> ，<code>target = 8</code>，程序输出 <code>2</code>，因为 <code>8</code> 出现了两次。</p><p>  因为数组有序，我们可以考虑使用二分查找把时间复杂度降为 <code>log(n)</code>。</p><p>  首先，使用二分查找找出<strong>第一个大于等于</strong> <code>target</code> 的位置 <code>lower</code> ，本例中就是 <code>3</code>，再使用二分查找找到<strong>第一个小于等于</strong> <code>target</code> 的位置 <code>l</code>，本例中就是 <code>4</code>，这样，数组中等于 <code>target</code> 的数字的出现次数就是 <code>l - lower + 1</code>，再考虑一些边界情况，即 <code>target</code> 未在数组中出现的情况，我们可以使用 <code>nums[l] === target</code>  来判断，若未出现过，返回 <code>0</code> 即可。</p><p><strong>JS 代码如下：</strong></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> search = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) </span>&#123;    <span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>, r = nums.length - <span class="hljs-number">1</span>;    <span class="hljs-comment">// 先找到第一个大于等于 target 的位置</span>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;        <span class="hljs-keyword">let</span> mid = l + <span class="hljs-built_in">Math</span>.floor((r - l) / <span class="hljs-number">2</span>);        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;            l = mid + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            r = mid;        &#125;    &#125;    <span class="hljs-keyword">let</span> lower = l;    l = <span class="hljs-number">0</span>, r = nums.length - <span class="hljs-number">1</span>;    <span class="hljs-comment">// 再找到第一个小于等于 target 的位置</span>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;        <span class="hljs-keyword">let</span> mid = l + <span class="hljs-built_in">Math</span>.ceil((r - l) / <span class="hljs-number">2</span>);        <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;            r = mid - <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            l = mid;        &#125;    &#125;        <span class="hljs-keyword">if</span> (nums[l] === target) &#123;        <span class="hljs-keyword">return</span> l - lower + <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;&#125;;</code></pre><h2 id="寻找第一个-大于等于-x-的位置"><a class="markdownIt-Anchor" href="#寻找第一个-大于等于-x-的位置"></a> 寻找第一个 《大于等于》  x 的位置</h2><p>  在下面代码中，循环结束时，<code>left</code> 是会刚好等于 <code>right</code> 的，<code>right</code> 总是会在<strong>大于等于</strong> <code>x</code> 的地方停下来，一直压缩区间，<code>left</code> 最后的位置会是第一个大于等于 <code>x</code> 的位置。</p><p>  如 <code>[5,7,7,8,8,10]</code> ，<code>x = 8</code>，那么当循环结束时， <code>l = r = 3</code>。</p><p>  如 <code>arr = [1, 3, 4, 6, 7]</code> ，<code>x = 5</code>，返回 <code>3</code>。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">upperBound</span>(<span class="hljs-params">arr, tar</span>) </span>&#123;    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>, right = arr.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">let</span> mid = <span class="hljs-built_in">Math</span>.floor((left + right) / <span class="hljs-number">2</span>);        <span class="hljs-keyword">let</span> num = arr[mid];        <span class="hljs-keyword">if</span> (tar &lt;= num) &#123;            right = mid;        &#125; <span class="hljs-keyword">else</span> &#123;            left = mid + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> left;&#125;</code></pre><h2 id="寻找第一个-大于-x-的位置"><a class="markdownIt-Anchor" href="#寻找第一个-大于-x-的位置"></a> 寻找第一个 《大于》  x 的位置</h2><p>  这个函数与上面一个函数的变化只是将 <code>if</code> 判断中的 <code>&lt;=</code> 改为 <code>&lt;</code>。</p><p>  如 <code>[5,7,7,8,8,10]</code> ，<code>x = 8</code>，那么当循环结束时， <code>l = r = 5</code>。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">upperBound</span>(<span class="hljs-params">arr, tar</span>) </span>&#123;    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>, right = arr.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">let</span> mid = <span class="hljs-built_in">Math</span>.floor((left + right) / <span class="hljs-number">2</span>);        <span class="hljs-keyword">let</span> num = arr[mid];        <span class="hljs-keyword">if</span> (tar &lt; num) &#123;            right = mid;        &#125; <span class="hljs-keyword">else</span> &#123;            left = mid + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> left;&#125;</code></pre><h2 id="寻找第一个-小于等于-x-的位置"><a class="markdownIt-Anchor" href="#寻找第一个-小于等于-x-的位置"></a> 寻找第一个 《小于等于》  x 的位置</h2><p>  同理，在循环中稍加变动，就能实现另一个效果，不过这时候计算 <code>mid</code> 需要<strong>向上取整</strong>了（之前都是向上取整的），不然可能会出现无限循环，因为每次都向下取整的话可能会出现 <code>left</code> 不变的情况（如索引相邻情况 ）：</p><p>  如 <code>[5,7,7,8,8,10]</code> ，<code>x = 8</code>，那么当循环结束时， <code>l = r = 4</code>。</p><p>  如 <code>[1, 3, 4, 6, 7]</code> ，<code>x = 5</code>，那么当循环结束时， <code>l = r = 2</code>。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lowerBound</span>(<span class="hljs-params">arr, tar</span>) </span>&#123;    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>, right = arr.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">let</span> mid = <span class="hljs-built_in">Math</span>.ceil((left + right) / <span class="hljs-number">2</span>);        <span class="hljs-keyword">let</span> num = arr[mid];        <span class="hljs-keyword">if</span> (tar &gt;= num) &#123;            left = mid;        &#125; <span class="hljs-keyword">else</span> &#123;            right = mid - <span class="hljs-number">1</span>;        &#125;    &#125;<span class="hljs-keyword">return</span> right;&#125;</code></pre><h2 id="寻找第一个-小于-x-的位置"><a class="markdownIt-Anchor" href="#寻找第一个-小于-x-的位置"></a> 寻找第一个 《小于》 x 的位置</h2><p>  同理，第一个小于 <code>x</code> 的位置：</p><p>  如 <code>[5,7,7,8,8,10]</code> ，<code>x = 8</code>，那么当循环结束时， <code>l = r = 2</code>。</p><p>  如 <code>[1, 3, 4, 6, 7]</code> ，<code>x = 5</code>，那么当循环结束时， <code>l = r = 2</code>。</p><pre><code class="hljs js"><span class="hljs-keyword">while</span> (left &lt; right) &#123;    <span class="hljs-keyword">let</span> mid = <span class="hljs-built_in">Math</span>.ceil((left + right) / <span class="hljs-number">2</span>);    <span class="hljs-keyword">let</span> num = arr[mid];    <span class="hljs-keyword">if</span> (tar &gt; num) &#123;        left = mid;    &#125; <span class="hljs-keyword">else</span> &#123;        right = mid - <span class="hljs-number">1</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>算法知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThreeJS 坐标转换</title>
    <link href="/2020/10/17/WebGL/ThreeJS/ThreeJS-%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2/"/>
    <url>/2020/10/17/WebGL/ThreeJS/ThreeJS-%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="物体坐标转屏幕坐标"><a class="markdownIt-Anchor" href="#物体坐标转屏幕坐标"></a> 物体坐标转屏幕坐标</h1><p>  在 ThreeJS 中，一个物体可看作一个 <code>Mesh</code>，<code>Mesh</code> 的坐标是用一个 <code>Vector3</code> 来表示的，<code>Vector3</code> 中包含了 <code>x</code>、<code>y</code>、<code>z</code> 坐标。</p><h2 id="project-方法"><a class="markdownIt-Anchor" href="#project-方法"></a> project 方法</h2><p>  通过 <code>Vector3</code>对象的方法 <code>project</code>，方法的参数是相机对象，语句 <code>worldVector.project(camera);</code>返回的结果是世界坐标 <code>worldVector</code>在 <code>camera</code>相机对象矩阵变化下对应的标准设备坐标， 标准设备坐标 <code>xyz</code> 的范围是<code>[-1,1]</code>。</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201015163144727.png" alt="image-20201015163144727" style="zoom:80%;" /><p>  Three 的场景是建立在 <code>canvas</code> 之上的，<code>canvas</code> 画布的宽高是：<code>canvas.offsetWidth</code> 和 <code>canvas.offsetHeight</code>，从<strong>屏幕坐标系</strong>来看，画布的中心就是：<code>(canvas.offsetWidth / 2，canvas.offsetHeight / 2)</code>，从 WebGL <strong>标准设备坐标系</strong>的角度来看画布中心是坐标原点 <code>(0, 0)</code>。</p><p>  因此，从标准设备坐标系转换到屏幕坐标系我们可以这样做：</p><p>  首先计算出屏幕坐标系中心：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> centerX = canvas.offsetWidth / <span class="hljs-number">2</span>;<span class="hljs-keyword">const</span> centerY = canvas.offsetHeight / <span class="hljs-number">2</span>;</code></pre><p>  计算出的 <code>centerX</code> 和 <code>centerY</code> 同时也表示了坐标轴的一半大小。</p><p>  然后，由于<strong>屏幕坐标系的原点是在左上角</strong>，因此转换公式如下：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> standardVec = worldVector.project(camera);<span class="hljs-keyword">const</span> screenX = <span class="hljs-built_in">Math</span>.round(centerX * standardVec.x + centerX);<span class="hljs-keyword">const</span> screenY = <span class="hljs-built_in">Math</span>.round(-centerY * standardVec.y + centerY);</code></pre><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h1><p><a href="http://www.yanhuangxueyuan.com/Three.js_course/screen.html">http://www.yanhuangxueyuan.com/Three.js_course/screen.html</a></p>]]></content>
    
    
    <categories>
      
      <category>WebGL</category>
      
      <category>ThreeJS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>threeJS</tag>
      
      <tag>坐标转换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 52. N皇后 II</title>
    <link href="/2020/10/17/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/52-N%E7%9A%87%E5%90%8E-II/"/>
    <url>/2020/10/17/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/52-N%E7%9A%87%E5%90%8E-II/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/n-queens-ii/">https://leetcode-cn.com/problems/n-queens-ii/</a></p><p>难度：困难</p><hr /><p>  <em>n</em> 皇后问题研究的是如何将 <em>n</em> 个皇后放置在 <em>n</em>×<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201017095826142.png" alt="image-20201017095826142" style="zoom:80%;" /><p>  上图为 8 皇后问题的一种解法。</p><p>  给定一个整数 <em>n</em>，返回 <em>n</em> 皇后<strong>不同的解决方案的数量</strong>。</p><p><strong>示例:</strong></p><p>输入: 4</p><p>输出: 2</p><p>解释: 4 皇后问题存在如下两个不同的解法。</p><pre><code class="hljs json">[ [<span class="hljs-string">&quot;.Q..&quot;</span>,  <span class="hljs-comment">// 解法 1</span>  <span class="hljs-string">&quot;...Q&quot;</span>,  <span class="hljs-string">&quot;Q...&quot;</span>,  <span class="hljs-string">&quot;..Q.&quot;</span>], [<span class="hljs-string">&quot;..Q.&quot;</span>,  <span class="hljs-comment">// 解法 2</span>  <span class="hljs-string">&quot;Q...&quot;</span>,  <span class="hljs-string">&quot;...Q&quot;</span>,  <span class="hljs-string">&quot;.Q..&quot;</span>]]</code></pre><h2 id="解法1回溯"><a class="markdownIt-Anchor" href="#解法1回溯"></a> 解法1：回溯</h2><p>  解法和 <a href="http://yleave.top/2020/10/17/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/51-N%E7%9A%87%E5%90%8E/">N皇后1</a> 是一样的，区别就是本题求的是解法个数， N皇后1 求的是所有的解法棋盘布局。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> totalNQueens = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>&#123;    <span class="hljs-keyword">let</span> dirs = [[<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>], [<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>]];    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> board = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n).fill(<span class="hljs-number">0</span>).map(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n).fill(<span class="hljs-number">0</span>);    &#125;);    <span class="hljs-keyword">const</span> helper = <span class="hljs-function">(<span class="hljs-params">row</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (row === n) &#123;            res++;            <span class="hljs-keyword">return</span>;        &#125;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> col = <span class="hljs-number">0</span>; col &lt; n; col++) &#123;            <span class="hljs-keyword">let</span> flag;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> dir <span class="hljs-keyword">of</span> dirs) &#123;                <span class="hljs-keyword">let</span> r = row, c = col;                flag = <span class="hljs-literal">true</span>;                <span class="hljs-keyword">while</span> (r &gt;= <span class="hljs-number">0</span> &amp;&amp; c &gt;= <span class="hljs-number">0</span> &amp;&amp; c &lt; n) &#123;                    <span class="hljs-keyword">if</span> (board[r][c] === <span class="hljs-number">1</span>) &#123;                        flag = <span class="hljs-literal">false</span>;                        <span class="hljs-keyword">break</span>;                    &#125;                    r += dir[<span class="hljs-number">0</span>], c += dir[<span class="hljs-number">1</span>];                &#125;                <span class="hljs-keyword">if</span> (!flag) &#123;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;            <span class="hljs-keyword">if</span> (flag) &#123;                board[row][col] = <span class="hljs-number">1</span>;                helper(row + <span class="hljs-number">1</span>);                board[row][col] = <span class="hljs-number">0</span>;            &#125;        &#125;    &#125;;    helper(<span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> res;&#125;;</code></pre><h2 id="解法2空间优化"><a class="markdownIt-Anchor" href="#解法2空间优化"></a> 解法2：空间优化</h2><p>  对于解法1，使用了 <code>n * n</code> 的棋盘来帮助判断某个位置是否满足安置皇后的要求，但是，对于每种 N皇后的安置策略，我们仅使用了棋盘中的一部分来帮助判断（即每个位置的两条斜线和直线），因此，我们可以缩小空间，仅使用三个列表来分别表示直行、和两条斜行上是否有皇后。</p><p>  例如，对于直行，若第三列上有皇后，则 <code>cols[3] = 1</code>，否则，<code>cols[3] = 0</code></p><p>  直行判断是否有皇后很简单，只要使用列下标即可。</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201017104019691.png" alt="image-20201017104019691" style="zoom:67%;" /><p>  对于其中一个方向的斜线，棋盘中的每条这个方向的斜线都能使用一个下标来表示，即 <strong>行下标 - 列下标</strong>：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201017110155747.png" alt="image-20201017110155747" style="zoom:67%;" /><p>  另一个方向的斜线能使用 <strong>行下标 + 列下标</strong> 来表示：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201017110328469.png" alt="image-20201017110328469" style="zoom:67%;" /><p>  因此，对于棋盘中的一个位置，只需借助这三个列表来判断位置是否合法即可（三个列表中都不含当前位置）</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> totalNQueens = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> cols = [], diagonal1 = [], diagonal2 = [];    <span class="hljs-keyword">const</span> helper = <span class="hljs-function">(<span class="hljs-params">row</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (row === n) &#123;            res++;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            <span class="hljs-keyword">if</span> (cols[i] === <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">let</span> d1 = row - i;            <span class="hljs-keyword">if</span> (diagonal1[d1] === <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">let</span> d2 = row + i;            <span class="hljs-keyword">if</span> (diagonal2[d2] === <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            cols[i] = <span class="hljs-number">1</span>;            diagonal1[d1] = <span class="hljs-number">1</span>;            diagonal2[d2] = <span class="hljs-number">1</span>;            helper(row+<span class="hljs-number">1</span>);            cols[i] = <span class="hljs-number">0</span>;            diagonal1[d1] = <span class="hljs-number">0</span>;            diagonal2[d2] = <span class="hljs-number">0</span>;        &#125;    &#125;;    helper(<span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> res;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>解答</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 51. N皇后</title>
    <link href="/2020/10/17/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/51-N%E7%9A%87%E5%90%8E/"/>
    <url>/2020/10/17/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/51-N%E7%9A%87%E5%90%8E/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/n-queens/">https://leetcode-cn.com/problems/n-queens/</a></p><p>难度：困难</p><hr /><p>  <em>n</em> 皇后问题研究的是如何将 <em>n</em> 个皇后放置在 <em>n</em>×<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201017095826142.png" alt="image-20201017095826142" style="zoom:80%;" /><p>  图为 8 皇后问题的一种解法。</p><p>  给定一个整数 <code>n</code>，返回所有不同的 <code>n</code> 皇后问题的解决方案。</p><p>  每一种解法包含一个明确的 <code>n</code> 皇后问题的棋子放置方案，该方案中 <code>'Q'</code> 和 <code>'.'</code> 分别代表了皇后和空位。</p><p><strong>示例：</strong></p><p>输入：<code>4</code></p><pre><code class="hljs awk">输出：[ [<span class="hljs-string">&quot;.Q..&quot;</span>,  <span class="hljs-regexp">//</span> 解法 <span class="hljs-number">1</span>  <span class="hljs-string">&quot;...Q&quot;</span>,  <span class="hljs-string">&quot;Q...&quot;</span>,  <span class="hljs-string">&quot;..Q.&quot;</span>],</code></pre><pre><code class="hljs awk"> [<span class="hljs-string">&quot;..Q.&quot;</span>,  <span class="hljs-regexp">//</span> 解法 <span class="hljs-number">2</span>  <span class="hljs-string">&quot;Q...&quot;</span>,  <span class="hljs-string">&quot;...Q&quot;</span>,  <span class="hljs-string">&quot;.Q..&quot;</span>]]</code></pre><p>解释: 4 皇后问题存在两个不同的解法。</p><p><strong>提示：</strong></p><ul><li>皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</li></ul><h2 id="解法1回溯"><a class="markdownIt-Anchor" href="#解法1回溯"></a> 解法1：回溯</h2><p>  对每个位置都进行尝试。</p><p>  <code>n</code> 行，每行从头开始遍历，对当前位置，判断这个位置是否满足皇后位置的要求，即横、纵、斜线上都没有其他皇后存在，因为我们是从头开始遍历的，因此，对当前位置只需要判断处于一条竖线的上方、处于左斜线的上方和处于右斜线的上方是否有皇后存在即可。若当前位置满足，则开始寻找下一行的皇后的位置。直到第 <code>n</code> 行找到最后一个皇后。</p><p>  如下图，假设遍历到 Q3 位置，它只需要判断三条蓝线的方向是否有皇后即可。</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201017101137969.png" alt="image-20201017101137969" style="zoom:80%;" /><pre><code class="hljs js"><span class="hljs-keyword">var</span> solveNQueens = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = [];    <span class="hljs-keyword">let</span> board = [];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        board[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n).fill(<span class="hljs-string">&#x27;.&#x27;</span>);    &#125;    <span class="hljs-keyword">const</span> deepCopy = <span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-keyword">let</span> arr = [];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            arr[i] = [];            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;                arr[i][j] = board[i][j];            &#125;        &#125;        <span class="hljs-keyword">return</span> arr;    &#125;;    <span class="hljs-keyword">const</span> dirs = [[<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>]];  <span class="hljs-comment">// 只需要查找 上方的、斜左上方的 和 斜右上方的 方向是否有 Q 即可</span>    <span class="hljs-keyword">const</span> helper = <span class="hljs-function">(<span class="hljs-params">row</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (row === n) &#123;            res.push(deepCopy());        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> dir <span class="hljs-keyword">of</span> dirs) &#123;                <span class="hljs-keyword">let</span> r = row + dir[<span class="hljs-number">0</span>], c = i + dir[<span class="hljs-number">1</span>];                <span class="hljs-keyword">while</span>(r &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; n &amp;&amp; c &gt;= <span class="hljs-number">0</span> &amp;&amp; c &lt; n) &#123;                    <span class="hljs-keyword">if</span> (board[r][c] === <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;                        flag = <span class="hljs-literal">false</span>;                        <span class="hljs-keyword">break</span>;                    &#125;                    r += dir[<span class="hljs-number">0</span>], c += dir[<span class="hljs-number">1</span>];                &#125;                <span class="hljs-keyword">if</span> (!flag) &#123;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;                        <span class="hljs-keyword">if</span> (flag) &#123;                board[row][i] = <span class="hljs-string">&#x27;Q&#x27;</span>;                helper(row+<span class="hljs-number">1</span>);                board[row][i] = <span class="hljs-string">&#x27;.&#x27;</span>;            &#125;        &#125;    &#125;;    helper(<span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; res.length; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;            res[i][j] = res[i][j].join(<span class="hljs-string">&#x27;&#x27;</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>解答</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 116. 填充每个节点的下一个右侧节点指针</title>
    <link href="/2020/10/15/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/"/>
    <url>/2020/10/15/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/</a></p><p>难度：中等</p><hr /><p>  给定一个<strong>完美二叉树</strong>，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span>  <span class="hljs-keyword">int</span> val;  Node *left;  Node *right;  Node *next;&#125;</code></pre><p>  填充它的每个 <code>next</code>指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 <code>next</code>指针设置为 <code>NULL</code>。</p><p>  初始状态下，所有 <code>next</code>指针都被设置为 <code>NULL</code>。</p><p><strong>示例：</strong></p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201015114937533.png" alt="image-20201015114937533" style="zoom:80%;" /><hr /><p>  首先，给定的树是一棵<strong>完美二叉树</strong>，因此对于所有非叶子节点的节点，都会有左右孩子。</p><h2 id="解法1层次优先遍历"><a class="markdownIt-Anchor" href="#解法1层次优先遍历"></a> 解法1：层次优先遍历</h2><p>  由于每个节点的 <code>next</code> 指针都是指向当前层次的右边节点，因此很容易想到使用层次优先遍历，且由于是完美二叉树，每层的节点个数也很容易计算出来（即都是 <code>2</code> 的倍数）。</p><p>  具体做法是使用一个队列，从右到左往队列中添加节点，这样，除了最右侧节点，其他节点在出队时将其 <code>next</code> 指向上一个出队节点即可。</p><p><strong>JS 代码如下：</strong></p><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * // Definition for a Node.</span><span class="hljs-comment"> * function Node(val, left, right, next) &#123;</span><span class="hljs-comment"> *    this.val = val === undefined ? null : val;</span><span class="hljs-comment"> *    this.left = left === undefined ? null : left;</span><span class="hljs-comment"> *    this.right = right === undefined ? null : right;</span><span class="hljs-comment"> *    this.next = next === undefined ? null : next;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Node&#125;</span> <span class="hljs-variable">root</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;Node&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> connect = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">if</span> (!root) &#123;        <span class="hljs-keyword">return</span> root;    &#125;    <span class="hljs-keyword">let</span> queue = [];    <span class="hljs-keyword">let</span> last, cur;    <span class="hljs-keyword">let</span> n = <span class="hljs-number">0</span>, nums = <span class="hljs-number">1</span>;    queue.push(root);    <span class="hljs-keyword">while</span> (queue.length) &#123;        cur = queue.shift();        n++;        <span class="hljs-keyword">if</span> (last) &#123;            cur.next = last;        &#125;        <span class="hljs-keyword">if</span> (cur.right) &#123;            queue.push(cur.right);        &#125;        <span class="hljs-keyword">if</span> (cur.left) &#123;            queue.push(cur.left);        &#125;        last = cur;        <span class="hljs-keyword">if</span> (n === nums) &#123;            nums *= <span class="hljs-number">2</span>;            n = <span class="hljs-number">0</span>;            last = <span class="hljs-literal">null</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> root;&#125;;</code></pre><h2 id="解法2使用父节点-next-指针"><a class="markdownIt-Anchor" href="#解法2使用父节点-next-指针"></a> 解法2：使用父节点 next 指针</h2><p>  首先，如下图，对于当前遍历到的节点 <code>2</code>，我们能够很容易的找到其左孩子的 <code>next</code> 指针所指向的节点（即其右孩子）：<code>root.left.next = root.right;</code></p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201015122151393.png" alt="image-20201015122151393" style="zoom: 67%;" /><p>  而对于其右孩子 <code>5</code>，由于我们在遍历根结点 <code>1</code> 时就设置了节点 <code>2</code> 的 <code>next</code> 指针，因此我们能够使用节点 <code>2</code> 的 <code>next</code> 来找到节点 <code>5</code> 的 <code>next</code> 所要指向的右侧节点：<code>root.right.next = root.next.left;</code></p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201015122450657.png" alt="image-20201015122450657" style="zoom: 67%;" /><p>  根据这种思路，我们能够写出递归版本和迭代版本的代码：</p><h3 id="递归"><a class="markdownIt-Anchor" href="#递归"></a> 递归</h3><p>  递归版本很直观，就是按照上面的两种情况来的：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> connect = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">if</span> (!root) &#123;        <span class="hljs-keyword">return</span> root;    &#125;        <span class="hljs-keyword">const</span> dfs = <span class="hljs-function">(<span class="hljs-params">root</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (!root) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (root.left) &#123;            root.left.next = root.right;<span class="hljs-comment">// 若当前节点不是最右侧节点，那么可以通过 next 指针找到其右侧节点</span>            <span class="hljs-keyword">if</span> (root.next) &#123;                root.right.next = root.next.left;            &#125;        &#125;        dfs(root.left);        dfs(root.right);    &#125;;    dfs(root);    <span class="hljs-keyword">return</span> root;&#125;;</code></pre><h3 id="迭代"><a class="markdownIt-Anchor" href="#迭代"></a> 迭代</h3><p>  对于迭代法，我们可以从每一层最左边的节点出发，对每一个遍历到的节点的左右孩子，按照上面的两种情况来获取 <code>next</code> 的指向：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201015143519577.png" alt="image-20201015143519577" style="zoom: 67%;" /><pre><code class="hljs js"><span class="hljs-keyword">var</span> connect = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">if</span> (!root) &#123;        <span class="hljs-keyword">return</span> root;    &#125;        <span class="hljs-keyword">let</span> leftSide = root;    <span class="hljs-keyword">while</span> (leftSide.left) &#123;        <span class="hljs-keyword">let</span> node = leftSide;        <span class="hljs-keyword">while</span> (node) &#123;            node.left.next = node.right;            <span class="hljs-keyword">if</span> (node.next) &#123;                node.right.next = node.next.left;            &#125;            node = node.next;        &#125;        leftSide = leftSide.left;    &#125;    <span class="hljs-keyword">return</span> root;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>解答</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.URL与资源</title>
    <link href="/2020/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/HTTP/2.URL%E4%B8%8E%E8%B5%84%E6%BA%90/"/>
    <url>/2020/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/HTTP/2.URL%E4%B8%8E%E8%B5%84%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<p>  <br /><strong>统一资源定位符</strong>（URL）描述了一台特定服务器上某资源的特定位置。</p><h1 id="1-url-语法"><a class="markdownIt-Anchor" href="#1-url-语法"></a> 1. URL 语法</h1><p>  大多数 URL 方案的 URL 语法都建立在这个由 9 个部分构成的通用格式上：</p><p><code>&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt;</code></p><p>  URL 最重要的三个部分是：<strong>方案（scheme）</strong>、<strong>主机（host）<strong>和</strong>路径（path）</strong>。下表对这些组件进行了总结：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200923105305698.png" alt="image-20200923105305698" style="zoom:80%;" /><p>  如一个 URL ：<code>http://www.joes-hardware.com:80/index.html</code>，其方案是 <code>http</code>，主机为 <code>www.joes-hardware.com</code>，端口是 <code>80</code>，路径为 <code>/index.html</code>。</p><h2 id="11-方案"><a class="markdownIt-Anchor" href="#11-方案"></a> 1.1 方案</h2><p>  方案是规定如何访问指定资源的主要标识符，它告诉负责解析 URL 的应用程序应该使用什么协议。</p><p><strong>方案是大小写无关的</strong></p><h2 id="12-参数"><a class="markdownIt-Anchor" href="#12-参数"></a> 1.2 参数</h2><p>  HTTP URL 的路径组件可以分为若干路径段，<strong>每段路径都可以有自己的参数</strong>，比如：</p><p><code>http://www.joes-hardware.com/hammers;sale=false/index.html/graphics=true</code></p><p>  这个例子就有两个路径段，且它们都有各自的参数。</p><h2 id="13-查询字符串"><a class="markdownIt-Anchor" href="#13-查询字符串"></a> 1.3 查询字符串</h2><p>  查询字符串是用来缩小所请求资源类型范围的。</p><p>  查询字符串会以一系列 <code>key/value</code> 对的形式出现，中间使用  <code>&amp;</code> 字符分隔。</p><p>  如：<code>http://www.xxx.com/inventory-check?item=12731&amp;color=blue</code></p><p>  这个例子中，查询组件有两个键值对：<code>item=12731</code> 和 <code>color=blue</code>，查询目的是为了查找清单中是否有颜色为 <code>blue</code> 的条目 <code>12731</code>。</p><h2 id="14-片段"><a class="markdownIt-Anchor" href="#14-片段"></a> 1.4  片段</h2><p>  片段主要用于对一个资源内部做进一步的划分。</p><p>  如，一个 URL 可以加上片段来指向一个文档中一个特定的章节或图片。</p><p>  片段挂载 URL 的右边，前面有一个 <code>#</code> 分隔，如：<code>http://www.xxx.com/tools.html#drills</code></p><p>  这个例子中 <code>drills</code> 是 <code>tools.index</code> 这个页面中的一个标题，输入这个 URL 就会自动定位到这个标题开始的位置。</p><p>  HTTP 处理的是整个对象（如 <code>tools.html</code>），而这个对象的片段（<code>#drills</code>）是交给浏览器来处理的。</p><h1 id="2-方案"><a class="markdownIt-Anchor" href="#2-方案"></a> 2. 方案</h1><p>  下表总结了一些常用的方案：</p><p>  <code>http</code> 默认端口为 <code>80</code> ，<code>https</code> 默认端口为 <code>443</code></p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201005153537876.png" alt="image-20201005153537876" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201005153643487.png" alt="image-20201005153643487" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201005153709444.png" alt="image-20201005153709444" style="zoom:80%;" />]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>URL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机中的浮点数表示</title>
    <link href="/2020/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E8%A1%A8%E7%A4%BA/"/>
    <url>/2020/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E8%A1%A8%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="ieee-754-标准"><a class="markdownIt-Anchor" href="#ieee-754-标准"></a> IEEE 754 标准</h1><p>  在这个标准中，任意一个二进制浮点数 <code>V</code> 可以表示成下面这样的形式：</p><p>  1. <code>(-1)^s</code> 表示符号位，当 <code>s = 0</code> 时， <code>V</code> 为正， <code>s = 1</code> 时，<code>V</code> 为负<br />  2. <code>M</code> 表示有效数字，<code>1 &lt;= M &lt; 2</code><br />  3. <code>E</code> 表示指数，如 <code>2^E</code></p><p>  举个例子，对于十进制的 <code>5.0</code>，写成<strong>二进制</strong>就是 <code>101.0</code>，相当于 <code>1.01 x 2^2</code>。</p><p>  按照上面的标准，可以得出： <code>s = 0</code>，<code>M = 1.01</code> ， <code>E = 2</code></p><p>  IEEE 754 规定，对于 <strong>32 位</strong>的浮点数，最高的 <code>1</code> 位是符号位 <code>s</code>，接着的 <code>8</code> 位是指数 <code>E</code>，剩下的 <code>23</code> 位为有效数字 <code>M</code>:</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/bg2010060601.png" alt="img"  /><p>  对于 <strong>64位</strong> 的浮点数，最高的 <code>1</code>位是符号位 <code>S</code> ，接着的 <code>11</code> 位是指数 <code>E</code>，剩下的 <code>52</code> 位为有效数字 <code>M</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/bg2010060602.png" alt="img" /></p><p>  在 IEEE 754 标准中，对 <code>M</code> 和 <code>E</code> 还有一些特别的规定，用于应对一些极端情况。</p><p>  <strong>对于<code>M</code></strong>,前面有提到， <code>1 &lt;= M &lt; 2</code>，也就是说， <code>M</code> 可以写成 <code>1.xxxx</code> 的形式，其中 <code>xxxx</code> 表示小数部分。既然我们知道<strong>计算机在保存 <code>M</code> 时第一位默认总是 <code>1</code></strong>,那么我们可以先省略这个数，只保存 <code>xxxx</code> 这样的小数部分，然后在最后的结果前再加上 <code>1</code>，这样，我们就能多出一位来保存小数 <code>xxxx</code> 了。IEEE 754 中就是这样规定的。</p><p>  <strong>对于<code>E</code></strong>,情况会复杂些：</p><p>  首先，<code>E</code> 是一个无符号整数，若 <code>E</code> 为 <code>8</code> 位，它的取值范围就是 <code>0 - 255</code>，若 <code>E</code> 为 <code>11</code> 位，它的取值范围就是 <code>0 - 2047</code>，但是，在科学计数法中，指数位 <code>E</code> 是能取负值的，因此 IEEE 754 中规定,<strong><code>E</code> 的真实值需要再减去一个中间数</strong>,相当于是一个偏置（bias），<strong>对于 <code>8</code> 位的 <code>E</code>，这个偏置是 <code>127</code>，对于 <code>11</code> 位的 <code>E</code>，这个偏置是 <code>1023</code>。</strong></p><p>  比如，<code>2^10</code> 的 <code>E</code> 是 <code>10</code>，因此在保存为 <code>32</code> 位浮点数时，需要保存为 <code>10 + 127 = 137</code>，即 <code>10001001</code>（因为 <code>E</code> 在变成 <code>10</code> 之前，减去了一个偏置 <code>127</code>）</p><p>  <code>E</code> 还能分成三种情况讨论：</p><ol><li><p><strong>规格化：当 <code>E</code> 的二进制位不全为 <code>0</code>,也不全为 <code>1</code> 时，二进制浮点数 <code>V</code> 为规格化形式。</strong></p><p>这时 <code>E</code> 的计算就按上面的规则，减去 <code>127</code> 或 <code>1023</code>。如 <code>E</code> 为 <code>10000100</code>，则 <code>E = 132</code> ，<code>E</code> 的真实值 <code>e = 132 - 127 = 5</code> 。</p><p><code>M</code> 也是如之前所述，在左侧加上隐含位 <code>1</code>，也就是  <code>1.M</code>  ，如 <code>M</code> 为 <code>1010...0</code>（ <code>101</code> 后面共 20 个 0），则 <code>1.M = 1.101 = 1.625</code></p></li><li><p><strong>非规格化：当 <code>E</code> 的二进制位全部为 <code>0</code> 时，<code>V</code> 为非规格化形式。</strong></p><p>这时，<code>E</code> 的计算就是 <code>1 - 127</code> （或 <code>1 - 1023</code>），这样做的目的主要是为了规格化数值和非规格化数值之间的平滑过渡。并且，有效数字 <code>M</code> 不再加上第一位的 <code>1</code>，而是按原样输出：<code>0.xxxx</code>。这样，我们就能表示 <code>±0</code> （具体看符号位 <code>s</code>）和一些非常逼近 <code>0</code> 的小数了。</p></li><li><p><strong>特殊数值： 当E的二进制位全为 <code>1</code> 时为特殊数值。</strong></p><p>此时，若 <code>M</code> 的二进制位全为 <code>0</code> 则表示 <code>±无穷大</code>（具体看符号位 <code>s</code>），而若 <code>M</code> 的二进制位不全为 <code>0</code>  的话，则表示 <code>NaN</code>（Not a Number），表示这不是一个合法实数或者该数未经初始化。</p></li></ol><h1 id="浮点数例子"><a class="markdownIt-Anchor" href="#浮点数例子"></a> 浮点数例子</h1><p>  有一段 C 代码是这样的：</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> a = <span class="hljs-number">9</span>;<span class="hljs-keyword">float</span>* pFloat = (<span class="hljs-keyword">float</span>*)&amp;a;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\n&quot;</span>, a);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, a);*pFloat = <span class="hljs-number">9.0</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\n&quot;</span>, *pFloat);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, a);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>  程序的打印结果：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20201005230741731.png" alt="image-20201005230741731" style="zoom:80%;" /><p>  在上面的代码中，我们先申明了一个整型 <code>a = 9</code>，然后申明了一个浮点指针 <code>pFloat</code> 指向 <code>a</code> 的地址。</p><p>  <strong>1）</strong> 使用浮点数格式打印 <code>a</code> 时，发现为 <code>0.000000</code>；</p><p>  <strong>2）</strong> 然后我们根据 <code>a</code> 的地址 <code>pFloat</code> 修改它的值为 <code>9.0</code>，此时再以整型来打印 <code>a</code>，输出的却是 <code>1091567616</code>。</p><p>  <strong>首先来看 <code>1)</code></strong> ，为什么整型的 <code>9</code> 以浮点格式输出时打印出来的是 <code>0.000000</code>。</p><p>  将 32 位的整型 <code>9</code> 转化为二进制形式，得到： <code>0 0000 0000 000 0000 0000 0000 0000 1001</code></p><p>  根据前面的知识，可以知道 <code>s = 0</code>，<code>E = 0</code>，<code>M = 0...1001</code>，指数 <code>E</code> 的二进制位全为 <code>0</code>，因此是第二种非规格化的情况，因此浮点数 <code>V</code> 就写成：</p><p><code>V = (-1)^0 x 0.00000000000000000001001 x 2^(-126) = 1.001 x 2^(-146)</code></p><p>  显然，<code>V</code> 是一个非常小的接近 <code>0</code> 的数，因此用十进制小数表示就是 <code>0.000000</code>。</p><p>  <strong>再来看看 <code>2)</code></strong> ，为什么内存中的 <code>9</code> 变成 <code>9.0</code> 后，以整型格式打印，结果会是 <code>1091567616</code>。</p><p>  将浮点数 <code>9.0</code> 转换为二进制小数形式：<code>1001.0</code> 即 <code>1.001 x 2^3</code> ，那么，我们可以知道 <code>s = 0</code>，<code>E = 3 + 127 = 130</code>，二进制表示的话就是 <code>10000010</code> ，<code>M = 100 1000 0000 0000 0000 0000</code>  ，因此，<code>9.0</code> 的二进制形式表示就是：<code>s + E + M</code> ，也就是：<code>0 1000 0010 100 1000 0000 0000 0000 0000</code> ，这个 32 位的二进制，用十进制表示就是：<code>1,091,567,616</code></p><h1 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h1><p>  <strong>很多小数不能准确表示成二进制形式</strong>。比如 <code>0.4</code>，你就无法写出它的精确二进制形式（即 <code>0.5</code>的各次幂的累加），我们只能不断接近 <code>0.4</code>，而不能达到它。</p><p>  因为 <code>0.4</code> 的二进制表示是：<code>0.01100110011....</code> 无限循环，因此我们只能逼近而不能精确表示。</p><hr /><p>REF：</p><ul><li><p><a href="https://ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html">https://ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html</a></p></li><li><p><a href="https://blog.csdn.net/linven1911/article/details/2596038">https://blog.csdn.net/linven1911/article/details/2596038</a></p></li><li><p><a href="https://www.zhoulujun.cn/html/theory/ComputerScienceTechnology/Constitution/2016_0714_7860.html">https://www.zhoulujun.cn/html/theory/ComputerScienceTechnology/Constitution/2016_0714_7860.html</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浮点数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 406. 根据身高重建队列</title>
    <link href="/2020/10/04/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/406-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/"/>
    <url>/2020/10/04/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/406-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">https://leetcode-cn.com/problems/queue-reconstruction-by-height/</a></p><p>难度：中等</p><hr /><p>  假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对<code>(h, k)</code>表示，其中h是这个人的身高，<code>k</code>是排在这个人前面且身高大于或等于<code>h</code>的人数。 编写一个算法来重建这个队列。</p><p><strong>注意：</strong></p><p>  总人数少于<code>1100</code>人。</p><p><strong>示例</strong></p><p>输入: <code>[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]</code></p><p>输出: <code>[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]</code></p><hr /><h2 id="解法1排序调整"><a class="markdownIt-Anchor" href="#解法1排序调整"></a> 解法1：排序+调整</h2><p>  通过观察，我们可以知道，对于一组数据，如示例中的 <code>(7,0)</code> 和 <code>(7,1)</code>，无论它们所处的位置在哪，在最终结果中，它们的相对位置是不会发生变化的：<code>(7,1)</code> 一定会在 <code>(7,0)</code> 的后面，可能中间隔了一个、可能隔了 <code>n</code> 个。</p><p>  因此，我们可以先对这组数据排序，先保证它们的相对位置，具体做法是根据 <code>(h, k)</code> 来排序：我们先按 <code>h</code> 从大到小进行排序，这样保证了对于每一个数 <code>i</code>，它前面的数字都不会小于自身，然后对于 <code>h</code> 相同的数字，按 <code>k</code> 从小到大排序，这样，对于 <code>h</code> 相同的数据，它们的相对位置开始就是正确的。</p><p>  之后，遍历这组排序过的数据，我们使用 <code>tuple</code> 来表示一个 <code>(h, k)</code> 对，遍历过程中，数组索引 <code>i</code> 能够表示不小于当前 <code>tuple</code> 的所有 <code>tuple</code> 的个数（因为我们提前按 <code>h</code> 进行排序了），这样，我们只要根据每个 <code>tuple</code> 的 <code>k</code> 来进行调整即可。</p><p>  具体调整方法是：对于当前的 <code>tuple</code> ，若 <code>k &lt; i</code> ，说明在当前 <code>tuple</code> 前面的位置，比它高的 <code>tuple</code> 个数太多了，需要将这个 <code>tuple</code> 向前调整 <code>i-k</code> 个位置，让其前面的 <code>tuple</code> 个数刚好等于 <code>k</code>，也就是移动到第 <code>k</code> 个位置。且这样调整并不会影响到已调整的序列，因为那些数据的相对位置并不会发生改变。</p><p><strong>JS 代码：</strong></p><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">people</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> reconstructQueue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">people</span>) </span>&#123;    <span class="hljs-keyword">if</span> (people.length &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> people;    &#125;    <span class="hljs-keyword">let</span> res = [];        <span class="hljs-comment">// 先根据 h 和 k 排序，主 h 副 k , h 从大到小排序，k 从小到大排序</span>    people.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] === b[<span class="hljs-number">0</span>]) &#123;            <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>];        &#125;        <span class="hljs-keyword">return</span> b[<span class="hljs-number">0</span>] - a[<span class="hljs-number">0</span>];    &#125;);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; people.length; i++) &#123;        <span class="hljs-keyword">let</span> k = people[i][<span class="hljs-number">1</span>];        <span class="hljs-keyword">if</span> (k &lt; i) &#123;            res.splice(k, <span class="hljs-number">0</span>, people[i]);        &#125; <span class="hljs-keyword">else</span> &#123;            res[i] = people[i];        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;;</code></pre><h2 id="解法2逐个插入-调整"><a class="markdownIt-Anchor" href="#解法2逐个插入-调整"></a> 解法2：逐个插入、调整</h2><p><strong>（第 27/37 个 case 会超时）</strong></p><p>  主要思路是先找到序列的第一个 <code>tuple</code> ，然后根据每个 <code>tuple</code> 的 <code>h</code> 和 <code>k</code> 找到插入的位置，所有数据都插入完成之后，有些 <code>tuple</code> 会因为插入操作而导致站位错误，因此需要逐个检查判断是否站错，若站错，则将这个 <code>tuple</code> 重新插入，反复执行此操作，直到所有数据都满足站位要求：</p><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">people</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> reconstructQueue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">people</span>) </span>&#123;    <span class="hljs-keyword">if</span> (people.length &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> people;    &#125;    <span class="hljs-keyword">let</span> res = [];    <span class="hljs-keyword">let</span> n = people.length;    <span class="hljs-keyword">let</span> first;    <span class="hljs-keyword">let</span> tuple, k, height, insertIndex;        <span class="hljs-comment">// 先进行第一次排序</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        tuple = people[i];        k = tuple[<span class="hljs-number">1</span>];        height = tuple[<span class="hljs-number">0</span>];        insertIndex = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (k === <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">while</span>(insertIndex &lt; res.length &amp;&amp; res[insertIndex][<span class="hljs-number">0</span>] &lt; height) &#123;                insertIndex++;            &#125;            res.splice(insertIndex, <span class="hljs-number">0</span>, tuple);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">while</span>(insertIndex &lt; res.length &amp;&amp; k &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">if</span> (res[insertIndex++][<span class="hljs-number">0</span>] &gt;= height) &#123;                    k--;                &#125;            &#125;            res.splice(insertIndex, <span class="hljs-number">0</span>, tuple);        &#125;    &#125;    <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span>;    <span class="hljs-keyword">while</span>(flag) &#123;        flag = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            tuple = res[i];            k = tuple[<span class="hljs-number">1</span>];            height = tuple[<span class="hljs-number">0</span>];            <span class="hljs-keyword">if</span> (k !== <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">// 遍历当前 tuple 前面的人，看是否满足 k 的要求</span>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;                    <span class="hljs-keyword">let</span> tuple1 = res[j];                    <span class="hljs-keyword">if</span> (tuple1[<span class="hljs-number">0</span>] &gt;= height) &#123;                        k--;                    &#125;                &#125;                <span class="hljs-keyword">if</span> (k !== <span class="hljs-number">0</span>) &#123;                    k = tuple[<span class="hljs-number">1</span>]; <span class="hljs-comment">// k 要重新赋值，用于下面的重新插入</span>                    res.splice(i, <span class="hljs-number">1</span>); <span class="hljs-comment">// 将错误的 tuple 从结果中移除</span>                    flag = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 需要再次判断</span>                    <span class="hljs-keyword">break</span>;                &#125;            &#125;        &#125;        <span class="hljs-comment">// 若存在错误的站位，则重新插入，且 k 、height 和 tuple 可以就使用之前的</span>        <span class="hljs-keyword">if</span> (flag) &#123;            insertIndex = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span>(insertIndex &lt; n<span class="hljs-number">-1</span> &amp;&amp; k &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">if</span> (res[insertIndex++][<span class="hljs-number">0</span>] &gt;= height) &#123;                    k--;                &#125;            &#125;            res.splice(insertIndex, <span class="hljs-number">0</span>, tuple);        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>解答</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 145. 二叉树的后序遍历</title>
    <link href="/2020/09/30/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2020/09/30/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<p>  给定一个二叉树，返回它的 <strong>后序</strong> 遍历。</p><p><strong>示例:</strong></p><p>输入: <code>[1,null,2,3]</code></p><pre><code class="hljs angelscript"><span class="hljs-number">1</span> \  <span class="hljs-number">2</span> /<span class="hljs-number">3</span></code></pre><p>输出: <code>[3,2,1]</code></p><p><strong>进阶</strong>: 递归算法很简单，你可以通过迭代算法完成吗？</p><h2 id="解法1借助栈进行后序非递归遍历"><a class="markdownIt-Anchor" href="#解法1借助栈进行后序非递归遍历"></a> 解法1：借助栈进行后序非递归遍历</h2><p>  后序非递归遍历的<strong>关键点</strong>在于判断遍历过程中什么时候该往右走，什么时候该访问节点内容。</p><p>  我们使用一个栈来保存遍历路径上的节点，步骤如下：</p><ol><li>一直往左孩子遍历，遍历过程中保存遍历的节点</li><li>当左孩子为空时，我们访问右孩子</li><li>当左右孩子都为空时，我们访问这个节点内容，并返回到父节点</li><li>每当从孩子节点返回父节点时，需要判断是从左孩子返回的还是从右孩子返回的，若是从左孩子返回的，我们需要继续访问右孩子，而若是从右孩子返回的，我们则访问当前节点，并返回到其父节点。</li></ol><p>  判断一次返回是否是从右孩子返回，我们可以使用一个变量 <code>t</code>，当一个节点返回时，我们使用 <code>t</code> 记录这个节点，在父节点处判断 <code>t</code> 是否与这个节点的右孩子相等，若相等，则说明是从右孩子返回的，否则就是从左孩子返回的。</p><p><strong>C 代码：</strong></p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(struct TreeNode* root, <span class="hljs-keyword">int</span>* returnSize)</span></span>&#123;    <span class="hljs-keyword">int</span>* res = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * <span class="hljs-number">2001</span>);    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>** <span class="hljs-title">stack</span> = <span class="hljs-title">malloc</span>(<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">TreeNode</span>*) * 2001);</span>    <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;    *returnSize = <span class="hljs-number">0</span>;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">r</span>;</span> <span class="hljs-comment">// r 为辅助节点，用于判断当节点返回时，是从哪个方向返回到父节点的。</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">p</span> = <span class="hljs-title">root</span>;</span>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span> || size &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// 先从左走到底</span>        <span class="hljs-keyword">if</span> (p) &#123;            <span class="hljs-built_in">stack</span>[size++] = p;            p = p-&gt;left;        &#125; <span class="hljs-keyword">else</span> &#123;            p = <span class="hljs-built_in">stack</span>[size<span class="hljs-number">-1</span>];            <span class="hljs-comment">// 若右孩子还未遍历，遍历右孩子</span>            <span class="hljs-keyword">if</span> (p-&gt;right &amp;&amp; p-&gt;right != r) &#123;                p = p-&gt;right;            &#125; <span class="hljs-keyword">else</span> &#123;                p = <span class="hljs-built_in">stack</span>[--size];                res[(*returnSize)++] = p-&gt;val;                r = p;                p = <span class="hljs-literal">NULL</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h2 id="解法2morris-算法"><a class="markdownIt-Anchor" href="#解法2morris-算法"></a> 解法2：morris 算法</h2><p>  Morris 算法对于三种顺序（前、中、后）的遍历，<strong>主要区分点在于访问节点的时机</strong> 。</p><p>  Morris 算法的步骤可看：<a href="https://yleave.top/2020/09/24/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/Morris%E7%AE%97%E6%B3%95/">Morris 算法</a></p><p>  根据 Morris 算法的思想，<strong>对于每个节点，当它是借助左子树的最右下结点的空指针返回的时候，我们就倒序输出从当前节点到其左子树最右下节点的路径</strong>，就能得到后续遍历的结果了（想不通的一定要手动模拟一下 morris 算法），最后，在 morris 算法结束后，需要加上从根结点到其右子树最右节点的逆序路径，因为 morris 算法在遍历完成后不会再回到根结点。</p><p><strong>JS 代码：</strong></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> postorderTraversal = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = [];    <span class="hljs-keyword">let</span> len = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (!root) &#123;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-keyword">let</span> pre, tmp = root;    <span class="hljs-comment">// 对每个新添加的路径逆序排列</span>    <span class="hljs-keyword">const</span> addPath = <span class="hljs-function">(<span class="hljs-params">root</span>) =&gt;</span> &#123;        <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(root) &#123;            res[len++] = root.val;            root = root.right;            count++;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = len-count, j = len<span class="hljs-number">-1</span>; i &lt; j; i++, j--) &#123;            <span class="hljs-keyword">let</span> tmp = res[i];            res[i] = res[j];            res[j] = tmp;        &#125;    &#125;;    <span class="hljs-keyword">while</span>(root) &#123;        <span class="hljs-keyword">if</span> (root.left) &#123;            pre = root.left;            <span class="hljs-keyword">while</span>(pre.right &amp;&amp; pre.right !== root) &#123;                pre = pre.right;            &#125;            <span class="hljs-keyword">if</span> (!pre.right) &#123;                pre.right = root;                root = root.left;            &#125; <span class="hljs-keyword">else</span> &#123;                pre.right = <span class="hljs-literal">null</span>;                addPath(root.left);                root = root.right;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            root = root.right;        &#125;    &#125;    addPath(tmp);    <span class="hljs-keyword">return</span> res;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>解答</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>后序遍历</tag>
      
      <tag>morris</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>后序非递归遍历</title>
    <link href="/2020/09/30/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/%E5%90%8E%E5%BA%8F%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86/"/>
    <url>/2020/09/30/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/%E5%90%8E%E5%BA%8F%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<p>  对树进行后序非递归遍历一般会借助栈来保存路径上的节点。</p><p>  后序非递归遍历的一个<strong>特点</strong>就是：当访问到一个节点时，栈中所保存的节点正好是这个节点的所有祖先节点，因此后续非递归遍历可用来解决以下问题：</p><ol><li><strong>当给定一个节点时，输出该节点的所有祖先</strong></li><li><strong>输出根结点到叶子节点的所有路径</strong></li><li><strong>求每条路径上的节点值之和</strong></li></ol><p>  后序非递归遍历的<strong>关键点</strong>在于判断遍历过程中什么时候该往右走，什么时候该访问节点内容。</p><p>  我们使用一个栈来保存遍历路径上的节点，步骤如下：</p><ol><li>一直往左孩子遍历，遍历过程中保存遍历的节点</li><li>当左孩子为空时，我们访问右孩子</li><li>当左右孩子都为空时，我们访问这个节点内容，并返回到父节点</li><li>每当从孩子节点返回父节点时，需要判断是从左孩子返回的还是从右孩子返回的，若是从左孩子返回的，我们需要继续访问右孩子，而若是从右孩子返回的，我们则访问当前节点，并返回到其父节点。</li></ol><p>  判断一次返回是否是从右孩子返回，我们可以使用一个变量 <code>t</code>，当一个节点返回时，我们使用 <code>t</code> 记录这个节点，在父节点处判断 <code>t</code> 是否与这个节点的右孩子相等，若相等，则说明是从右孩子返回的，否则就是从左孩子返回的。</p><p><strong>C 代码：</strong></p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(struct TreeNode* root, <span class="hljs-keyword">int</span>* returnSize)</span></span>&#123;    <span class="hljs-keyword">int</span>* res = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * <span class="hljs-number">2001</span>);    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>** <span class="hljs-title">stack</span> = <span class="hljs-title">malloc</span>(<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">TreeNode</span>*) * 2001);</span>    <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;    *returnSize = <span class="hljs-number">0</span>;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">r</span>;</span> <span class="hljs-comment">// r 为辅助节点，用于判断当节点返回时，是从哪个方向返回到父节点的。</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">p</span> = <span class="hljs-title">root</span>;</span>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span> || size &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// 先从左走到底</span>        <span class="hljs-keyword">if</span> (p) &#123;            <span class="hljs-built_in">stack</span>[size++] = p;            p = p-&gt;left;        &#125; <span class="hljs-keyword">else</span> &#123;            p = <span class="hljs-built_in">stack</span>[size<span class="hljs-number">-1</span>];            <span class="hljs-comment">// 若右孩子还未遍历，遍历右孩子</span>            <span class="hljs-keyword">if</span> (p-&gt;right &amp;&amp; p-&gt;right != r) &#123;                p = p-&gt;right;            &#125; <span class="hljs-keyword">else</span> &#123;                p = <span class="hljs-built_in">stack</span>[--size];                res[(*returnSize)++] = p-&gt;val;                r = p;                p = <span class="hljs-literal">NULL</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h2 id="morris-算法遍历节点值"><a class="markdownIt-Anchor" href="#morris-算法遍历节点值"></a> morris 算法遍历节点值</h2><p>  若需要使用非递归算法后序遍历节点值，那么可使用 morris 算法实现 <code>O(1)</code> 复杂度的遍历。</p><p>具体可看：<a href="https://yleave.top/2020/09/30/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/#%E8%A7%A3%E6%B3%952%EF%BC%9Amorris-%E7%AE%97%E6%B3%95">使用Morris算法进行后序非递归遍历</a></p>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>算法知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后序非递归遍历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 501. 二叉搜索树中的众数</title>
    <link href="/2020/09/24/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/501-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0/"/>
    <url>/2020/09/24/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/501-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/">https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/</a></p><p>难度：简单</p><hr /><p>  给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p><p>假定 BST 有如下定义：</p><ul><li><p>结点左子树中所含结点的值小于等于当前结点的值</p></li><li><p>结点右子树中所含结点的值大于等于当前结点的值</p></li><li><p>左子树和右子树都是二叉搜索树</p></li></ul><p><strong>例如：</strong></p><p>  给定 BST <code>[1,null,2,2]</code>,</p><pre><code class="hljs angelscript"><span class="hljs-number">1</span> \  <span class="hljs-number">2</span> /<span class="hljs-number">2</span></code></pre><p>  返回 <code>[2]</code></p><p><strong>提示</strong>：如果众数超过1个，不需考虑输出顺序</p><p><strong>进阶：</strong> 你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p><hr /><h2 id="解法1中序遍历"><a class="markdownIt-Anchor" href="#解法1中序遍历"></a> 解法1：中序遍历</h2><p>  对于一棵二叉搜索树，若对其进行中序遍历并在遍历过程中顺序记录节点值，那么记录的值会是一个单调递增序列（在本题中是单调不减序列）。</p><p>  这样的话，若要求众数，我们可以先对其进行中序遍历，众数在序列中的位置一定是连续的，如 <code>[1, 2, 2, 2, 3]</code>。这样，我们对这个序列进行遍历并计数，就能够得到它的众数。</p><p>  不过，为了避免使用额外空间，我们可以在遍历过程中就求出众数，具体做法是维护一个 <code>max</code> ，表示当前所遇到的最多的连续数字的个数，然后在遍历过程中累计每个数字出现的次数，若比 <code>max</code> 大，则使用当前数字覆盖结果数组，并更新 <code>max</code> 值。</p><p>  在中序遍历完成之后，我们还需要最后进行一次众数判断，因为最后的连续数字不会在遍历过程中判断是否是众数。</p><p><strong>JS 代码：</strong></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> findMode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = [];    <span class="hljs-keyword">if</span> (!root) &#123;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-keyword">let</span> n;    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> max = <span class="hljs-number">-1</span>;    <span class="hljs-keyword">const</span> dfs = <span class="hljs-function">(<span class="hljs-params">node</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (!node) &#123;            <span class="hljs-keyword">return</span>;        &#125;        dfs(node.left);                <span class="hljs-keyword">if</span> (n === <span class="hljs-literal">undefined</span>) &#123;            n = node.val;            count = <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n === node.val) &#123;            count++;        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 遇到新的数字</span>            <span class="hljs-keyword">if</span> (count &gt; max) &#123;                max = count;                res = [n];            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count === max) &#123;                res.push(n);            &#125;            n = node.val;            count = <span class="hljs-number">1</span>;        &#125;            dfs(node.right);    &#125;;    dfs(root);    <span class="hljs-keyword">if</span> (count &gt; max) &#123;        max = count;        res = [n];    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count === max) &#123;        res.push(n);    &#125;    <span class="hljs-keyword">return</span> res;&#125;;</code></pre><p>C 版本：</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> max;<span class="hljs-keyword">int</span> count;<span class="hljs-keyword">int</span> cur;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(struct TreeNode* root, <span class="hljs-keyword">int</span>* res, <span class="hljs-keyword">int</span>* returnSize)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!root) &#123;        <span class="hljs-keyword">return</span>;    &#125;    dfs(root-&gt;left, res, returnSize);        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">-1</span>) &#123;        cur = root-&gt;val;        count = <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur == root-&gt;val) &#123;        count++;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">if</span> (max &lt; count) &#123;            max = count;            *returnSize = <span class="hljs-number">0</span>;            res[(*returnSize)++] = cur;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (max == count) &#123;            res[(*returnSize)++] = cur;        &#125;        cur = root-&gt;val;        count = <span class="hljs-number">1</span>;    &#125;    dfs(root-&gt;right, res, returnSize);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">findMode</span><span class="hljs-params">(struct TreeNode* root, <span class="hljs-keyword">int</span>* returnSize)</span></span>&#123;    *returnSize = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> *res = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * <span class="hljs-number">4001</span>);    count = <span class="hljs-number">-1</span>;    max = <span class="hljs-number">-1</span>;    <span class="hljs-keyword">if</span> (!root) &#123;        <span class="hljs-keyword">return</span> res;    &#125;    dfs(root, res, returnSize);    <span class="hljs-keyword">if</span> (max &lt; count) &#123;        max = count;        *returnSize = <span class="hljs-number">0</span>;        res[(*returnSize)++] = cur;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (max == count) &#123;        res[(*returnSize)++] = cur;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h2 id="解法2morris-算法"><a class="markdownIt-Anchor" href="#解法2morris-算法"></a> 解法2：Morris 算法</h2><p>  所有能使用中序遍历解决的问题都能使用 Morris 算法来优化其空间复杂度。</p><p>  <a href="https://yleave.top/2020/09/24/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/Morris%E7%AE%97%E6%B3%95/">Morris 算法详情可看</a></p><p>  在使用 Morris 算法时最重要的是要把握好节点遍历的时机。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> findMode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = [];    <span class="hljs-keyword">if</span> (!root) &#123;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-keyword">let</span> n;    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> max = <span class="hljs-number">-1</span>;    <span class="hljs-keyword">let</span> pre;    <span class="hljs-keyword">const</span> check = <span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (max &lt; count) &#123;            max = count;            res = [n];        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (max === count) &#123;            res.push(n);        &#125;    &#125;;    <span class="hljs-keyword">while</span> (root) &#123;        <span class="hljs-keyword">if</span> (root.left) &#123;            pre = root.left;            <span class="hljs-keyword">while</span> (pre.right &amp;&amp; pre.right !== root) &#123;                pre = pre.right;            &#125;            <span class="hljs-keyword">if</span> (!pre.right) &#123;                pre.right = root;                root = root.left;            &#125; <span class="hljs-keyword">else</span> &#123;                 <span class="hljs-comment">// 此时是刚从左孩子节点返回之后，往右孩子遍历</span>                <span class="hljs-keyword">if</span> (n === <span class="hljs-literal">undefined</span>) &#123;                    n = root.val;                    count = <span class="hljs-number">1</span>;                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n === root.val) &#123;                    count++;                &#125; <span class="hljs-keyword">else</span> &#123;                    check();                    n = root.val;                    count = <span class="hljs-number">1</span>;                &#125;                pre.right = <span class="hljs-literal">null</span>;                root = root.right;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;           <span class="hljs-comment">// 节点此时可能是借助前面设置的空闲指针返回父节点，也可能是从父节点到右节点遍历的过程</span>            <span class="hljs-keyword">if</span> (n === <span class="hljs-literal">undefined</span>) &#123;                n = root.val;                count = <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n === root.val) &#123;                count++;            &#125; <span class="hljs-keyword">else</span> &#123;                check();                n = root.val;                count = <span class="hljs-number">1</span>;            &#125;            root = root.right;        &#125;    &#125;    check();    <span class="hljs-keyword">return</span> res;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>解答</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中序遍历</tag>
      
      <tag>LeetCode</tag>
      
      <tag>二叉搜索树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Morris算法</title>
    <link href="/2020/09/24/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/Morris%E7%AE%97%E6%B3%95/"/>
    <url>/2020/09/24/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/Morris%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="morris-算法介绍"><a class="markdownIt-Anchor" href="#morris-算法介绍"></a> Morris 算法介绍</h1><p>  Morris 算法是一种巧妙的方法可以在<strong>线性时间</strong>内，只占用<strong>常数空间</strong>来实现树的遍历。这种方法由 J. H. Morris 在 1979 年的论文「Traversing Binary Trees Simply and Cheaply」中首次提出，因此被称为 Morris 遍历。</p><p>  Morris 算法一般用在解决中序遍历的问题，不过稍微修改一下，它也能用在前序遍历和<a href="https://yleave.top/2020/09/30/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/#%E8%A7%A3%E6%B3%952morris-%E7%AE%97%E6%B3%95">后序遍历</a>上。</p><p>  正常的中序遍历算法，无论是递归还是迭代，都需要使用到栈来保存节点，因此空间复杂度一般和树的节点数有关，而 Morris 算法是使用了树中子结点的空闲的指针来完成遍历过程。具体是通过底层节点指向<code>NULL</code>的空闲指针返回上层的某个节点，从而完成下层到上层的移动。</p><p><strong>Morris 遍历算法</strong>整体步骤如下（假设当前遍历到的节点为 <code>x</code>）：</p><ol><li>如果 <code>x</code> 无左孩子，则访问 <code>x</code> 的右孩子，即 <code>x = x.right</code></li><li>如果 <code>x</code> 有左孩子，则<strong>找到 <code>x</code> 左子树上最右的节点</strong>（即左子树中序遍历的最后一个节点，是 <code>x</code> 在中序遍历中的前驱节点），记为 <code>predecessor</code> 。<ul><li>如果 <code>predecessor</code> 的右孩子为空，则将其右孩子指向 <code>x</code>，然后访问 <code>x</code> 的左孩子，即 <code>x = x.left</code></li><li>如果 <code>predecessor</code> 的右孩子不为空，则此时右孩子是指向 <code>x</code> 的，说明我们已经遍历完了左孩子；这时将 <code>predecessor</code> 的右孩子置空，然后访问 <code>x</code> 的右孩子，即 <code>x = x.right</code></li></ul></li><li>重复上述步骤，直到访问完整棵树，即 <code>x = null</code> 时。</li></ol><p>  (没搞清楚的话可以自己模拟一个简单的二叉树试试)</p><p>  感觉这个有点像是线索二叉树，不过这边的线索只是帮助遍历二叉树，用完一次就会清除。</p><p><strong>下面是 Morris 中序遍历算法的模板：</strong></p><p><strong>JS 版本：</strong></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> inOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">let</span> predecessor;    <span class="hljs-keyword">while</span>(root) &#123;        <span class="hljs-keyword">if</span> (root.left) &#123;            <span class="hljs-keyword">let</span> predecessor = root.left;            <span class="hljs-comment">// 找到左子树的最右节点</span>            <span class="hljs-keyword">while</span>(predecessor.right &amp;&amp; predecessor.right !== root) &#123;                predecessor = predecessor.right;            &#125;            <span class="hljs-comment">// 若右孩子为空，表示第一次遍历到这个节点，将其右孩子设为root</span>            <span class="hljs-keyword">if</span> (!predecessor.right) &#123;                predecessor.right = root;                root = root.left;            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 否则， root 的左子树已经遍历完了，这时相当于中序遍历从左子树回到父节点</span>                <span class="hljs-comment">// 此时是刚从左孩子节点返回之后，往右孩子遍历</span>                root = root.right;                predecessor.right = <span class="hljs-literal">null</span>;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 节点此时可能是借助前面设置的空闲指针返回父节点，也可能是从父节点到右节点遍历的过程</span>            root = root.right;        &#125;    &#125;&#125;;</code></pre><p><strong>C++ 版本：</strong></p><pre><code class="hljs c++">TreeNode *cur = root, *pre = <span class="hljs-literal">nullptr</span>;<span class="hljs-keyword">while</span> (cur) &#123;    <span class="hljs-keyword">if</span> (!cur-&gt;left) &#123;        <span class="hljs-comment">// ...遍历 cur</span>        cur = cur-&gt;right;        <span class="hljs-keyword">continue</span>;    &#125;    pre = cur-&gt;left;    <span class="hljs-keyword">while</span> (pre-&gt;right &amp;&amp; pre-&gt;right != cur) &#123;        pre = pre-&gt;right;    &#125;    <span class="hljs-keyword">if</span> (!pre-&gt;right) &#123;        pre-&gt;right = cur;        cur = cur-&gt;left;    &#125; <span class="hljs-keyword">else</span> &#123;        pre-&gt;right = <span class="hljs-literal">nullptr</span>;        <span class="hljs-comment">// ...遍历 cur</span>        cur = cur-&gt;right;    &#125;&#125;</code></pre><h1 id="morris-算法实际应用"><a class="markdownIt-Anchor" href="#morris-算法实际应用"></a> Morris 算法实际应用</h1><p><a href="https://yleave.top/2020/09/24/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/501-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0/">LeetCode 501. 二叉搜索树中的众数</a></p>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>算法知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中序遍历</tag>
      
      <tag>Morris</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 968.监控二叉树</title>
    <link href="/2020/09/23/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/968-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/09/23/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/968-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-tree-cameras/">https://leetcode-cn.com/problems/binary-tree-cameras/</a></p><p>难度：困难</p><hr /><p>  给定一个二叉树，我们在树的节点上安装摄像头。</p><p>  节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象。</strong></p><p>  计算监控树的所有节点所需的最小摄像头数量。</p><p><strong>示例 1：</strong></p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200922220425128.png" alt="image-20200922220425128" style="zoom:80%;" /> <p>  输入：<code>[0,0,null,0,0]</code></p><p>  输出：<code>1</code></p><p>  解释：如图所示，一台摄像头足以监控所有节点。</p><p><strong>示例 2：</strong></p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200922220447483.png" alt="image-20200922220447483" style="zoom:67%;" /> <p>  输入：<code>[0,0,null,0,null,0,null,null,0]</code></p><p>  输出：<code>2</code></p><p>  解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。</p><p><strong>提示：</strong></p><ol><li>给定树的节点数的范围是 <code>[1, 1000]</code>。</li><li>每个节点的值都是 0。</li></ol><h2 id="解法1递归状态判断"><a class="markdownIt-Anchor" href="#解法1递归状态判断"></a> 解法1：递归+状态判断</h2><p>  仔细思考，根据题目，我们可以知道，对于一个节点 <code>node</code>，它只可能会存在三种状态（下图中<strong>红色</strong>代表安装监控器，<strong>蓝色</strong>代表被监控到，<strong>绿色</strong>代表未被监控到，或是监控与未监控两者都可）：</p><ul><li><p><code>node</code> 任意一个孩子结点已安装监视器，那么当前 <code>node</code> 节点也会被监控到，这种状态记为 <code>1</code>；</p><p>关于下面<strong>右孩子的蓝色</strong>，这边解释一下，因为我们是从下往上遍历的，且因为一些条件判断，我们会保证遇到这种情况时，孩子结点会处于监控状态，具体可看代码。</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200922213305179.png" alt="image-20200922213305179" style="zoom:80%;" /></li><li><p><code>node</code> 任意一个孩子节点未安装监视器，且该孩子节点也未被监控到，那么当前节点必须安装监视器，这种状态我们记为 <code>2</code>；</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200922214339811.png" alt="image-20200922214339811" style="zoom:80%;" /></li><li><p><code>node</code> 的孩子节点都没安装监视器，但是都被监控到了，那么当前节点可以安装监视器，也可以不安装监视器，但是本着节省资源的目的，需要将这种情况返回给父节点，让父节点做裁断（到底是父节点安装，还是当前节点安装）。</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200922214438620.png" alt="image-20200922214438620" style="zoom:80%;" /><p>​<strong>JS 代码：</strong></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> minCameraCover = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">const</span> dfs = <span class="hljs-function">(<span class="hljs-params">node</span>) =&gt;</span> &#123;      <span class="hljs-keyword">if</span> (!node) &#123; <span class="hljs-comment">// 对于空节点，默认其是未安装监视器且被监控到的状态</span>          <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;      &#125;<pre><code>  &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; left = dfs(node.left), right = dfs(node.right);  &lt;span class=&quot;hljs-comment&quot;&gt;// 若有一个孩子结点未被监控到，那么当前节点需要安装监控器，造成的结果就是返回父节点时，表现是安装了监控器&lt;/span&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (left === &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; || right === &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) &amp;#123;      res++;      &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;  &amp;#125;  &lt;span class=&quot;hljs-comment&quot;&gt;// 否则，若有一个孩子结点安装了监控器，当前节点会处于被监控的状态，且上面的判断语句已经排除了有孩子结点未被监控到的情况，因此当前节点返回到其父节点的表现就是没装监控器但是被监控到的情况&lt;/span&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (left === &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; || right === &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) &amp;#123;      &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;;  &amp;#125;  &lt;span class=&quot;hljs-comment&quot;&gt;// 否则，当前节点会处于未装监控器且未被监控到的情况，也就是状态 2.&lt;/span&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;</code></pre><p>};</p><p><span class="hljs-keyword">if</span> (dfs(root) === <span class="hljs-number">2</span>) {<br />res++;<br />}</p><p><span class="hljs-keyword">return</span> res;<br />};</code></pre>:hexoPostRenderEscape–&gt;</p></li></ul><h2 id="解法2递归"><a class="markdownIt-Anchor" href="#解法2递归"></a> 解法2：递归</h2><p>  <strong>解法2是官方的解题思路，看了几遍才看懂…因此附上一些自己的理解。</strong></p><p>  <strong>约定</strong>：若某棵树的所有节点都被监控，则称这棵树被<strong>覆盖</strong>。</p><p>  设当前节点为 <code>root</code>，其左右孩子为 <code>left</code> 和 <code>right</code> 。若想要覆盖以 <code>root</code> 为根的树，那么有两种情况：</p><ul><li>情况1：若给 <code>root</code> 设置了摄像头，那么其孩子节点 <code>left</code>、<code>right</code> 也会被监控到。此时只需要保证 <code>left</code> 和 <code>right</code> <strong>的</strong>两棵子树也被覆盖即可。</li><li>情况2：若 <code>root</code> 没有设置摄像头，那么除了要保证以<code>left</code>为根结点的树 和 以<code>right</code>为根结点的树被覆盖之外，还需要保证 <code>left</code> 和 <code>right</code> 之中至少有一个节点安装了摄像头，这样 <code>root</code> 才能被监控到。</li></ul><p>  根据这两种情况，我们可以分析出，对于每个 <code>root</code> ，需要维护三种类型的状态：</p><ul><li>状态 <code>a</code> ：<code>root</code> 必须安装摄像头的情况下（即情况1），覆盖整棵树需要的摄像头数量；</li><li>状态 <code>b</code> ：不论 <code>root</code> 是否安装摄像头，覆盖整棵树需要的摄像头数量；（也就是若 <code>root</code> 安置摄像头的话最好，不然 <code>left</code> 或 <code>right</code> 两个节点中需要至少一个有安置摄像头来保证 <code>root</code> 被监控）</li><li>状态 <code>c</code> ：不论 <code>root</code> 是否被<strong>监控</strong>到，覆盖两棵子树需要的摄像头数量；（对应着情况 1 和情况 2 中， <code>left</code>树 和 <code>right</code>树被覆盖，而<code>root</code> 是否被监控表示 <code>left</code> 或 <code>right</code> 节点可能有安置摄像头，也可能未安置摄像头）</li></ul><p>  根据以上定义，一定有 <code>a &gt;= b &gt;= c</code></p><p>  设 <code>root</code> 节点的左右孩子节点<code>left</code>、<code>right</code>维护的状态变量为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>l</mi><mi>a</mi></msub><mo separator="true">,</mo><msub><mi>l</mi><mi>b</mi></msub><mo separator="true">,</mo><msub><mi>l</mi><mi>c</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(l_a,l_b,l_c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>r</mi><mi>a</mi></msub><mo separator="true">,</mo><msub><mi>r</mi><mi>b</mi></msub><mo separator="true">,</mo><msub><mi>r</mi><mi>c</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(r_a,r_b,r_c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ，那么：</p><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><msub><mi>l</mi><mi>c</mi></msub><mo>+</mo><msub><mi>r</mi><mi>c</mi></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a = l_c + r_c + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ：即左右子树被覆盖所需的摄像头数量加上 <code>root</code> 安置的 1 个摄像头</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><msub><mi>l</mi><mi>a</mi></msub><mo>+</mo><msub><mi>r</mi><mi>b</mi></msub><mo separator="true">,</mo><msub><mi>l</mi><mi>b</mi></msub><mo>+</mo><msub><mi>r</mi><mi>a</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">b = min(a, min(l_a + r_b, l_b + r_a))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> ：即两种情况中的最小值，情况 2 中需要 <code>left</code> 和 <code>right</code> 中至少一个节点设置摄像头来保证 <code>root</code> 被监控，因此是 <strong><code>left</code> 设置 + <code>right</code> 未设置</strong> 与 <strong><code>left</code> 未设置 + <code>right</code> 设置</strong> 这两种取值中的最小值。</li></ul><p>  对于状态 <code>c</code> 而言，只需要保证 <code>left</code> 和 <code>right</code> 两棵子树被覆盖即可（包括 <code>left</code> 和 <code>right</code>）。</p><p>  那么，要么 <code>root</code> 处设置一个摄像头（保证 <code>left</code> 和 <code>right</code> 这两个节点被监控）的情况下<code>left</code> 和 <code>right</code> <strong>的</strong>两棵子树刚好也被覆盖，那么就是状态<code>a</code> 的摄像头数量；</p><p>  要么 <code>root</code> 处不放置摄像头，<code>left</code> 和 <code>right</code> 两棵子树保证自己被覆盖，所需的摄像头数量就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>l</mi><mi>b</mi></msub><mo>+</mo><msub><mi>r</mi><mi>b</mi></msub></mrow><annotation encoding="application/x-tex">l_b + r_b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p><p>  需要额外注意的是，对于 <code>root</code> 而言，如果其某个孩子为空，则不能通过在该孩子处放置摄像头的方式，监控到当前节点。因此，该孩子对应的变量 <code>a</code> 应当返回一个大整数，用于标识不可能的情形。</p><p>  最终，根节点的状态变量 <code>b</code> 即为要求出的答案。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> minCameraCover = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;    <span class="hljs-keyword">const</span> dfs = <span class="hljs-function">(<span class="hljs-params">root</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (!root) &#123;            <span class="hljs-keyword">return</span> [<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Number</span>.MAX_SAFE_INTEGER / <span class="hljs-number">2</span>), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>];        &#125;        <span class="hljs-keyword">const</span> [la, lb, lc] = dfs(root.left);        <span class="hljs-keyword">const</span> [ra, rb, rc] = dfs(root.right);        <span class="hljs-keyword">const</span> a = lc + rc + <span class="hljs-number">1</span>;        <span class="hljs-keyword">const</span> b = <span class="hljs-built_in">Math</span>.min(a, <span class="hljs-built_in">Math</span>.min(la + rb, ra + lb));        <span class="hljs-keyword">const</span> c = <span class="hljs-built_in">Math</span>.min(a, lb + rb);        <span class="hljs-keyword">return</span> [a, b, c];    &#125;    <span class="hljs-keyword">return</span> dfs(root)[<span class="hljs-number">1</span>];&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>解答</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1. HTTP概述</title>
    <link href="/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/HTTP/1.HTTP%E6%A6%82%E8%BF%B0/"/>
    <url>/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/HTTP/1.HTTP%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-web资源"><a class="markdownIt-Anchor" href="#1-web资源"></a> 1. WEB资源</h1><h2 id="11-媒体类型"><a class="markdownIt-Anchor" href="#11-媒体类型"></a> 1.1 媒体类型</h2><p>  MIME（Multipurpose Internet Mail Extention，多用途因特网邮件拓展）。</p><p>  MIME类型 （MIME type）是一种文本标记，表示一种主要的对象类型和一个特定的子类型，中间由一条斜杠来分隔。</p><p>  WEB 服务器会为所有的 HTTP 对象数据附加一个 MIME 类型，当 WEB 浏览器从服务器中取回一个对象时，会检查相关的 MIME 类型，看看它是否知道如何处理这个对象。</p><p>常见的 MIME 类型有数百个，部分如下所示：</p><ul><li>HTML 格式的文本文档由 <code>text/html</code> 类型来标记</li><li>普通的 ASCII 文本文档由 <code>text/plain</code> 类型来标记</li><li>JPEG 格式的图片为 <code>image/jpeg</code> 类型</li><li>GIF 格式的图片为 <code>image/jif</code> 类型</li><li>Apple 的 QuickTime 电影为 <code>video/quicktime</code> 类型</li><li>…</li></ul><h2 id="12-uri"><a class="markdownIt-Anchor" href="#12-uri"></a> 1.2 URI</h2><p>  每个 WEB 服务器资源都有一个名字，这些名字被统称为 <strong>统一资源标识符</strong>（Uniform Resource Identifier, URI）。</p><p>  URI 有两种形式，分别称为 URL 和 URN，不过 URN 见的较少，现在几乎所有的 URI 都是 URL，这边没有记录 URN。</p><h3 id="url"><a class="markdownIt-Anchor" href="#url"></a> URL</h3><p>  <strong>统一资源定位符</strong>（URL）描述了一台特定服务器上某资源的特定位置。</p><p><strong>URL 说明了协议、服务器和本地资源</strong> ：</p><p>​<img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200920183803074.png" alt="image-20200920183803074" style="zoom:80%;" /></p><p>大部分 URL 都遵循着一种标准格式，这个格式包含三个部分：</p><ul><li>URL 的第一部分被称为方案（scheme），说明了访问资源所使用的协议类型。如 <code>http://</code> 。</li><li>第二部分个给出了服务器的因特网地址，如 <code>www.joes-hardware.com</code>。</li><li>其余部分指定了 WEB 服务器上的某个资源，如 <code>/specials/saw-blade.gif</code>。</li></ul><h2 id="13-事务"><a class="markdownIt-Anchor" href="#13-事务"></a> 1.3 事务</h2><p>  一个 HTTP 事务是由一条（客户端发往服务器）请求命令和一个（服务器发回客户端）响应结果组成。</p><p>  这种通信是通过名为 HTTP 报文（HTTP message）的格式化数据块进行的。如下图所示：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200921090503302.png" alt="image-20200921090503302" style="zoom: 67%;" /><h2 id="14-方法"><a class="markdownIt-Anchor" href="#14-方法"></a> 1.4 方法</h2><p>  每条 HTTP 请求报文都包含一个方法（HTTP method），这个方法会告诉服务器需要执行什么动作（获取一个 Web 页面、运行一个网关程序、删除一个程序等）。下表列出了五种常见的 HTTP 方法：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200921090837035.png" alt="image-20200921090837035" style="zoom:75%;" /><h2 id="15-状态码"><a class="markdownIt-Anchor" href="#15-状态码"></a> 1.5 状态码</h2><p>  每条 HTTP 响应报文返回时都会携带一个状态码。状态码是一个三位数字的代码，它会告知客户端这条请求的状态，下表显示了几种常见的状态码：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200921091213730.png" alt="image-20200921091213730" style="zoom:80%;" /><h1 id="2-报文"><a class="markdownIt-Anchor" href="#2-报文"></a> 2. 报文</h1><p>  HTTP 报文是由一行一行的简单字符串组成的。HTTP 报文是纯文本，不是二进制代码。</p><p>  下图是一个简单事务所使用的报文：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200921093721791.png" alt="image-20200921093721791" style="zoom: 80%;" /><p>  HTTP 报文只包含两种类型：<strong>请求报文</strong> (request message) 和<strong>响应报文</strong> (response message) 。</p><p>HTTP 报文包括以下三个部分：</p><ul><li>起始行：报文的第一行是起始行，在<strong>请求报文</strong>中用于说明要做些说明，在<strong>响应报文</strong>中说明出现了什么情况。</li><li>首部字段：起始行后有零或多个首部字段。一个首部字段包含一个字段名和值，两者使用 <code>:</code> 分隔。首部字段以一个空行结束。</li><li>主体：首部字段的空行之后就是可选的报文主体。<strong>请求主体</strong>中包含了要发送给 Web 服务器的数据；<strong>响应主体</strong>中装载了要返回给客户端的数据。与起始行和首部不同，主体中可以包含文本或任意的二进制数据（如图片、视频、音频、软件程序等）。</li></ul><h1 id="3-连接"><a class="markdownIt-Anchor" href="#3-连接"></a> 3. 连接</h1><p>  报文是通过<strong>传输控制协议</strong>（Transmission Control Protocol，<strong>TCP</strong>）连接从一个地方传递到另一个地方。</p><h2 id="31-tcpip"><a class="markdownIt-Anchor" href="#31-tcpip"></a> 3.1 TCP/IP</h2><p>  HTTP 是个应用层协议，其内部的通信细节都由 TCP/IP 来完成。</p><p>TCP 提供了：</p><ul><li>无差错的数据传输</li><li>按序传输（数据总是会按照发送的顺序到达）</li><li>未分段的数据流（可以在任意时刻以任意尺寸将数据发送出去）</li></ul><p>  HTTP 位于 TCP 的上层，下图是 HTTP 网络协议栈：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200921095353410.png" alt="image-20200921095353410" style="zoom: 80%;" /><h2 id="32-连接-ip-地址及端口号"><a class="markdownIt-Anchor" href="#32-连接-ip-地址及端口号"></a> 3.2 连接、IP 地址及端口号</h2><p>  在 HTTP 客户端向服务器发送报文之前，需要使用网际协议（Internet Protocol，IP）地址和端口号在客户端和服务器之间建立一条 TCP/IP 连接。</p><p>  建立 TCP 连接的过程类似于给公司办公室的某个人打电话的过程；首先，需要拨打正确的公司的电话号码，然后再拨打那个人的公司分机号。</p><p>  HTTP 服务器的 IP 和端口号是通过 URL 获取的。</p><p>如</p><ul><li><code>http://207.200.83.29:80/index.html</code></li><li><code>http://www.netscape.com:80/index.html</code></li><li><code>http://www.metscape.com/index.html</code></li></ul><p>  第三条 URL 中没有指定端口号则会使用默认的端口号，如 <code>80</code></p><p>  下图是一个基本的浏览器连接处理过程：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200921100649034.png" alt="image-20200921100649034" style="zoom: 80%;" /><p>步骤如下：</p><ol><li>浏览器从 URL 中解析出服务器的主机名；</li><li>浏览器将服务器的主机名转换成服务器的 IP 地址；</li><li>浏览器将端口号（若有指定）从 URL 中解析出来；</li><li>浏览器建立一条与 WEB 服务器的 TCP 连接；</li><li>浏览器向服务器发送一条 HTTP 请求报文；</li><li>服务器向浏览器会送一条 HTTP 响应报文；</li><li>关闭连接，浏览器显示文档。</li></ol><h1 id="4-协议版本"><a class="markdownIt-Anchor" href="#4-协议版本"></a> 4. 协议版本</h1><p>HTTP 有多个协议版本：</p><ul><li>HTTP/0.9</li><li>HTTP/1.0</li><li>HTTP/1.0+</li><li>HTTP/1.1</li><li>HTTP-NG (又名 HTTP/2.0)</li></ul><p>  不过目前在广泛使用的仍是 HTTP/1.1 版本</p><h1 id="5-web-的结构组件"><a class="markdownIt-Anchor" href="#5-web-的结构组件"></a> 5. Web 的结构组件</h1><h2 id="51-代理"><a class="markdownIt-Anchor" href="#51-代理"></a> 5.1 代理</h2><p>  代理是位于客户端和服务器之间的 HTTP 中间实体，它是 Web 安全、应用集成以及性能优化的重要组成模块。</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-2020092110112604125.png" alt="image-2020092110260412511" style="zoom:80%;" /><p>  代理接收所有客户端的 HTTP 请求，并将这些请求转发给服务器（可能会对请求进行修改）。代理还能对请求和响应进行过滤，比如对下载的应用程序进行病毒检测、或对小学生屏蔽一些成年人才能看的内容。</p><h2 id="52-缓存"><a class="markdownIt-Anchor" href="#52-缓存"></a> 5.2 缓存</h2><p>  缓存是 HTTP 的仓库，常用的页面副本可以保存在离客户端更近的地方。</p><p>  Web 缓存（Web cache）或代理缓存（proxy cache）是一种特殊的 HTTP 代理服务器，可将经过代理的常用文档的副本保存下来，下次再访问这个资源时就能直接在代理服务器上下载，加快了下载速度。</p><h2 id="53-网关"><a class="markdownIt-Anchor" href="#53-网关"></a> 5.3 网关</h2><p>  网关（gateway）是一种特殊的服务器，作为其他服务器的中间实体使用。</p><p>  通常用于将 HTTP 流量转换成其他的协议。</p><p>  例如，一个 HTTP/FTP 网关会通过 HTTP 请求接收对 FTP URI 的请求，但通过 FTP 协议来获取文档。得到的文档会封装成一条 HTTP 报文，发送给客户端。</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200921104641330.png" alt="image-20200921104641330" style="zoom:80%;" /><h2 id="54-隧道"><a class="markdownIt-Anchor" href="#54-隧道"></a> 5.4 隧道</h2><p>  隧道（tunnel）是建立起来之后，就会在两条连接之间对原始数据进行盲转发的 HTTP 应用程序。</p><p>  HTTP 隧道通常用来在一条或多条 HTTP 连接上转发非 HTTP 数据，转发时不会窥探数据。</p><p>  HTTP 隧道的一种常见的用途就是通过 HTTP 连接承载加密的安全套接字层（SSL，Secure Sockets Layer）流量，这样 SSL 流量就可以穿过只允许 Web 流量通过的防火墙了。</p><p>  如下图所示，HTTP/SSL 隧道收到一条 HTTP 请求，要求建立一条到目的地址和端口的输出连接，然后在 HTTP 信道上通过隧道 传输 加密的 SSL 流量，这样就能将其盲转发到目的服务器上去了。</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200921105518446.png" alt="image-20200921105518446" style="zoom:80%;" /><h2 id="55-agent-代理"><a class="markdownIt-Anchor" href="#55-agent-代理"></a> 5.5 Agent 代理</h2><p>  用户 Agent 代理是代表用户发起 HTTP 请求的客户端程序。</p><p>  我们常用的一种 Agent 代理就是 Web 浏览器。</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThreeJS快照</title>
    <link href="/2020/09/20/WebGL/ThreeJS/ThreeJS%E6%88%AA%E5%9B%BE/"/>
    <url>/2020/09/20/WebGL/ThreeJS/ThreeJS%E6%88%AA%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p>  假设有一个需求，需要获取 Three 场景的一张快照，然后再将其显示在屏幕上。</p><h1 id="1-获取快照"><a class="markdownIt-Anchor" href="#1-获取快照"></a> 1. 获取快照</h1><p>  对于这个需求，一种方法是在创建 <code>WebGLRenderer</code> 时设置一个 <code>preserveDrawingBuffer</code> 参数为 <code>true</code>，然后再调用场景中的 <code>canvas</code> 的 <code>toDataURL</code> 方法来获取某一帧的 <code>base64</code> 格式的图像数据：</p><pre><code class="hljs js">renderer = <span class="hljs-keyword">new</span> WebGLRenderer(&#123;    preserveDrawingBuffer :<span class="hljs-literal">true</span> &#125;);<span class="hljs-keyword">const</span> image = <span class="hljs-keyword">new</span> Image();image.src = renderer.domElement.toDataURL();</code></pre><p>  而 <code>preserveDrawingBuffer</code> 参数的含义是：是否保留缓直到手动清除或被覆盖。若设为 <code>true</code>，在任意时刻，前一帧的缓存图像不会被清除，因此可以获取到任意一刻的截图，若未设置的话，获取的截图可能就会是一张空白的图片。不过，这有一个明显的副作用，那就是会更加的消耗性能和占用内存。因此<strong>不推荐</strong>这种方式。</p><p>  <strong>另一种方式</strong>就是在获取截图之前先再渲染一下场景，这样就不会因为缓存清空而导致截屏空白了：</p><pre><code class="hljs js">renderer.clear();renderer.render(scene, camera);<span class="hljs-keyword">const</span> image = <span class="hljs-keyword">new</span> Image();image.src = canvas.toDataURL(<span class="hljs-string">&quot;image/png&quot;</span>);</code></pre><h1 id="2在屏幕上显示出来"><a class="markdownIt-Anchor" href="#2在屏幕上显示出来"></a> 2.在屏幕上显示出来</h1><p>  既然我们已经能够获取到正确的快照了，那么要将其显示在屏幕上，我们可以再创建一个新的 <code>canvas</code>，然后将获取的快照使用这个新的 <code>canvas</code> 加载出来就行了，代码如下：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> canvas = renderer.domElement;renderer.render(scene, camera);<span class="hljs-keyword">const</span> image = <span class="hljs-keyword">new</span> Image();<span class="hljs-keyword">const</span> base64 = canvas.toDataURL(<span class="hljs-string">&quot;image/png&quot;</span>);image.src = base64;<span class="hljs-keyword">const</span> mycanvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myImageEditCanvas&#x27;</span>);mycanvas.width = canvas.width;mycanvas.height = canvas.height;<span class="hljs-keyword">const</span> ctx = mycanvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);image.onload = <span class="hljs-function">() =&gt;</span> &#123;    ctx.drawImage(image, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);&#125;;</code></pre><p>  使用 <code>canvas</code> 载入图像使用了 <code>drawImage</code> 方法，它的第二第三个参数的意思是从源图像的哪个位置开始载入，要载入整张图像，填入 <code>0</code> 即可。</p><p>  <code>drawImage</code> 详细一些的介绍可看：<a href="https://yleave.top/2020/09/20/HTML/canvas%E6%93%8D%E4%BD%9C%E5%9B%BE%E5%83%8F/">drawImage</a></p>]]></content>
    
    
    <categories>
      
      <category>WebGL</category>
      
      <category>ThreeJS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>canvas</tag>
      
      <tag>threeJS</tag>
      
      <tag>快照</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>canvas操作图像</title>
    <link href="/2020/09/20/HTML/canvas%E6%93%8D%E4%BD%9C%E5%9B%BE%E5%83%8F/"/>
    <url>/2020/09/20/HTML/canvas%E6%93%8D%E4%BD%9C%E5%9B%BE%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="canvas-获取截图"><a class="markdownIt-Anchor" href="#canvas-获取截图"></a> canvas 获取截图</h1><p>  具体是使用 <code>canvas</code> 的 <code>toDataURL</code> 方法：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> image = <span class="hljs-keyword">new</span> Image();image.src = canvas.toDataURL(<span class="hljs-string">&quot;image/png&quot;</span>);</code></pre><p>  <code>toDataURL</code> 的第一个参数是图像类型，默认是 <code>image/png</code>，也可设置为 <code>image/jpeg</code> 。</p><p>  详细可看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLCanvasElement/toDataURL">MDN</a> 的介绍。</p><p>  若想将获取的图像下载下来：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> imgUri = canvas.toDataURL(<span class="hljs-string">&quot;image/png&quot;</span>).replace(<span class="hljs-string">&quot;image/png&quot;</span>, <span class="hljs-string">&quot;image/octet-stream&quot;</span>);<span class="hljs-built_in">window</span>.location.href= imgUri; <span class="hljs-comment">// 下载图片</span></code></pre><h1 id="canvas-载入图像"><a class="markdownIt-Anchor" href="#canvas-载入图像"></a> canvas 载入图像</h1><p>  <code>canvas</code> 载入图像有两种方式。一种是使用 <code>drawImage</code> 方法载入任何 <code>canvas</code> 支持的图像类型，另一种是使用 <code>putImageData</code> 方法或是通过循环遍历的方式根据像素值加载图像。</p><h2 id="使用-drawimage-载入图像"><a class="markdownIt-Anchor" href="#使用-drawimage-载入图像"></a> 使用 drawImage 载入图像</h2><p>  <code>canvas</code> 支持的图像类型有：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CSSImageValue">CSSImageValue</a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLImageElement">HTMLImageElement</a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/SVGImageElement">SVGImageElement</a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLVideoElement">HTMLVideoElement</a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLCanvasElement">HTMLCanvasElement</a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ImageBitmap">ImageBitmap</a> 或者<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/OffscreenCanvas">OffscreenCanvas</a>。</p><p>  以最常见的 <code>HTMLImageElement</code> 类型的图像为例，也就是使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLImageElement/Image">Image</a> 方法或是 <code>&lt;img&gt;</code> 标签创建的对象：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> image = <span class="hljs-keyword">new</span> Image();image.src = <span class="hljs-string">&#x27;picture.jpg&#x27;</span>;<span class="hljs-comment">// or </span><span class="hljs-comment">// &lt;img id=&quot;picture&quot; src=&quot;...&quot; width=&quot;300&quot; height=&quot;227&quot;&gt;</span><span class="hljs-keyword">var</span> image = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;picture&#x27;</span>);</code></pre><p>  然后，就能使用 <code>drawImage</code> 方法载入这个对象：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;canvas&quot;</span>);<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&quot;2d&quot;</span>);ctx.drawImage(image, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);</code></pre><p>  对于 <code>new Image</code> 方式创建的 <code>image</code> ，需要等到图片加载完成后才能载入：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> image = <span class="hljs-keyword">new</span> Image();image.src = <span class="hljs-string">&#x27;picture.jpg&#x27;</span>;image.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    ctx.drawImage(image, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);&#125;;</code></pre><p>  <code>drawImage</code> 方法有多个参数，除了第一个 <code>imageSource</code> 是必须的，其他参数都是可选的，其他参数设置了源图像和目标图像的起始位置和截取范围：</p><p>  <code>drawImage(image, source_x, source_y, source_width, source_height, x, y, width, heigh)</code></p><p>  因此，<code>drawImage</code> 方法不仅能够普通的载入图像，还能够在载入图像的过程中对图像进行裁剪和缩放。</p><p>  具体可参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/drawImage">MDN1</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Using_images">MDN2</a></p><h2 id="使用-putimagedata-载入图像"><a class="markdownIt-Anchor" href="#使用-putimagedata-载入图像"></a> 使用 putImageData 载入图像</h2><p>  首先，使用该方法，我们需要一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ImageData">ImageData</a> 的对象。这个对象中存储着 <code>canvas</code> 对象真实的像素数据。</p><p><code>ImageData</code> 对象包含以下几个<strong>只读</strong>属性：</p><ul><li><code>width</code> : 图片宽度，单位是像素</li><li><code>height</code> : 图片高度，单位是像素</li><li><code>data</code>: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray">Uint8ClampedArray</a>类型的一维数组，包含着 <strong>RGBA</strong> 格式的整型数据，范围在0至255之间（包括255）。</li></ul><p>  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray">Uint8ClampedArray</a> 包含高度 × 宽度 × 4 bytes 数据，索引值从 <code>0</code> 到 <code>(高度 × 宽度 × 4 ) - 1</code></p><p>  下面将图像从一个 <code>canvas</code> 复制到一个新的 <code>canvas</code>，涉及两个函数：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/getImageData">getImageData</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/putImageData">putImageData</a></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;canvas&quot;</span>);<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&quot;2d&quot;</span>);<span class="hljs-keyword">var</span> imgData = ctx.getImageData(left, top, width, height);<span class="hljs-keyword">var</span> newCvs = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;new_canvas&quot;</span>);<span class="hljs-keyword">var</span> cewCtx = newCvs.getContext(<span class="hljs-string">&quot;2d&quot;</span>);cewCtx.putImageData(imgData, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);</code></pre><p>  若是已知图像的像素值，也可使用循环遍历的方式来载入图像：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;canvas&quot;</span>);<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&quot;2d&quot;</span>);<span class="hljs-comment">// 创建一个空的 ImageData 对象</span><span class="hljs-keyword">var</span> img = context.createImageData(width, height);<span class="hljs-keyword">var</span> data = img.data;<span class="hljs-comment">// 按 RGBA 格式存储数据</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; height; i++) &#123;    <span class="hljs-keyword">var</span> l = height - <span class="hljs-number">1</span> - i;    <span class="hljs-keyword">var</span> s1 = l * width * <span class="hljs-number">4</span>;    <span class="hljs-keyword">var</span> s2 = i * width * <span class="hljs-number">4</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; width * <span class="hljs-number">4</span>; j++) &#123;        data[s1 + j] = imageData[s2 + j]    &#125;&#125;context.putImageData(img, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);</code></pre><p>  更多详细内容可参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas">像素操作</a></p>]]></content>
    
    
    <categories>
      
      <category>HTML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>canvas</tag>
      
      <tag>js截图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 47. 全排列 II</title>
    <link href="/2020/09/19/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/47-%E5%85%A8%E6%8E%92%E5%88%97-II/"/>
    <url>/2020/09/19/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/47-%E5%85%A8%E6%8E%92%E5%88%97-II/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/permutations-ii/">https://leetcode-cn.com/problems/permutations-ii/</a></p><p>难度：中等</p><hr /><p>  给定一个可<strong>包含重复数字</strong>的序列，返回所有不重复的全排列。</p><p><strong>示例:</strong></p><p>输入: <code>[1,1,2]</code></p><p>输出:</p><pre><code class="hljs json">[  [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>],  [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]]</code></pre><h2 id="解法1回溯-剪枝"><a class="markdownIt-Anchor" href="#解法1回溯-剪枝"></a> 解法1：回溯 + 剪枝</h2><p>  这题求全排列的步骤与 <a href="https://yleave.top/2020/09/17/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/46-%E5%85%A8%E6%8E%92%E5%88%97/">46.全排列</a> 这题是一样的，区别就是 <code>46.</code> 这题给的数字序列是不含重复的数字，而本题则包含重复数字。</p><p>  这样的话，我们只需要在原先的基础上对其进行剪枝即可，将造成重复组合的情况去除。</p><p>  考虑一组序列：<code>[2, 2, 1, 1]</code>，标记一下以便区分：<code>[2, 2', 1, 1']</code>，对于这组序列，按照 <code>46.</code> 的思路，会造成重复的情况有在固定索引 <code>0</code> 处的值时，序列中的两个 <code>2</code> 和两个 <code>1</code> 都会造成固定值重复，即 <code>[2, 2', 1, 1']</code> 、<code>[2', 2, 1, 1']</code>，<code>[1, 2', 2, 1']</code> 和 <code>[1', 2', 1, 2]</code> ，这样，由于第一个固定的数字就重复，后面的所有组合也都是重复的。</p><p>  因此，我们要做的就是<strong>让每个索引处固定的值不再重复！</strong></p><p>  要做到这样，我们可以借用一个 <code>map</code>，对于每个固定的索引，当一个值是第一次出现时，将其记录在 <code>map</code> 中，而若是遇到了 <code>map</code> 中已经存的值，则说明这个值已经固定过了，跳过它，这样就完成了全排列过程中的去重要求。</p><p>  当然，还有一个很耿直的做法就是：还是像 <code>46.</code> 一样计算序列的组合，只在保存每个组合结果时，使用一个 <code>map</code> 记录当前组合是否保存过，若未保存过，则记录到结果数组中。。。</p><p>剪枝的 JS 代码：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> permuteUnique = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = [];    <span class="hljs-keyword">let</span> len = nums.length;    <span class="hljs-keyword">const</span> swap = <span class="hljs-function">(<span class="hljs-params">i, j</span>) =&gt;</span> &#123;        <span class="hljs-keyword">let</span> tmp = nums[i];        nums[i] = nums[j];        nums[j] = tmp;    &#125;;    <span class="hljs-keyword">const</span> helper = <span class="hljs-function"><span class="hljs-params">index</span> =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (index === len) &#123;            res.push(nums.slice());            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">let</span> map = [];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = index; i &lt; len; i++) &#123;            <span class="hljs-keyword">if</span> (map[nums[i]]) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            map[nums[i]] = <span class="hljs-number">1</span>;            swap(index, i);            helper(index+<span class="hljs-number">1</span>);            swap(index, i);        &#125;    &#125;;    helper(<span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> res;&#125;;</code></pre><h2 id="牛客网的全排列"><a class="markdownIt-Anchor" href="#牛客网的全排列"></a> 牛客网的全排列</h2><p><a href="https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=188&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1">题目地址</a></p><p><strong>题目描述</strong></p><p>  输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串<code>abc</code>,则按字典序打印出由字符<code>a,b,c</code>所能排列出来的所有字符串<code>abc</code>,<code>acb</code>,<code>bac</code>,<code>bca</code>,<code>cab</code>和<code>cba</code>。</p><p>**输入描述:**输入一个字符串,长度不超过<code>9</code>(<strong>可能有字符重复</strong>),字符只包括大小写字母。</p><p>  相较于 LeetCode 的全排列，这题要求答案需要按照字符序进行排列，因此使用上面的方法并不能满足字符序的要求。</p><p>  一个简单的使用回溯输出字符序全排列的方法就是创建一个 <code>visited</code> 数组，每次选取字符时从头到尾遍历一次，跳过已经选取的字符，最后在保存结果时判断一下是否有重复的结果，若无，则保存，有则跳过。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Permutation</span>(<span class="hljs-params">str</span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (str === <span class="hljs-string">&#x27;&#x27;</span>) &#123;        <span class="hljs-keyword">return</span> [];    &#125;    <span class="hljs-keyword">let</span> res = [];    <span class="hljs-keyword">let</span> len = str.length;    <span class="hljs-keyword">let</span> arr = [];    <span class="hljs-keyword">let</span> visited = [];    <span class="hljs-keyword">const</span> dfs = <span class="hljs-function"><span class="hljs-params">index</span> =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (index === len) &#123;            <span class="hljs-keyword">let</span> s = arr.join(<span class="hljs-string">&#x27;&#x27;</span>);            <span class="hljs-keyword">if</span> (res.indexOf(s) === <span class="hljs-number">-1</span>) &#123;                res.push(s);            &#125;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;            <span class="hljs-keyword">if</span> (!visited[i]) &#123;                arr.push(str[i]);                visited[i] = <span class="hljs-literal">true</span>;                dfs(index+<span class="hljs-number">1</span>);                arr.pop();                visited[i] = <span class="hljs-literal">false</span>;            &#125;        &#125;    &#125;;        dfs(<span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>解答</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 46. 全排列</title>
    <link href="/2020/09/19/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/46-%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <url>/2020/09/19/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/46-%E5%85%A8%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/permutations/">https://leetcode-cn.com/problems/permutations/</a></p><p>难度：中等</p><hr /><p>  给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p><p><strong>示例:</strong></p><p>输入: <code>[1,2,3]</code></p><p>输出:</p><pre><code class="hljs json">[  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],  [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>],  [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],  [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>],  [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],  [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]]</code></pre><h2 id="解法1回溯法"><a class="markdownIt-Anchor" href="#解法1回溯法"></a> 解法1：回溯法</h2><p>  对于一组<strong>没有重复</strong>数字的序列，要求它的全排列，假设这个序列是 <code>[1, 2, 3]</code>，若用手算，我们是这样算的：</p><ol><li><p>固定索引 <code>0</code> 处的数字 <code>1</code> ，剩下的就是 <code>[2, 3]</code>，两个数字的组合有 <code>[2, 3]</code> 和 <code>[3, 2]</code> ，再加上 <code>1</code> ，就得到了组合 <code>[1, 2, 3]</code> 和 <code>[1, 3, 2]</code>。（其实对于如 <code>[2, 3]</code> 这样的未固定的数字，我们也是像固定 <code>1</code> 一样，先固定住索引 <code>1</code> 处的数字 <code>2</code> ，剩下一个 <code>3</code>，得到组合后再回溯回去，换一个值固定在索引 <code>1</code> 处，即 <code>[3, 2]</code> … ）。</p></li><li><p>现在再改变索引 <code>0</code> 处的数字为 <code>2</code>，即 <code>1</code> 与 <code>2</code> 互换位置，那么剩下的数字就是 <code>[1, 3]</code> ，组合有 <code>[1, 3]</code> 和 <code>[3, 1]</code>，再加上固定的 <code>2</code> ，就得到了 <code>[2, 1, 3]</code> 和 <code>[2, 3, 1]</code>。</p></li><li><p>同理，恢复到初始的 <code>[1, 2, 3]</code>，再改变索引 <code>0</code> 的值为 <code>3</code>，剩下了 <code>[2, 1]</code> ，组合有 <code>[2, 1]</code> 和 <code>[1, 2]</code>，加上 <code>3</code> ，得到的组合就是 <code>[3, 2, 1]</code> 和 <code>[3, 1, 2]</code>。</p></li></ol><p>  整理一下我们的计算过程，也就是对于每个索引 <code>0, 1,...,n</code> ，我们从索引 <code>0</code>  开始，固定住每一位，对于剩下未固定的数字再进行全排列，这样，每次固定到索引末尾时，我们就获得了一个组合，对每个索引取所有的值都固定一遍，我们就得到了所有数字的全排列了！</p><p>  （可能还是有些没讲清楚，请看代码：</p><p><strong>JS 代码：</strong></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> permute = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = [];    <span class="hljs-keyword">let</span> len = nums.length;    <span class="hljs-keyword">const</span> swap = <span class="hljs-function">(<span class="hljs-params">i, j</span>) =&gt;</span> &#123;        <span class="hljs-keyword">let</span> tmp = nums[i];        nums[i] = nums[j];        nums[j] = tmp;    &#125;;      <span class="hljs-keyword">const</span> helper = <span class="hljs-function"><span class="hljs-params">index</span> =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (index === len) &#123; <span class="hljs-comment">// 当最后一个数字也被固定后，就得到了一个组合</span>            res.push(nums.slice());            <span class="hljs-keyword">return</span>;        &#125;<span class="hljs-comment">// 对于每个索引 index，取所有的值都固定一次，每固定一次后 index+1 ,固定下一位</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = index; i &lt; len; i++) &#123;            swap(index, i);            helper(index+<span class="hljs-number">1</span>);            swap(index, i);        &#125;    &#125;;    helper(<span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> res;&#125;;</code></pre><p><strong>CPP 代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">permute</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt; res;        helper(res,nums,<span class="hljs-number">0</span>,nums.size());        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt; &amp;res,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> n)</span></span>&#123;        <span class="hljs-keyword">if</span>(b == n)&#123;            res.push_back(nums);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = b; i &lt; n; i++)&#123;            swap(nums[i],nums[b]);            helper(res,nums,b + <span class="hljs-number">1</span>,n);            swap(nums[b],nums[i]);        &#125;    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>解答</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>github+picGo+jsDelivr构建图床</title>
    <link href="/2020/09/19/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/github-picGo-jsDelivr%E6%9E%84%E5%BB%BA%E5%9B%BE%E5%BA%8A/"/>
    <url>/2020/09/19/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/github-picGo-jsDelivr%E6%9E%84%E5%BB%BA%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>  不论是写博客还是记笔记，图床的选择很重要。且对于一个博客平台来说，网站中的图片、视频以及音频等资源的下载速度直接影响到了整个博客网站的加载和体验，这点我深有体会。</p><p>  就我个人来说，最开始，我在博客中有加入音乐播放器，音频和部分图片是直接存储在博客项目里的，而文章中的一些图片则使用 <strong><a href="http://SM.MS">SM.MS</a> 图床</strong>存储，然后每次打开网站时都要等很久网站的资源才能加载出来，开始我还认为是因为博客是部署在 githubPages 上导致的网站访问缓慢，也试了一些方法如 <a href="https://yleave.top/2020/09/12/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E4%BD%BF%E7%94%A8Netlify%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/">使用Netlify部署博客</a> 来尝试加速网站的访问，然并卵…</p><p>  直到有一天我受不了图片的上传和加载速度的缓慢，就尝试了下经常在博客搭建教程中看到的 <strong>七牛云图床</strong>。结果确实很香~，我不仅将图片存储在了七牛云上，并且将音频也一并存储了。重新部署后网站的访问速度有了肉眼可见的提升。直到这时，我才直到原来之前<strong>访问速度慢的原因不止是部署服务器的问题，和网站中的静态资源也有很大的关系！</strong></p><p>  使用 七牛云图床 前后对比：</p><p><img src="https://i.loli.net/2020/09/18/IcYpjFWJnC6Kmft.png" alt="img" style="zoom: 40%;" /> <img src="https://i.loli.net/2020/09/18/1GJKUjIVdBLrTno.png" alt="image-20200918152333510" style="zoom:40%;" /></p><p>  效果确实好了很多。</p><h2 id="七牛云图床吐槽"><a class="markdownIt-Anchor" href="#七牛云图床吐槽"></a> 七牛云图床吐槽</h2><p>  <font color="skyblye" style="font-size:150%;font-weight:bold"> 不过!!! </font></p><p>  虽然七牛云有提供免费的 10G 空间，但是如果想要真正使用七牛云图床的完整服务的话，你的网站<strong>需要备案</strong>，也就是说需要自己租一个服务器，在上面部署网站（掏了下口袋，空空的，想想还是算了吧）。</p><img src="https://i.loli.net/2020/09/18/Ei4Smw3g5lD8M2I.jpg" alt="穷" style="zoom:50%;" /><p>  否则，你只能得到一个<strong>临时域名</strong>，也就是你你资源路径的前面部分，如 <code>http://xxxxx.hd-bkt.clouddn.com/1.jpg</code> 。然后这个临时域名会在 30 天之后回收！！这意味着 30 天后你网站中所有使用七牛云存储的静态资源都不能正常访问了！！</p><img src="https://i.loli.net/2020/09/18/meyl9OXUJAZu2xr.png" alt="image-20200918153307205" style="zoom:80%;" /><p>  其次，七牛云上的临时域名还是 <code>HTTP</code> 的，就算使用了备案的域名绑定，想使用 <code>HTTPS</code> 的域名也需要交费（又掏了掏口袋）。</p><p>  你的网站就会变成这样（看着是不是很不爽）</p><img src="https://i.loli.net/2020/09/18/9jygoJbrIdp4q7l.png" alt="image-20200918154227852" style="zoom:80%;" /><p>  因此，果断抛弃七牛云，尝试使用 github 图床 + jsDelivr CDN加速访问！</p><p>  好了，说了这么多废话，下面是配置过程。</p><h1 id="配置-github-图床"><a class="markdownIt-Anchor" href="#配置-github-图床"></a> 配置 github 图床</h1><p>  首先，新建一个 github 仓库：</p><img src="https://i.loli.net/2020/09/18/uk7X3qAhBJTIzNQ.png" alt="image-20200918154812090" style="zoom: 50%;" /><p>  依次点击 Settings -&gt; DeveloperSettings -&gt; Personal access tokens -&gt;  Generate new token</p><p><img src="https://i.loli.net/2020/09/18/ZzsiVL1nSIbkKlH.png" alt="image-20200918155050224" style="zoom: 67%;" /> <img src="https://i.loli.net/2020/09/18/GKp6XhkMWPgnaoT.png" alt="image-20200918155149215" style="zoom:50%;" /> <img src="https://i.loli.net/2020/09/18/A6iyYX3ObQLZraI.png" alt="image-20200918155324860" style="zoom:50%;" /></p><p>  填写描述，再勾选 repo，最后拉到底点击 Generate token。</p><img src="https://i.loli.net/2020/09/18/w2dSAbWyuz6QXF8.png" alt="image-20200918155537060" style="zoom:67%;" /> <img src="https://i.loli.net/2020/09/18/raUQvJ4lgGb7R1y.png" alt="image-20200918155736272" style="zoom:50%;" /> <h1 id="picgo-配置"><a class="markdownIt-Anchor" href="#picgo-配置"></a> PicGo 配置</h1><p>  然后打开 <a href="https://github.com/Molunerfinn/picgo/releases">PicGo</a> 进行配置 （PicGo 是图床管理工具，能配合种图床使用，typora 中也支持使用 PicGo 自动上传图片，使用起来不要太方便了~</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200918174221758.png" alt="image-20200918174221758" style="zoom: 67%;" /><p>  配置如上。</p><ul><li>仓库名：格式是 ：github用户名/图床仓库名</li><li>分支：master</li><li>token：前面生成的 token</li><li>存储路径：自己定义，如 <code>img/</code> 的话就会在仓库下生成一个 <code>img</code> 文件夹来存储图片</li><li>自定义域名：在图片上传后，PicGo会按照<code>自定义域名+储存路径+上传的图片名</code>的方式生成访问链接，放到粘贴板上，因为我们要使用 jsDelivr 加速访问，所以可以设置为<code>https://cdn.jsdelivr.net/gh/用户名/图床仓库名</code> ，上传完毕后，我们就可以通过<code>https://cdn.jsdelivr.net/gh/用户名/图床仓库名/图片路径</code>加速访问我们的图片了。</li></ul><h1 id="jsdelivr"><a class="markdownIt-Anchor" href="#jsdelivr"></a> jsDelivr</h1><p>  关于 jsDelivr 是不需要配置的，对于 github ，只要符合 jsDelivr 规定的路径，且<strong>仓库大小小于 50M ，文件不超过 20M</strong> 的都能直接引用。</p><p>  规定的路径格式就是上面提到的：<code>https://cdn.jsdelivr.net/gh/用户名/图床仓库名/图片路径</code>。</p><p>  如我在 <code>imagehost</code> 仓库的 <code>img</code> 文件夹下有一张图片 <code>default.png</code> ，这样就能通过：<a href="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/default.png">https://cdn.jsdelivr.net/gh/yleave/imagehost/img/default.png</a> 来访问它了。</p><p>  当然，jsDelivr 不止能加速图片的访问，对于视频文件和音频文件也能使用同样的方法访问，不过美中不足的是仓库大小不能超过 50M。</p><h1 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h1><h2 id="imagine"><a class="markdownIt-Anchor" href="#imagine"></a> Imagine</h2><p>  jsDelivr 限制了仓库大小，因此图片的压缩很重要，这里再推荐一个图片压缩工具 <a href="https://github.com/meowtec/Imagine">Imagine</a> ，非常好用，压缩效果很好，1M多的图片压缩成不到 100k 的图片也基本上看不出什么差别：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200918175722716.png" alt="image-20200918175722716" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200918175745739.png" alt="image-20200918175745739" style="zoom:67%;" /><h2 id="staticaly-与-githack"><a class="markdownIt-Anchor" href="#staticaly-与-githack"></a> staticaly 与 githack</h2><p>  除了 jsDelivr 外，还有几个免费的且不限流量的CDN， <code>staticaly</code> <code>githack</code> ，它们都是全球通用的。</p><h3 id="staticaly"><a class="markdownIt-Anchor" href="#staticaly"></a> staticaly</h3><p>  官网地址：<a href="https://statically.io/">https://www.staticaly.com</a></p><p>  轻松地从GitHub / GitLab / Bitbucket等加载您的项目 没有流量限制或限制。</p><p>  文件通过超快速全球CDN提供。 在URL（不是分支）中使用特定标记或提交哈希。</p><p>  根据URL永久缓存文件。 除master分支外，文件在浏览器中缓存1年。 具体用法：</p><p>  <code>staticaly</code> 的用法：进入网站，将你的资源链接贴上去就会有了可用的链接：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200919005010468.png" alt="image-20200919005010468" style="zoom: 50%;" /><h3 id="githack"><a class="markdownIt-Anchor" href="#githack"></a> githack</h3><p><strong>该 CDN 亲测需要接外网</strong></p><p>  直接从GitHub，Bitbucket或GitLab提供原始文件</p><p>  官网地址：<a href="https://raw.githack.com/">http://raw.githack.com/</a> 具体用法和上面的<code>staticaly</code>很类似</p><p>  同样，在网站中输入资源链接，如：</p><img src="https://cdn.jsdelivr.net/gh/yleave/imagehost/img/image-20200919005149597.png" alt="image-20200919005149597" style="zoom: 80%;" /><p>  有两个 URL 版本：生产模式和开发模式，亲测生产模式速度会更快些，开发模式的 URL 会更“工整” 些，以便测试。不过别看生产模式的 URL 是有一长串字符，这些只要你前面的路径没变，这些字符都是一样的，因此同样比较方便统一路径。</p><p>  当然，最最具有吸引力的就是它没有限制仓库容量，并且是永久免费的！</p><hr /><p><a href="https://blog.csdn.net/qq_36759224/article/details/98058240">参考1</a></p><p><a href="https://www.itrhx.com/2019/02/10/A18-free-cdn/">参考2</a></p><p><a href="https://www.cnblogs.com/lfri/p/12212878.html">参考3</a></p>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图床</tag>
      
      <tag>CDN</tag>
      
      <tag>PicGo</tag>
      
      <tag>jsDelivr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2020/09/17/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2020/09/17/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p>并查集就是一个数组 <code>father[]</code> ，<code>father[i]</code> 表示元素 <code>i</code> 的父节点。</p><p>并查集的使用场景主要有：</p><ul><li>寻找节点的公共根结点</li><li>判断图的连通性</li><li>求集合的个数（根据给定的数据，求这些数据能够构成几个不连通的图）</li><li>…</li></ul><p>并查集的几个操作：</p><h2 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h2><pre><code class="hljs js"><span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;    father[i] = i;&#125;</code></pre><h2 id="查找"><a class="markdownIt-Anchor" href="#查找"></a> 查找</h2><p>用于快速找到某个节点的根结点</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findFather</span>(<span class="hljs-params">x</span>) </span>&#123;    <span class="hljs-keyword">while</span> (father[x] !== x) &#123;        x = father[x];    &#125;        <span class="hljs-keyword">return</span> x;&#125;<span class="hljs-comment">// or 递归</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">father</span>(<span class="hljs-params">x</span>) </span>&#123;    <span class="hljs-keyword">if</span> (x === father[x]) &#123;        <span class="hljs-keyword">return</span> x;    &#125;    <span class="hljs-keyword">return</span> findFather(father[x]);&#125;</code></pre><h2 id="合并"><a class="markdownIt-Anchor" href="#合并"></a> 合并</h2><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">union</span>(<span class="hljs-params">a, b</span>) </span>&#123;    <span class="hljs-keyword">let</span> fa = findFather(a);    <span class="hljs-keyword">let</span> fb = findFather(b);    <span class="hljs-keyword">if</span> (fa !== fb) &#123;        father[fa] = fb; <span class="hljs-comment">// 将 a 接在 b 之下，即 b 作为 a 的父节点</span>    &#125; <span class="hljs-comment">// 否则，出现了环</span>&#125;</code></pre><h2 id="路径压缩"><a class="markdownIt-Anchor" href="#路径压缩"></a> 路径压缩</h2><p>若节点很多的情况下，并查集的&quot;高度&quot;会非常高，因此可以使用路径压缩，使所有结点与根节点直接相连。</p><img src="https://i.loli.net/2020/09/17/e6BDlnFxiovp9K1.png" alt="image-20200917164907651" style="zoom: 67%;" /><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findFather</span>(<span class="hljs-params">x</span>) </span>&#123;    <span class="hljs-keyword">let</span> tmp = x;    <span class="hljs-keyword">while</span> (x !== father[x]) &#123; <span class="hljs-comment">// 寻找根结点，根结点是父节点等于当前值的节点</span>        x = father[x];    &#125;        <span class="hljs-keyword">while</span> (tmp !== father[tmp]) &#123;        <span class="hljs-keyword">let</span> a = tmp;        tmp = father[tmp];        father[a] = x; <span class="hljs-comment">// 将原先节点的父节点直接改为根结点。</span>    &#125;        <span class="hljs-keyword">return</span> x; <span class="hljs-comment">// 返回根结点</span>&#125;<span class="hljs-comment">// 递归写法</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findFather</span>(<span class="hljs-params">x</span>) </span>&#123;    <span class="hljs-keyword">if</span> (x === father[x]) &#123;        <span class="hljs-keyword">return</span> x;    &#125;        <span class="hljs-keyword">let</span> r = findFather(father[x]);    father[x] = r;    <span class="hljs-keyword">return</span> r;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>算法知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>连通性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 685. 冗余连接 II</title>
    <link href="/2020/09/17/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/685-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5-II/"/>
    <url>/2020/09/17/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/685-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5-II/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/redundant-connection-ii/">https://leetcode-cn.com/problems/redundant-connection-ii/</a></p><p>难度：困难</p><hr /><p>  在本问题中，有根树指满足以下条件的有向图。该树只有一个根节点，所有其他节点都是该根节点的后继。每一个节点只有一个父节点，除了根节点没有父节点。</p><p>  输入一个有向图，该图由一个有着<code>N</code>个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在<code>1</code>到<code>N</code>中间，这条附加的边不属于树中已存在的边。</p><p>  结果图是一个以边组成的二维数组。 每一个边 的元素是一对 <code>[u, v]</code>，用以表示有向图中连接顶点 <code>u</code> 和顶点 <code>v</code> 的边，其中 <code>u</code> 是 <code>v</code> 的一个父节点。</p><p>  返回一条能删除的边，使得剩下的图是有<code>N</code>个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。</p><p><strong>简化题目：</strong> 根据给定的边集，求出一条多余的边，使得删除这条边后，图会变成一棵树，对于一些情况，这样的边会有多条，删除边集中出现的最后一条满足条件的边。</p><p><strong>示例 1:</strong></p><p>输入: <code>[[1,2], [1,3], [2,3]]</code></p><p>输出: <code>[2,3]</code></p><p>解释: 给定的有向图如下:</p><pre><code class="hljs angelscript">  <span class="hljs-number">1</span> / \v   v<span class="hljs-number">2</span>--&gt;<span class="hljs-number">3</span></code></pre><p><strong>示例 2:</strong></p><p>输入: <code>[[1,2], [2,3], [3,4], [4,1], [1,5]]</code></p><p>输出: <code>[4,1]</code></p><p>解释: 给定的有向图如下:</p><pre><code class="hljs angelscript"><span class="hljs-number">5</span> &lt;- <span class="hljs-number">1</span> -&gt; <span class="hljs-number">2</span>     ^    |     |    v     <span class="hljs-number">4</span> &lt;- <span class="hljs-number">3</span></code></pre><p><strong>注意:</strong></p><ul><li>二维数组大小的在<code>3</code>到<code>1000</code>范围内。</li><li>二维数组中的每个整数在<code>1</code>到<code>N</code>之间，其中 <code>N</code> 是二维数组的大小。</li></ul><h2 id="解法1并查集"><a class="markdownIt-Anchor" href="#解法1并查集"></a> 解法1：并查集</h2><p>思路来源：<a href="https://leetcode-cn.com/problems/redundant-connection-ii/comments/70573">Nu11Pointer</a></p><p>  对于一条能使一棵树变成图的边，它有以下几种情况：</p><ol><li><img src="https://i.loli.net/2020/09/17/OJIs4VDuBwAyxSd.png" alt="image-20200917170455420" style="zoom:80%;" />  <p>这条边从任意节点出发，指向了根结点，此时树形成了环，树也就没有根结点了（表现就是所有结点的入度都为 1），而这种情况下，处于这个环中的所有边都能被删除，因为删除任意一条边都能变成一棵正常的树，这也就是题目中提到的“多条边”的情况，但根据题目，需要删除边集中最后一条在环中的边。</p></li><li><img src="https://i.loli.net/2020/09/17/Cazh1PI3D4YecFn.png" alt="image-20200917170905916" style="zoom:80%;" />  <p>这条边从任意节点出发，指向了其祖先节点，树中形成了环，但仍有根结点，不过造成的后果就是有一个节点的入度变成 2了。这种情况下，只能删除环中的且造成 2 个入度的边，即图中橙色的边。</p></li><li><img src="https://i.loli.net/2020/09/17/qnpHve92sCIwOPW.png" alt="image-20200917171311259" style="zoom:80%;" /> <p>这条边从任意节点出发，指向了一个非祖先节点。这种情况下，有一个节点的入度会为 2，这两条造成入度为 2 的边都能删除，但根据题目，需要删除后出现的那条。</p></li></ol><p>  </p><p>  好了，既然清楚可能的几种情况，就需要想办法找到这些满足条件的边了。</p><p>  对于这种需要判断环的问题，可以考虑使用<a href="http://localhost:4000/2020/09/17/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/%E5%B9%B6%E6%9F%A5%E9%9B%86/">并查集</a>来做。在创建并查集的过程中，合并两个节点 <code>a</code> 和 <code>b</code> 时，若这两个节点有着公共的根结点，那么将它们合并的话就会出现环了。</p><p>  好的，首先，我们可以判断图中是否存在入度为 2 的节点，<strong>若存在</strong>，那么就是第 2 和第 3 种情况，将造成入度为 2 的这两条边（<code>edge1，edge2</code>）都先记录下来。</p><p>  然后创建并查集，我们跳过 <code>edge2</code> （<strong>后出现的边</strong>）这条边，若创建并查集的过程一路畅通（即未出现环），那么答案就是 <code>edge2</code>，也就是 <code>2.</code> 中删了正确的边（橙色的边）和 <code>3.</code> 中的情况 。</p><p>  而若创建并查集的过程中出现了环，那么对应的就是 <code>2.</code> 中删除了错误的边，那么答案就是 <code>edge1</code>。</p><p>  <strong>若不存在入度为 2 的节点</strong> ，那么就是 <code>1.</code> 中的情况了。此时，在创建并查集的过程中，记录那条造成环出现的边，这条边会是环中的边（废话），且会是边集中最后出现的满足条件的边，将其记录下来，作为答案返回。</p><p><strong>JS 代码：</strong></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> findRedundantDirectedConnection = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">edges</span>) </span>&#123;    <span class="hljs-keyword">let</span> inDegrees = [];    <span class="hljs-keyword">let</span> res = [];    <span class="hljs-keyword">let</span> meetCircle;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> edge <span class="hljs-keyword">of</span> edges) &#123;        <span class="hljs-keyword">let</span> node = edge[<span class="hljs-number">1</span>];        <span class="hljs-keyword">if</span> (!inDegrees[node]) &#123;            inDegrees[node] = edge;        &#125; <span class="hljs-keyword">else</span> &#123;            res.push(inDegrees[node]);            res.push(edge); <span class="hljs-comment">// 若找到入度为 2 的节点，将其中一条边记录下来</span>            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">let</span> father = [];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= edges.length; i++) &#123;        father[i] = i;    &#125;    <span class="hljs-keyword">const</span> findFather = <span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> &#123;        <span class="hljs-keyword">let</span> tmp = x;        <span class="hljs-keyword">while</span> (x !== father[x]) &#123;            x = father[x];        &#125;        <span class="hljs-keyword">let</span> a = tmp;        tmp = father[tmp];        father[a] = x;        <span class="hljs-keyword">return</span> x;    &#125;;    <span class="hljs-keyword">const</span> union = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;        <span class="hljs-keyword">let</span> fa = findFather(a);        <span class="hljs-keyword">let</span> fb = findFather(b);        <span class="hljs-keyword">if</span> (fa !== fb) &#123;            father[fb] = fa;        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 遇到了环</span>            meetCircle = [a, b];        &#125;    &#125;;    <span class="hljs-comment">// 建立并查集，若存在入度为 2 的节点，跳过后出现的边</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> edge <span class="hljs-keyword">of</span> edges) &#123;        <span class="hljs-keyword">if</span> (res.length &amp;&amp; res[<span class="hljs-number">1</span>] === edge) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        union(edge[<span class="hljs-number">0</span>], edge[<span class="hljs-number">1</span>]);    &#125;    <span class="hljs-comment">// 若没有入度为 2 的点，则说明冗余的边指向了根结点</span>    <span class="hljs-keyword">if</span> (res.length === <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> meetCircle;    &#125;    <span class="hljs-keyword">return</span> meetCircle ? res[<span class="hljs-number">0</span>] : res[<span class="hljs-number">1</span>];&#125;;</code></pre><p>  优化后的代码：只遍历了一次边集</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> findRedundantDirectedConnection = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">edges</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = [], father = [];    <span class="hljs-keyword">let</span> indegrees = [];    <span class="hljs-keyword">let</span> meetCircle;    <span class="hljs-keyword">const</span> findFather = <span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> &#123;        <span class="hljs-keyword">let</span> tmp = x;        <span class="hljs-keyword">while</span> (x !== father[x]) &#123;            x = father[x];        &#125;        <span class="hljs-keyword">let</span> a = tmp;        tmp = father[tmp];        father[a] = x;        <span class="hljs-keyword">return</span> x;    &#125;;    <span class="hljs-comment">// 创建并查集</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> edge <span class="hljs-keyword">of</span> edges) &#123;        <span class="hljs-keyword">let</span> node1 = edge[<span class="hljs-number">0</span>], node2 = edge[<span class="hljs-number">1</span>];        <span class="hljs-comment">// 初始化</span>        <span class="hljs-keyword">if</span> (!father[node1]) &#123;            father[node1] = node1;        &#125;        <span class="hljs-keyword">if</span> (!father[node2]) &#123;            father[node2] = node2;        &#125;        <span class="hljs-keyword">if</span> (indegrees[node2]) &#123; <span class="hljs-comment">// 若其入度已经为 1 了，则加上当前边入度就是 2了</span>            res.push([indegrees[node2], node2]);            res.push(edge);        &#125; <span class="hljs-keyword">else</span> &#123;            indegrees[node2] = node1;            <span class="hljs-keyword">let</span> f1 = findFather(node1);            <span class="hljs-keyword">let</span> f2 = findFather(node2);            <span class="hljs-keyword">if</span> (f1 !== f2) &#123;                father[f2] = f1;            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 遇到了环</span>                meetCircle = edge;            &#125;        &#125;    &#125;        <span class="hljs-comment">// 若没有入度为 2 的点，则说明冗余的边指向了根结点</span>    <span class="hljs-keyword">if</span> (res.length === <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> meetCircle;    &#125;    <span class="hljs-comment">// 否则，根据是否产生环输出答案</span>    <span class="hljs-keyword">return</span> meetCircle ? res[<span class="hljs-number">0</span>] : res[<span class="hljs-number">1</span>];&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>解答</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>并查集</tag>
      
      <tag>图</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Netlify部署博客</title>
    <link href="/2020/09/12/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E4%BD%BF%E7%94%A8Netlify%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/09/12/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E4%BD%BF%E7%94%A8Netlify%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>  原先博客是部署在 githubPages 上的，稍微设置一下就能实现自动化部署和启用 https，还是蛮方便的，但是使用国内网络访问 githubPages 上部署的网站速度太慢了，体验很差，因此，搜了下解决方案，发现了 <code>Netlify</code> 这个一站式自动化部署网站的平台，部署网站的过程很简单， githubPages 上的支持和不支持的功能 Netlify 上都有，最重要的是听说使用 Netlify 部署的网站，国内访问深度会比 githubPages 快多了。因此也捣鼓了一番，使用 Netlify 重新部署了网站。</p><p>  但是。。。部署完后使用国内网络访问网站，感觉访问速度没什么变化。。。去站长之家测试了下速度，唉</p><p><strong>我理想中的变化：</strong></p><img src="https://i.loli.net/2020/09/12/QFlGUA7px2aDmMN.png" alt="image-20200912114349985" style="zoom:80%;" /><p><strong>残酷的现实：</strong></p><p><img src="https://i.loli.net/2020/09/12/cUhBsSGPVHZkApW.png" alt="image-20200912114441879" style="zoom:40%;" /> <img src="https://i.loli.net/2020/09/12/aWpBJ7IDlcXvFCx.png" alt="image-20200912114518298" style="zoom:40%;" /></p><p>  总之记录一下部署的过程，不过可能还是会选用 githubPages 了，关于网站加速，后面再看了。</p><h2 id="github-项目部署"><a class="markdownIt-Anchor" href="#github-项目部署"></a> github 项目部署</h2><p>  首先，进入 <a href="https://app.netlify.com/teams/yleave/sites">Netlify</a> 官网，选择 github 账号登陆。</p><p>  然后点击创建新网站：</p><img src="https://i.loli.net/2020/09/12/UNgWzbrBpMFin7E.png" alt="image-20200912024233068" style="zoom:80%;" /><p>  选择 github</p><img src="https://i.loli.net/2020/09/12/KgbkJuPSoFNQaB8.png" alt="image-20200912024310535" style="zoom:80%;" /><p>  然后进入第二步，选择网站的项目仓库：</p><img src="https://i.loli.net/2020/09/12/PGQSKXUyLz2clhF.png" alt="image-20200912024635089" style="zoom:80%;" /><p>  然后选择部署的分支及打包命令与发布目录，我是使用了 hexo ，因此打包命令是 <code>hexo generate</code>：</p><img src="https://i.loli.net/2020/09/12/dvts5UECVeaTRgQ.png" alt="image-20200912024803284" style="zoom: 67%;" /><p>  点击 <code>Deploy</code> 按钮后，会自动进行部署，部署完成后，就能通过它给你的域名访问你的网站了：</p><img src="https://i.loli.net/2020/09/12/oQVNMXCEUmgnSey.png" alt="image-20200912025256424" style="zoom: 67%;" /><p>  网站名称默认会是一连串字符，可以在 <code>Site Setting</code> 里更改：</p><img src="https://i.loli.net/2020/09/12/gLuZcst8EAmrB5D.png" alt="image-20200912025420094" style="zoom:67%;" /><h2 id="自定义域名"><a class="markdownIt-Anchor" href="#自定义域名"></a> 自定义域名</h2><p>  Netify 的初始域名会是 <code>xxx.netify.app</code></p><p>  需要更改域名的话需要去申请域名，解析 DNS，有了之前的<a href="https://yleave.netlify.app/2020/09/11/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%B9%B6%E6%B7%BB%E5%8A%A0ssl/">经验</a> ，这步就很快了：</p><p>  首先使用 <a href="http://tool.chinaz.com/dns">dns查询工具</a> 查询网站的 ip：</p><img src="https://i.loli.net/2020/09/12/cD7wf495nxWISud.png" alt="image-20200912025833859" style="zoom:67%;" /><p>  然后去阿里云的 dns 解析平台解析这几条IP，并添加 <code>CNAME</code> 记录：</p><img src="https://i.loli.net/2020/09/12/9mdcMTJOi61vRGK.png" alt="image-20200912030148298" style="zoom:80%;" /><p>  操作完成后，回到 Neltify，点击 <code>Add custom domain</code> 添加你的域名：</p><img src="https://i.loli.net/2020/09/12/ftZqQe9b6z5Juxm.png" alt="image-20200912030601733" style="zoom:80%;" /><p>  然后是为网站添加 SSL，我<a href="https://www.yleave.top/2020/09/11/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%B9%B6%E6%B7%BB%E5%8A%A0ssl/#%E7%BB%99%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E6%B7%BB%E5%8A%A0-SSL">之前</a>已经申请过 SSL 证书了，因此点击添加证书按钮，将证书的内容上传：</p><img src="https://i.loli.net/2020/09/12/q1xW8fHOP6VXr2t.png" alt="image-20200912030811357" style="zoom:67%;" /><img src="https://i.loli.net/2020/09/12/5sAOkrjQXTwGNPZ.png" alt="image-20200912030928206" style="zoom: 67%;" /><p>  若没有申请过证书的话，Netlify 也提供了免费证书的发放服务：</p><p>  点击 <code>Let's Encrypt</code>，完成后如下：</p><img src="https://i.loli.net/2020/09/12/di6oRcH5FhTbsEQ.png" alt="image-20200912031035996" style="zoom: 67%;" /><p>  至此，使用 Netlify 自动部署博客步骤就全部完成了，之后添加新内容提交后， Netlify 会自动打包发布，非常方便:</p><img src="https://i.loli.net/2020/09/12/aVEbmrYw2MJtFQR.png" alt="image-20200912032343535" style="zoom: 80%;" /><hr /><p><strong>Ref:</strong></p><p><a href="https://www.cnblogs.com/37Y37/p/12551839.html">https://www.cnblogs.com/37Y37/p/12551839.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/77651304">https://zhuanlan.zhihu.com/p/77651304</a></p>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netlify</tag>
      
      <tag>自动化部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自定义域名并添加SSL</title>
    <link href="/2020/09/11/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%B9%B6%E6%B7%BB%E5%8A%A0SSL/"/>
    <url>/2020/09/11/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%B9%B6%E6%B7%BB%E5%8A%A0SSL/</url>
    
    <content type="html"><![CDATA[<p>  本博客是部署在 Github Pages 上的，因此访问时域名为： <code>yleave.github.io</code> ，不过还是感觉太长了，于是乎捣鼓了两天，给博客加了个域名并添加了SSL证书，下面记录了一些捣鼓经验。</p><h1 id="自定义域名"><a class="markdownIt-Anchor" href="#自定义域名"></a> 自定义域名</h1><p>  前置条件：一个已部署在 github 上的博客</p><p>  首先，需要注册一个域名，我是在<a href="https://wanwang.aliyun.com/domain/?spm=5176.100251.111252.21.72014f15uvzIEz">阿里云</a>上注册的，首年 9 元，续费 27 元，价格还可以接受，步骤也不麻烦。</p><p>  第一次注册的需要实名认证，而名认证审核时间大概半天就能完成。</p><h2 id="域名解析"><a class="markdownIt-Anchor" href="#域名解析"></a> 域名解析</h2><p>  域名注册完成后，进入解析页面，点击添加记录：</p><img src="https://i.loli.net/2020/09/11/izd5jS7e2TVDgM4.png" alt="image-20200911163555583" style="zoom:80%;" /><p>  先获取你的博客 IP 地址，可以使用命令行窗口 <code>ping</code> 一下：<code>ping name.github.io</code>  :</p><img src="https://i.loli.net/2020/09/11/dUDfhNnM5B6xTtL.png" alt="image-20200911163939089" style="zoom:80%;" /><p>  或是去<a href="http://tool.chinaz.com/dns">网站</a>查一下：</p><img src="https://i.loli.net/2020/09/11/rp169ZtWCVNwMfD.png" alt="image-20200911164127950" style="zoom:80%;" /><p>  这几个其实都是 github 的 IP 地址，应该所有在 github 上部署的博客都是这几个地址。</p><p>  可以只选择一个 ip 进行解析，不过我这边将这四个地址都解析了：</p><img src="https://i.loli.net/2020/09/11/iTPvBhr7J8nEmV4.png" alt="image-20200911164331299" style="zoom: 67%;" /><img src="https://i.loli.net/2020/09/11/PGYWM2OEjw7ycRk.png" alt="image-20200911164419343" style="zoom:80%;" /><p>  然后解析一个 <code>CNAME</code> 类型的记录：</p><img src="https://i.loli.net/2020/09/11/zbDgrJtNh7d2uKL.png" alt="image-20200911164528656" style="zoom: 67%;" /><p>  最后，在博客所在项目的 <code>source</code> 文件夹下新建一个 <code>CNAME</code> 文件，写入申请的域名：</p><img src="https://i.loli.net/2020/09/11/buEdOwZFxce8jQz.png" alt="image-20200911164738664" style="zoom:80%;" /><p>  不过这一步不知道它的作用是什么，但看其他教程都有这步，就加上去吧。</p><p>  到这里，域名解析步骤就完成了。</p><h2 id="github-绑定"><a class="markdownIt-Anchor" href="#github-绑定"></a> github 绑定</h2><p>  这个步骤中将解析的域名与 github 上的博客项目绑定起来。</p><p>  先进入博客项目的 <code>Settings</code> 中：</p><img src="https://i.loli.net/2020/09/11/rEj2z1pJh76ctsg.png" alt="image-20200911165059055" style="zoom:80%;" /><p>  拉到底部，在 <code>Custom domain</code> 栏中填入申请的域名：</p><img src="https://i.loli.net/2020/09/11/3c5nN9RMHSADZbX.png" alt="image-20200911165140522" style="zoom:67%;" /><p>  到这一步，自定义域名的步骤就完成了，但由于我是第一次注册，还需等待实名认证完成，审核完成后就能通过 <code>www.yleave.top</code> 和 <code>yleave.top</code> 访问了。</p><img src="https://i.loli.net/2020/09/11/tSsPnkwdz59qO4F.png" alt="image-20200911165328548" style="zoom:80%;" /><h1 id="给博客网站添加-ssl"><a class="markdownIt-Anchor" href="#给博客网站添加-ssl"></a> 给博客网站添加 SSL</h1><img src="https://i.loli.net/2020/09/11/WX46dDuBK8OvMig.png" alt="image-20200911165528080" style="zoom:80%;" /><p>  关于 SSL 和 HTTPS 的介绍这里就不说明了，这篇<a href="https://yq.aliyun.com/articles/721195">文章</a>有一些简介可以看看。</p><h2 id="申请免费ssl证书"><a class="markdownIt-Anchor" href="#申请免费ssl证书"></a> 申请免费SSL证书</h2><p>  证书这边我是在 <a href="https://console.qcloud.com/ssl">腾讯云</a>申请免费的 SSL 证书，不过只有一年免费时间。</p><img src="https://i.loli.net/2020/09/11/qwMHnYxtACdPuiW.png" alt="image-20200911170245686" style="zoom:80%;" /><p>  阿里云应该也能申请，不过我没找到，因此去腾讯云申请了，但是证书申请和域名申请不在同一个网站的话，后面上传证书时会稍微麻烦一些，不过也还好。</p><p>  申请步骤很简单，只需要填写一个表格并实名认证就行。</p><img src="https://i.loli.net/2020/09/11/QWJShizDbOuTClr.png" alt="image-20200911170359563" style="zoom:80%;" /><p>  申请完成后需要进行 DNS 验证：</p><img src="https://i.loli.net/2020/09/11/IQqkwEmhx62lcav.png" alt="image-20200911171152620" style="zoom:80%;" /><p>  因此再回到阿里云的 DNS 解析页面，将上表中出现的字段填入解析记录中：</p><img src="https://i.loli.net/2020/09/11/QGcaB6q4i9dOPVL.png" alt="image-20200911171242463" style="zoom:80%;" /><p>然后，等待<a href="https://console.cloud.tencent.com/ssl/detail/gLRDXe3L">腾讯云</a>那边的 DNS 验证</p><img src="https://i.loli.net/2020/09/11/YrRZfFmPxEBCqze.png" alt="image-20200911171319884" style="zoom:80%;" /><p>  过了大概五分钟，腾讯云发来短信，提示 DNS 解析成功。</p><img src="https://i.loli.net/2020/09/11/7MBHXatQUG5Z4A6.png" alt="image-20200911171410380" style="zoom:67%;" /><p>  证书下载下来是一个压缩包，里面是这样子的，我估摸着是不同代理的证书：</p><img src="https://i.loli.net/2020/09/11/X6adrQ8wRF79fU2.png" alt="image-20200911171553060" style="zoom:80%;" /><h2 id="上传ssl证书"><a class="markdownIt-Anchor" href="#上传ssl证书"></a> 上传SSL证书</h2><p>  在腾讯云上申请完 SSL 证书后，需要将其上传到域名申请的地方，也就是阿里云的<a href="https://yundunnext.console.aliyun.com/?p=casnext#/overview/cn-hangzhou">证书管理中心</a>：</p><img src="https://i.loli.net/2020/09/11/e8iPSIDBodCVhlq.png" alt="image-20200911171741501" style="zoom:80%;" /><p>  证书名称可以随便填，证书文件就是 <code>.crt</code> 的文件中的内容，一个证书文件对应了一个私钥，如 Apache 目录下， <code>_www.yleave.top.crt</code> 就是证书文件，<code>.key</code> 就是私钥，填入这两个就好了：</p><img src="https://i.loli.net/2020/09/11/8Ns2I6nyMZFhrAK.png" alt="image-20200911171826131" style="zoom:80%;" /><img src="https://i.loli.net/2020/09/11/DvlAJ6pV9KyXGdf.png" alt="image-20200911171859459" style="zoom:80%;" /><p>  我这边先是上传了两个证书：</p><p><img src="https://i.loli.net/2020/09/11/KFQq7to6xyhvfXC.png" alt="image-20200911171934657" /></p><p>  上传完后点击部署按钮：</p><img src="https://i.loli.net/2020/09/11/eJ1HLE5PRY3mhqO.png" alt="image-20200911172010043" style="zoom:80%;" /><p>  全选，点击部署：</p><img src="https://i.loli.net/2020/09/11/rgBiSMDbJIOoNtp.png" alt="image-20200911172049141" style="zoom: 80%;" /><p>  不过刚部署完后访问网站还是 <code>http</code> 类型的，当时感觉是不是自己哪错了（后来发现应该是要等一会儿才能生效），于是看<a href="https://www.cnblogs.com/sslwork/p/5984167.html">一个博文</a> 里说还需要部署中间证书，于是按照上面的方法又上传部署了一个带中间证书内容的证书，但刚部署完仍未生效。</p><p>  不过过了一会儿，正当我沮丧找其他博文参考时，又访问了一下发现证书好像生效了：</p><img src="https://i.loli.net/2020/09/11/LlnEkSad2G4eMVP.png" alt="image-20200911172535154" style="zoom:80%;" /><p>  最后，在浏览其他博文时，发现 github 上还有一个 <code>Enforce HTTPS</code> 选项，暂时不清楚作用，总之先勾选上：</p><img src="https://i.loli.net/2020/09/11/MWEApjaytkvcVCT.png" alt="image-20200911172829156" style="zoom:67%;" /><p>  捣鼓了两天，虽然过程中对一些步骤的作用还不太清楚，但最后成功完成，时间还是没白费的</p>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自定义域名</tag>
      
      <tag>SSL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Python 编写 MapReduce -- Hadoop Streaming</title>
    <link href="/2020/08/18/%E5%A4%A7%E6%95%B0%E6%8D%AE/hadoop%20streaming/"/>
    <url>/2020/08/18/%E5%A4%A7%E6%95%B0%E6%8D%AE/hadoop%20streaming/</url>
    
    <content type="html"><![CDATA[<p>要使用其他语言编写 MR 任务，首先要了解一下 Hadoop Streaming</p><h2 id="hadoop-streaming-简介"><a class="markdownIt-Anchor" href="#hadoop-streaming-简介"></a> hadoop streaming 简介</h2><p>  Hadoop streaming 是 Hadoop的一个工具， 它帮助用户创建和运行一类特殊的 map/reduce 作业， 这些特殊的map/reduce 作业是由一些可执行文件或脚本文件充当 mapper 或者 reducer。</p><p>  也就是 hadoop streaming 可以帮助我们使用其他语言（非 java) 来编写 mapper 和 reducer。</p><p><strong>下面使用 python 来编写 MR 脚本</strong></p><h2 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> 工作原理</h2><p>  在 hadoop streaming 中，mapper 和 reducer 都是可执行文件，它们从标准输入流读取数据，使用标准输出流输出数据。</p><p>  在 python 中就是：<code>sys.stdin</code> 和 <code>print</code></p><p>  mapper 和 reducer 会一行一行的读取数据，根据分隔符（默认为 <code>tab</code>）将读入的数据切分为 <code>key</code> 和 <code>value</code>，同时，输出的数据也需要是一个 <code>key,value</code> 对，在第一个 <code>tab</code> 分隔符前的会被认为是 <code>key</code>，后面的都作为 <code>value</code>。</p><p>  如，输出时 <code>print(&quot;%s\t%s&quot;, %(key, value))</code></p><h2 id="mr-编写示例"><a class="markdownIt-Anchor" href="#mr-编写示例"></a> MR 编写示例</h2><p>  假设有数据如下，下面编写 MR 实现 “倒排”。</p><pre><code class="hljs scheme"><span class="hljs-number">1</span><span class="hljs-symbol">&#x27;bread</span>&#x27; <span class="hljs-symbol">&#x27;milk</span>&#x27; <span class="hljs-symbol">&#x27;vegetable</span>&#x27; <span class="hljs-symbol">&#x27;fruit</span>&#x27; <span class="hljs-symbol">&#x27;eggs</span>&#x27;<span class="hljs-number">2</span><span class="hljs-symbol">&#x27;noodle</span>&#x27; <span class="hljs-symbol">&#x27;beef</span>&#x27; <span class="hljs-symbol">&#x27;pork</span>&#x27; <span class="hljs-symbol">&#x27;water</span>&#x27; <span class="hljs-symbol">&#x27;socks</span>&#x27; <span class="hljs-symbol">&#x27;gloves</span>&#x27; <span class="hljs-symbol">&#x27;shoes</span>&#x27; <span class="hljs-symbol">&#x27;rice</span>&#x27;<span class="hljs-number">3</span><span class="hljs-symbol">&#x27;socks</span>&#x27; <span class="hljs-symbol">&#x27;gloves</span>&#x27;<span class="hljs-number">4</span><span class="hljs-symbol">&#x27;bread</span>&#x27; <span class="hljs-symbol">&#x27;milk</span>&#x27; <span class="hljs-symbol">&#x27;shoes</span>&#x27; <span class="hljs-symbol">&#x27;socks</span>&#x27; <span class="hljs-symbol">&#x27;eggs</span>&#x27;<span class="hljs-number">5</span><span class="hljs-symbol">&#x27;socks</span>&#x27; <span class="hljs-symbol">&#x27;shoes</span>&#x27; <span class="hljs-symbol">&#x27;sweater</span>&#x27; <span class="hljs-symbol">&#x27;cap</span>&#x27; <span class="hljs-symbol">&#x27;milk</span>&#x27; <span class="hljs-symbol">&#x27;vegetable</span>&#x27; <span class="hljs-symbol">&#x27;gloves</span>&#x27;<span class="hljs-number">6</span><span class="hljs-symbol">&#x27;eggs</span>&#x27; <span class="hljs-symbol">&#x27;bread</span>&#x27; <span class="hljs-symbol">&#x27;milk</span>&#x27; <span class="hljs-symbol">&#x27;fish</span>&#x27; <span class="hljs-symbol">&#x27;crab</span>&#x27; <span class="hljs-symbol">&#x27;shrimp</span>&#x27; <span class="hljs-symbol">&#x27;rice</span>&#x27;</code></pre><p>  所谓 “倒排” 就是将数据中的每一个字符 <code>word</code> 与其前面的编号 <code>num</code> 对应起来，如 <code>bread</code>，它在编号 <code>1</code>、<code>4</code>、<code>6</code> 中都有出现，因此 倒排 的结果就是：<code>bread 1 4 6</code>。</p><p>  首先，编写一个 <code>mapper</code> 来将数据拆分为一个个的 <code>word, num</code> 对：</p><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment"># coding=utf-8</span><span class="hljs-keyword">import</span> sys<span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> sys.stdin:    line = line.strip()    words = line.split()    num = words[<span class="hljs-number">0</span>]    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(words)):        word = words[i]        print(<span class="hljs-string">&#x27;%s\t%s&#x27;</span> % (word, num))</code></pre><p>  接着，编写 <code>reducer</code>，将同一个 <code>word</code> 的所属编号收集到一起：</p><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><span class="hljs-comment">#coding:utf-8</span><span class="hljs-keyword">import</span> sysoutput = &#123;&#125;curWord = <span class="hljs-string">&#x27;&#x27;</span>wordCount = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> sys.stdin:    line = line.strip()    word,tid = line.split()    <span class="hljs-keyword">if</span> output.get(word) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:        output[word] = []    output[word].append(tid)    <span class="hljs-keyword">if</span> curWord == <span class="hljs-string">&#x27;&#x27;</span>:        curWord = word    <span class="hljs-keyword">if</span> curWord == word:        wordCount += <span class="hljs-number">1</span>    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">if</span> wordCount &gt;= <span class="hljs-number">3</span>: <span class="hljs-comment"># 若一个单词对应的编号数量不少于 3，则输出</span>            print(<span class="hljs-string">&#x27;%s\t%r&#x27;</span> % (curWord, output[curWord]))        wordCount = <span class="hljs-number">1</span>        curWord = word</code></pre><h2 id="执行-mr-脚本"><a class="markdownIt-Anchor" href="#执行-mr-脚本"></a> 执行 MR 脚本</h2><p>  通常执行 MR 脚本需要在 hadoop 系统上工作，但是为了防止出错， <code>mapper</code> 脚本可以在本地测试，而 <code>reducer</code> 脚本通常涉及排序，在本地测试可能会得到错误结果。</p><h3 id="本地测试"><a class="markdownIt-Anchor" href="#本地测试"></a> 本地测试</h3><p>  在当前路径下有 <code>t1.txt</code> 存放数据，<code>mapper/mapper1.py</code> 为 mapper 脚本，在 <code>shell</code> 上运行命令：</p><p><code>cat t1.txt | python mapper/mapper1.py</code> ，这样 mapper 运行的结果就会打印在屏幕上了，若想要输出到文件中，可以使用 <code>&gt;</code> ，即 <code>cat t1.txt | python mapper/mapper1.py &gt; out1.txt</code></p><img src="https://i.loli.net/2020/09/11/iXvlZ6Tx2MoReJs.png" alt="image-20200828222203501" style="zoom:80%;" /><p>  若想要读取一个文件夹下的所有文件的话，则改为：<code>cat data/*.txt | python mapper/mapper1.py</code></p><h3 id="分布式系统上执行"><a class="markdownIt-Anchor" href="#分布式系统上执行"></a> 分布式系统上执行</h3><p>  首先，将数据上传到 HDFS 的 <code>/pj</code> 目录下：<code>hadoop fs -put t1.txt /pj</code></p><p>  然后使用 hadoop streaming 执行 MapReduce，hadoop streaming 需要提供一些设置参数，可以在命令行中直接输入，也可以编写 <code>shell</code> 脚本来执行（推荐）</p><p>  来看 <code>shell</code> 脚本的编写，文件命名后缀是 <code>.sh</code></p><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span>hadoop jar /usr/<span class="hljs-built_in">local</span>/hadoop/share/hadoop/tools/lib/hadoop-streaming-2.7.7.jar \-jobconf mapreduce.reduce.shuffle.memory.limit.percent=0.1 \-jobconf mapreduce.reduce.shuffle.input.buffer.percent=0.3 \-jobconf mapreduce.map.memory.mb=512 \-jobconf mapreduce.reduce.memory.mb=512 \-jobconf mapred.map.capacity=100 \-jobconf mapred.reduce.capacity=100 \-jobconf mapred.job.name=reverse_sort \-file mapper/mapper1.py -mapper mapper/mapper1.py  \-file reducer/reducer1.py -reducer reducer/reducer1.py  \-input /pj/t1.txt -output /pj/output/</code></pre><p>  简单说明一下这个 <code>shell</code> 脚本：</p><p>  第一行 <code>#!/bin/bash</code> 说明这个是一个 <code>shell</code> 脚本</p><p>  第二行中的 <code>hadoop-streaming-2.7.7.jar</code> jar 包路径是在自己安装 hadoop 的路径下，应该都会有的</p><p>  再下面，<code>-jobconfig</code> 的那些参数根据自己的需要来设置，具体可以参照<a href="https://cwiki.apache.org/confluence/display/HADOOP2/JobConfFile">官网</a> 和这篇<a href="https://www.jianshu.com/p/1b69df99d949">博客</a>的介绍</p><p>  而 <code>file</code>、<code>mapper</code>、<code>reducer</code>、<code>input</code> 和 <code>output</code> 是必须的。</p><p>  其中 <code>file</code> 选项是让f ramework 把可执行文件作为作业的一部分，一起打包提交。</p><p>  接下来，运行这个 <code>shell</code> 脚本，假设这个 <code>shell</code> 脚本的文件名是 <code>run.sh</code>。</p><p>  <code>shell</code> 脚本有三种运行方式：</p><ol><li><p>先输入 <code>chmod +x run.sh</code> 赋予可执行权限，然后在命令行中输入 <code>./run.sh</code> 即可运行</p><img src="https://i.loli.net/2020/09/11/1SlUOAciyk4GLhK.png" alt="image-20200828224508743" style="zoom:80%;" /></li><li><p>使用 <code>sh run.sh</code> 运行</p></li><li><p>使用 <code>source run.sh</code> 运行</p></li></ol><p>  脚本若正确执行完毕，拉取 HDFS 上的结果：<code>hadoop fs -get /pj/output</code></p>   <img src="https://i.loli.net/2020/09/11/kIN7CSXZxvsniMp.png" alt="image-20200828224740795" style="zoom:80%;" /><p>  顺便一提，若不是使用编写 <code>shell</code> 脚本的方式运行，则上面的 hadoop streaming 运行方式为：</p><img src="https://i.loli.net/2020/09/11/G4fhzH6aeVMjX8E.png" alt="image-20200828225015917" style="zoom:80%;" /><p>  即将脚本里的内容全写在命令行中。</p><h2 id="关于-hadoop-streaming-配置的一些参考学习文章"><a class="markdownIt-Anchor" href="#关于-hadoop-streaming-配置的一些参考学习文章"></a> 关于 hadoop streaming 配置的一些参考学习文章</h2><p><a href="http://hadoop.apache.org/docs/r1.0.4/cn/streaming.html">Hadoop Streaming</a></p><p><a href="https://help.aliyun.com/document_detail/44024.html?spm=a2c4g.11186623.6.914.162d19d6A0ZelV">阿里云Hadoop Streaming</a></p><p><a href="https://www.cnblogs.com/shay-zhangjin/p/7714868.html">Hadoop Streaming详解</a></p><p><a href="https://blog.csdn.net/Alanyungz/article/details/106767668">Hadoop Streaming介绍与实战</a></p><p><a href="https://cwiki.apache.org/confluence/display/HADOOP2/JobConfFile">JobConfFile</a></p><p><a href="http://www.uml.org.cn/zjjs/201205303.asp">hadoop作业调优参数整理及原理</a></p><p><a href="https://blog.csdn.net/loveblair1990/article/details/53608293">hadoop streaming参数配置</a></p><p><a href="https://www.jianshu.com/p/1b69df99d949">Hadoop-Streaming参考一</a></p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
      <category>hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>big data</tag>
      
      <tag>hadoop streaming</tag>
      
      <tag>MapReduce</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>写在前面</title>
    <link href="/2020/08/17/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/"/>
    <url>/2020/08/17/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<p>  2019 初，我开始了我的第一篇博客，说是写作，但更多的是 「做笔记」「转载」 等没有深度的文章。</p><p>  开始是在 <a href="https://blog.csdn.net/qq_38701868">CSDN</a> 上写博客，一些不想让别人看的笔记就使用有道云笔记写。慢慢的，看着一些大牛的博客，感觉他们的文章有深度、有干货，也有自己的理解，再看看我的 “博客”，大多是知识积累笔记，而对于一些知识点的理解并不是很透彻，即怕误导别人又怕被别人吐槽…发布博客的激情也就逐渐淡下来了。越来越多的笔记选择在本地的有道云笔记上记录而不是再发布到 CSDN 上，最终，零零散散的发了快一年的博客后，我停止了 CSDN 上的 “写作”。</p><p>  后来，面向浏览器编程的我，看了许多大佬的博客和他们炫酷的博客网站后，萌生了搭网站写博客的想法，也想着能在搭博客的过程中学习一些 Web 知识，不过由于对自己文章的信心不足，这个想法也因此搁置了很久，直到一次逛B站时看到了 <strong>Up 主 CodeSheep</strong>  的 <a href="https://www.bilibili.com/video/BV1Px411d74c">为什么程序员必须写技术博客?..</a> 这个视频后再次激起了我搭建自己的博客网站并再次开始发布博客的想法。</p><p>  视频中分享了自己写博客的感想，以及写博客的重要性和必要性，但对我说服力最大的还是视频中提到的<strong>写博客误区</strong>，以及对这个误区的纠正:</p><blockquote><p>  <strong>误区一</strong>：初学者写博客没技术含量怎么办（感同身受</p><p>  <strong>误区二</strong>：初学者写博客会不会被喷</p><p>​  对于误区二，虽然只是不到一年的写博客经历，但基本上没遇到喷我博客的人（可能是我博客的流量太小hh），并且偶尔有一些感谢的留言和点赞还是会有点小开心的~</p></blockquote><p>  诚然，写博客能够在以后找工作，面试时加分，不过正如视频里所说，写博客更重要的是能够在写作过程中锻炼自己的语言表达和知识总结能力。知识需要沉淀，每学的一些知识，每做的一件事，都需要总结、输出，学习过的内容能够用自己的话说出来，能够有自己的理解，才能说你学过了这个知识。这点我在做笔记、写博客时有些体会，需要将学习的知识整理、凝练一番，在写博客的过程中才能有一个比较清晰的思路，写完后立马再回顾一下会感觉对这个知识点有着更加清晰的理解。</p><p>  即使是一个小的技术点、一个小的 idea，甚至一些简单的笔记，都可以写到博客中，我相信积累的力量。</p><p>  就这样，我再次开始了我的写博客之旅，或许博客内容会有些青涩，有些错误，请见谅~</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
