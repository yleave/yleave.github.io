---
title: 原型和原型链
index_img: 'https://cdn.jsdelivr.net/gh/yleave/imagehost/index_img/js.jpg'
banner_img: 'https://cdn.jsdelivr.net/gh/yleave/imagehost/banner_img/44.png'
date: 2021-01-08 14:53:08
categories:
    - JS
    - 原型和原型链
tags:
    - 原型
---



&emsp;&emsp;首先，在 JS 中可以使用类或构造函数来创建一个实例：

```js
function Person() {}
// or
class Person {}

Person.prototype.name = 'Kevin';

let p1 = new Person();
let p2 = new Person();
// p1.name === p2.name = 'Kevin';
```

## prototype

&emsp;&emsp;每个函数/类都有一个 `prototype` 属性，它指向了一个对象，这个对象就是我们调用这个构造函数/类而创建的实例的原型，即上面代码中 `p1` 和 `p2` 的原型。

&emsp;&emsp;而**原型**可以这样理解：**每一个 JS 对象（null除外）在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型中 “继承” 属性**。



&emsp;&emsp;用一张图来表示构造函数和实例原型之间的关系：

<img src="https://cdn.jsdelivr.net/gh/yleave/imagehost@master/img/prototype1.png" alt="构造函数和实例原型的关系图" style="zoom:80%;" />

## `__proto__`

&emsp;&emsp;每一个 JS 对象（除了 null）都具有 `__proto__` 这个属性，它指向该对象的原型。

如：

```js
p1.__proto__ === Person.prototype;

let n = 3;
n.__proto__ === Number.prototype;
```

&emsp;&emsp;因此关系图更新为：

<img src="https://cdn.jsdelivr.net/gh/yleave/imagehost@master/img/prototype2.png" alt="实例与实例原型的关系图" style="zoom:80%;" />

&emsp;&emsp;除了可以使用 `__proto_` 属性来获取实例的原型之外，还能使用 `Object.getPrototypeOf(p1)` （ES5 的方法）来获取对象原型：

```js
Object.getPrototypeOf(p1) === Person.prototype;
```



## constructor

&emsp;&emsp;每个原型都有一个 `constructor` 属性来指向与其关联的构造函数/类。

如：

```js
Person.prototype.constructor === Person;

Number.prototype.constructor === Number;
```

&emsp;&emsp;因此再次更新关系图：

<img src="https://cdn.jsdelivr.net/gh/yleave/imagehost@master/img/prototype3.png" alt="实例原型与构造函数的关系图" style="zoom:80%;" />

## 原型的原型

&emsp;&emsp;前面原型理解中有提到，**原型也是一个对象**，因此我们可以使用最原始的方式创建它：

```js
let obj = new Object();
```

&emsp;&emsp;其实原型对象也就是通过 `Object` 构造函数生成的，因此原型对象的 `__proto__` 属性会指向构造函数的 `prototype` ，也就是：

```js
p1.__proto__.__proto__ === Object.prototype;
// 即
Person.prototype.__proto__ === Object.prototype;
```



&emsp;&emsp;那么 `Object.prototype` 的原型是什么呢？

&emsp;&emsp;答案是 `null`：`Object.prototype.__proto__ === null`

&emsp;&emsp;代表了原型链的尽头。

&emsp;&emsp;因此关系图可以更新为：其中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。

<img src="https://cdn.jsdelivr.net/gh/yleave/imagehost@master/img/prototype5.png" alt="原型链示意图" style="zoom:80%;" />

## 实例与原型链

&emsp;&emsp;当读取实例的属性时，如果找不到，就会查找与其相关的原型中的属性，如果还找不到，就会去找原型的原型，直到最顶层的 `null` 为止。

如：

```js
Object.prototype.name = 'End';

function Person() {}
Person.prototype.name = 'Kevin';

let p = new Person();
p.name = 'Daisy';

// 首先会在当前对象中查找
console.log(p.name); // Daisy

// 若找不到，则去与其关联的原型中查找
delete p.name;
console.log(p.name); // Kevin

// 若其原型中也没有，则去原型的原型中查找
delete Person.prototype.name;
console.log(p.name); // End
```



## 补充

### constructor

&emsp;&emsp;先看个例子：

```js
function Person() {}

let person = new Person();
person.constructor === Person; //true
```

&emsp;&emsp;根据我们前面的描述，`constructor` 是 `person` 对象的原型中的属性，`person` 中并没有这个属性；但当我们获取 `person.constructor` 时，会从 `person` 的原型中读取，而原型中正好有这个属性，因此还是能够正确读取。

&emsp;&emsp;因此：

```js
person.constructor === Person.prototype.constructor;
```

### `__proto__`

&emsp;&emsp;绝大部分浏览器都支持这个非标准的方法来访问原型，然而它并不存在于 `Person.prototype` 中，**实际上，它是来自于 `Object.prototype`**，与其说是一个属性，不如说是一个 `getter/setter`，当使用 `obj.__proto__` 时，可以理解为返回了 `Object.getPrototypeOf(obj)`。

### 属性 “继承”

&emsp;&emsp;前面有说到，每一个对象都会从原型中 “继承” 属性。实际上，继承是一个比较迷惑的说法，在 《你不知道的 JS》 中有这样一段话：

> 继承意味着复制操作，然而 JS 默认并不会复制对象中的属性，相反，JS 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数。
>
> 所以与其叫继承，**委托**的说法反而更准确些。



---

REF：

https://github.com/mqyqingfeng/Blog/issues/2