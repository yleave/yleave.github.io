---
title: 知识点杂记
index_img: 'https://cdn.jsdelivr.net/gh/yleave/imagehost/index_img/86.jpg'
banner_img: 'https://cdn.jsdelivr.net/gh/yleave/imagehost/banner_img/78.jpg'
date: 2020-12-09 19:22:39
categories:
    - JS
tags:
    - JS
---



# 闭包





# this 指向

REF: [MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this)


函数的调用方式决定了 `this` 的值（**运行时绑定**）。

ES5 引入了 `bind` 方法来设置函数的 `this` 的值，ES2015 引入了箭头函数，箭头函数不提供自身的 `this` 绑定，`this` 的值将保持为闭合词法上下文的值。



可以使用 `globalThis` 来获取全局对象，无论代码是否在当前上下文中运行。



## 函数上下文

在函数内部，`this`的值取决于函数被调用的方式。



在严格模式下，如果进入执行环境时没有设置 `this` 的值，`this` 会保持为 `undefined`，如：

```js
function f2() {
    "use strict";
    return this;
}

f2() === undefined; // true

function f1() {
    return this;
}

f1() === window; // 在浏览器中，全局对象是 window

f1() === globalThis; // 在 Node 中
```



## 类上下文

`this` 在 [类](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes) 中的表现与在函数中类似，因为类本质上也是函数。



在类的构造器中， `this` 是一个常规对象。类中所有非静态的方法都会被添加到 `this` 的原型中：

```js
class Example {
    constructor() {
        const proto = Object.getPrototypeOf(this);
        console.log(Object.getOwnPropertyNames(proto));
    }
    first() {}
    second() {}
    static third() {}
}

new Example(); // ['constructor', 'first', 'second']
```



## 箭头函数

在箭头函数中，`this` 与封闭词法环境的 `this` 保持一致，且一旦设置，就不会被 `call`、`bind`、`apply` 等方法修改。

如：

```js
function foo1() {
    return this;
}

let foo2 = () => this;

let obj = {foo1: foo1, foo2: foo2};

//foo1 返回的 this 为 obj，foo2 返回的 this 为全局对象，因为函数是根据执行的对象来绑定 this 的，而箭头函数是创建的时候就绑定了上下文环境
console.log(obj.foo1(), obj.foo2());
```



```js
// obj 对象中有一个 foo 方法，这个方法中使用了箭头函数返回了一个 this
// 因此箭头函数返回的这个 this 被绑定到了外层函数的 this
// 而 foo 的值可以在调用中设置，进而设置返回的 this
let obj = {
    foo: function() {
        let x = () => this;
        return x;
    }
}

// 作为 obj 对象的一个方法来调用，它的 this 会绑定到 obj 上
let fn = obj.foo(); // fn === obj

// 但是，若只是引用 obj 方法，没有调用它
let fn2 = obj.foo;

// 那么调用箭头函数后，this 指向 window，因为它从 foo 继承了this。
fn2() === window; // true
```



## 作为构造函数

当一个函数用作构造函数时（使用 `new` 关键字），它的 `this` 被绑定到正在构造的新对象。



## 作为一个 DOM 事件处理函数

当函数被用作事件处理函数时，它的 `this` 指向触发事件的元素。



## 作为一个内联事件处理函数

当代码被内联 [on-event 处理函数](https://developer.mozilla.org/zh-CN/docs/Web/Guide/Events/Event_handlers) 调用时，它的`this`指向监听器所在的DOM元素：

```js
<button onclick="alert(this.tagName.toLowerCase());">
  Show this
</button>
```

上面的 alert 会显示 `button`。

注意只有外层代码中的 `this` 是这样设置的：

```js
<button onclick="alert((function(){return this})());">
  Show inner this
</button>
```

在这种情况下，没有设置内部函数的 `this`，所以它指向` global/window` 对象（即非严格模式下调用的函数未设置 `this` 时指向的默认对象）。

这种情况下，若想要正确设置 `this`，可以使用 `bind` ：

```js
<button onclick="alert((function(){return this}).bind(this)());">
    Show inner this
</button>
```





















