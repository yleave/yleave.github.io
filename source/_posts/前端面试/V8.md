---
title: 运行环境
index_img: 'https://gitee.com/ylea/imagehost/raw/master/index_img/v8.jpg'
banner_img: 'https://gitee.com/ylea/imagehost/raw/master/banner_img/2.jpg'
date: 2020-12-20 11:39:07
categories:
    - 前端面试题
tags:
    - V8
---



# V8 执行 JS 大致流程

&emsp;&emsp;编程语言有两种类别：静态类型和动态类型。

&emsp;&emsp;**静态类型语言**如 C++、GO 等，需要提前编译（AOT）成机器码然后执行，这个过程主要使用**编译器**来完成。

&emsp;&emsp;**动态类型语言**如 JS、Python 等，只在运行时进行编译执行（JIT），这个过程通过**解释器**来完成。



&emsp;&emsp;而 V8 采用了混合编译执行和解释执行的方式，我们称为 **JIT**（Just-In-Time-Compilation）

&emsp;&emsp;这是一种权衡策略，因为这两种方法都有各自优缺点，解释执行的启动速度快，但是执行时的速度慢，而编译执行的启动速度慢，但是执行时的速度快。

## 编译器的工作流程

源代码	`->`	词法分析、语法分析	`->`	AST	`->`	语义分析	`->`	中间代码	`->`	代码优化	`->`	机器码	`->`	执行

## 解释器工作流程

源代码	`->`	词法、语法分析	`->`	AST	`->`	语义分析	`->`	字节码	`->`	执行

## V8 工作流程

&emsp;&emsp;首先将 JS **源码**通过解析器解析成**抽象语法树 AST**。

<img src="https://gitee.com/ylea/imagehost/raw/master/img/image-20200802170037793.png" alt="image-20200802170037793" style="zoom:80%;" />

&emsp;&emsp;接着再通过解释器将 **AST** 编译成**字节码** bytecode

&emsp;&emsp;字节码是跨平台的一种中间表示，不同于最终的机器代码，字节码与平台无关，能够在不同操作系统上运行：

<img src="https://gitee.com/ylea/imagehost/raw/master/img/image-20200802170115022.png" alt="image-20200802170115022" style="zoom:80%;" />

&emsp;&emsp;字节码最后通过编译器生成机器代码：

<img src="https://gitee.com/ylea/imagehost/raw/master/img/image-20200802170225783.png" alt="image-20200802170225783" style="zoom:80%;" />

### 基础准备

&emsp;&emsp;V8 在启动执行 JS 之前，还需要准备一些执行 JS 需要的基础环境，包括 **堆空间**，**栈空间**，**全局执行上下文**，**全局作用域**，**消息循环系统**，**内置函数** 等。

## 执行步骤

&emsp;&emsp;基础环境准备好之后，接下来就能使用 V8 执行启动 JS 了：

1. 首先使用解析器将 JS 源码解析成抽象语法树（AST），它是一种便于 V8 理解的结构，在生成 AST 的同时，V8 还会生成相关的作用域，作用域中存放相关变量。
2. 接着，通过解释器将 AST 编译成字节码 bytecode，解释器可以直接执行字节码，或通过编译器将其编译为二进制代码再执行
3. 解释器按照顺序解释执行字节码，并输出执行结果
4. 在解释器执行过程中，若某段代码被重复多次执行，那么这段代码会被标记为热点代码
5. 对于热点代码，V8 会将这段字节码交给编译器去将其编译为二进制代码，并执行优化操作，优化后的二进制代码执行效率会大幅提升。若下面再次执行到这段代码时，V8 会优先选择执行优化后的二进制代码。
6. 不过，由于 JS 是一种动态类型语言，因此在执行过程中某个对象的结构和属性是可以被修改的，而经过编译器优化后的代码是只针对某种固定的结构，因此编译器需要再次执行优化操作。



## 小结

&emsp;&emsp;V8 执行一段 JS 代码的大致流程：

1. 初始化基础环境
2. 解析源码生成 AST 和作用域
3. 根据 AST 和作用域生成字节码
4. 解释执行字节码
5. 监听热点代码
6. 使用编译器优化编译热点代码成二进制代码



# V8 垃圾回收

https://juejin.cn/post/6844904016325902344

## V8 引擎的内存限制

默认情况下，V8 在 64 位系统下最多只能使用 1.4GB 的内存，而在 32 位系统下最多只能使用约 0.7GB 的内存。这样的限制主要有两个原因：

- **JS单线程机制**：因为 JS 是单线程的，因此在进行垃圾回收时，需要暂停程序中其他逻辑的执行，直到垃圾回收结束之后再次进行，因此为了减少对 JS 运行效率的影响，内存会有一个限制。**即，JS的单线程机制，垃圾回收的过程阻碍了主线程逻辑的执行**
- **垃圾回收机制**：垃圾回收过程本身也是一件很耗时的操作，在垃圾回收的过程中，浏览器一直处于等待状态，因此若内存使用过高，必然会导致垃圾回收过程缓慢，进而影响程序性能。



不过，V8 也提供了 API 接口能让我们手动调整内存大小，不过需要在 node 初始化的时候进行。

使用 `node --v8-options` 可以看到关于 V8 的配置选项，几个比较关键的选项为：

```js
// 设置新生代内存中单个半空间的内存最小值，单位MB
node --min-semi-space-size=1024 xxx.js

// 设置新生代内存中单个半空间的内存最大值，单位MB
node --max-semi-space-size=1024 xxx.js

// 设置老生代内存最大值，单位MB
node --max-old-space-size=2048 xxx.js
```

同时，可以使用 node 命令：`process.memoryUsage()` 来手动查看当前 node 进程所占用的实际内存大小。



## 垃圾回收策略

V8 中的垃圾回收机制主要是 **分代式垃圾回收**，根据对象的**存活时间**将内存中的垃圾进行分代管理，并对不同的分代采用不同的垃圾回收算法。



### V8 内存结构

在 V8 中，除了 **新生代** 和 **老生代**，还存在一些内存分区，不过垃圾回收的过程主要出现在 新生代 和 老生代 中。

- **新生代（new_space）**：大多数的对象初始时都会被分配到这里，这个区域较小但是垃圾回收的比较频繁；整个区域被分为两半，一半原来分配内存，另一半用来在垃圾回收时将需要保留的对象复制过来。
- **老生代（old_space）**：新生代中的对象在内存中存活过一段时间后就会被转移到老生代中，老生代相对于新生代垃圾回收频率较低。老生代又分为两部分：**老生代指针区** 和 **老生代数据区**，前者包含了大多数可能会存在指向其他对象的指针的对象，后者只保存了原始数据对象，这些对象没有指向其他对象的指针。
- **大对象区（large_object_space）**：存放体积超越其他区域大小的对象，每个对象都会有自己的内存，垃圾回收不会移动大对象区。
- **代码区（code_space）**：代码对象会被分配到这里，这是唯一有执行权力的内存区域。
- **map区（map_space）**：存放 Cell 和 Map，这个区域都是存放相同大小的元素，结构简单。

<img src="https://gitee.com/ylea/imagehost/raw/master/img/V8%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4.jpg" alt="V8内存空间" style="zoom: 67%;" />



上图的新生代中，未激活的区域称为 `To` 空间，已激活的区域称为 `From` 空间。



### 对象晋升

当一个对象再进行多次复制（新生代中其中一个分区原来复制需要保留的对象）之后依然存活，那么就认为它是一个生命周期较长的对象，在下一次垃圾回收时，会将它转移到老生代中。这种将对象从新生代转移到老生代的过程我们称之为**晋升**。

对象晋升的条件主要有以下两个：

- 对象是否经历过一次 `Scavenge` 算法
- `To` 的空间内存占比是否已经超过 `25%`





### 老生代

老生代中使用**标记清除（Mark-Sweep）**和**标记整理（Mark-Compact）**算法进行内存回收。















































































