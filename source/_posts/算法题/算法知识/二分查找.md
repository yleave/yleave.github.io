---
title: 二分查找
index_img: https://cdn.jsdelivr.net/gh/yleave/imagehost/index_img/38.png
banner_img: https://cdn.jsdelivr.net/gh/yleave/imagehost/banner_img/52.jpg
date: 2020-10-18 15:34:25
categories:
    - 算法题
    - 算法知识
tags:
    - 查找
---

&emsp;&emsp;所谓二分查找，就是从一个查找范围中每次取中间值，然后根据中间值来判断是否满足条件或是缩小查找范围的过程，且这个范围内的值需要是有规律的，比如是有序的。

# 引子

&emsp;&emsp;以 [LeetCode](https://leetcode-cn.com/problems/search-insert-position/) 的一道简单题为例：给定一个排序数组和一个目标值，返回目标值的索引，若不存在，则返回能够插入该目标值的索引。

&emsp;&emsp;如 ：`array = [1,5,7,10,12], target = 6`

&emsp;&emsp;则返回值为 `2`

&emsp;&emsp;这题就是经典的使用二分查找的场景，最开始的查找范围是 `[0, 4]`，中间值 `array[2] = 7`，根据这个中间值，我们知道 `6` 是小于中间值的，因此能够缩小查找范围，即 `[0, 1]`，继续判断中间值 `array[0] = 1`，缩小查找范围 `[1, 1]`，最后发现查找范围内只剩下一个值 `5`，且小于目标值 `6` ，因此最后就能知道需要插入的索引是 `2`。

代码如下：

```c
int binarySearch(int r[],int left,int right,int x){
    int mid;
    while(left <= right){
        mid = (left + right) / 2;
        if(r[mid] == x){
            return mid;
        }else if(r[mid] > x){
            right = mid - 1;
        }else{
            left = mid + 1;
        }
    }
    return left;
}
```

&emsp;&emsp;其中， `(left + right) / 2` 有必要的话可以替换成 `left + (right - left) / 2`，以避免 `left + right` 超出整型范围的情况。



# 二分查找变形

&emsp;&emsp;根据使用场景的不同，二分查找有一些变形算法。

## 返回第一个大于等于 x 的位置

&emsp;&emsp;在下面代码中，循环结束时，`left` 是会刚好等于 `right` 的，`right` 总是会在大于等于 `x` 的地方停下来，一直压缩区间，`left` 最后的位置会是恰好大于等于 `x` 的位置。

&emsp;&emsp;所以说，下面的代码作用和上面例子中的代码是完全一样的。

```js
function lowerBound(arr, tar) {
    let left = 0, right = arr.length - 1;
    while (left < right) {
        let mid = Math.floor((left + right) / 2);
        let num = arr[mid];
        if (tar <= num) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return left;
}
```

&emsp;&emsp;如 `arr = [1, 3, 4, 6, 7]` ，`target = 5`，返回 `3`

## 返回第一个大于 x 的位置

&emsp;&emsp;这个函数与上面一个函数的变化只是将 `if` 判断中的 `<=` 改为 `<`。

```js
function lowerBound(arr, tar) {
    let left = 0, right = arr.length - 1;
    while (left < right) {
        let mid = Math.floor((left + right) / 2);
        let num = arr[mid];
        if (tar < num) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return left;
}
```

&emsp;&emsp;如 `arr = [1, 3, 4, 6, 7]` ，`target = 3`，返回 `3`

## 返回第一个小于等于 x 的位置

&emsp;&emsp;同理，在循环中稍加变动，就能实现另一个功能，不过这时候计算 `mid` 需要向上取整了（之前都是向上取整的），不然可能会出现无限循环，因为每次都向下取整的话可能会出现 `left` 不变的情况：

```js
function lowerBound(arr, tar) {
    let left = 0, right = arr.length - 1;
    while (left < right) {
        let mid = Math.ceil((left + right) / 2);
        let num = arr[mid];
        if (tar >= num) {
            left = mid;
        } else {
            right = mid - 1;
        }
    }
	return right;
}
```

&emsp;&emsp;同理，第一个**小于** `x` 的位置：

```js
while (left < right) {
    let mid = Math.ceil((left + right) / 2);
    let num = arr[mid];
    if (tar > num) {
        left = mid;
    } else {
        right = mid - 1;
    }
}
```


