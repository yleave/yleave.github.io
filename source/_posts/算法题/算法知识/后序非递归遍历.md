---
title: 后序非递归遍历
index_img: 'https://cdn.jsdelivr.net/gh/yleave/imagehost/index_img/40.png'
banner_img: 'https://cdn.jsdelivr.net/gh/yleave/imagehost/banner_img/44.png'
date: 2020-09-30 23:16:01
categories:
tags:
---


&emsp;&emsp;对树进行后序非递归遍历一般会借助栈来保存路径上的节点。



&emsp;&emsp;后序非递归遍历的一个**特点**就是：当访问到一个节点时，栈中所保存的节点正好是这个节点的所有祖先节点，因此后续非递归遍历可用来解决以下问题：

1. **当给定一个节点时，输出该节点的所有祖先**
2. **输出根结点到叶子节点的所有路径**
3. **求每条路径上的节点值之和**



&emsp;&emsp;后序非递归遍历的**关键点**在于判断遍历过程中什么时候该往右走，什么时候该访问节点内容。

&emsp;&emsp;我们使用一个栈来保存遍历路径上的节点，步骤如下：

1. 一直往左孩子遍历，遍历过程中保存遍历的节点
2. 当左孩子为空时，我们访问右孩子
3. 当左右孩子都为空时，我们访问这个节点内容，并返回到父节点
4. 每当从孩子节点返回父节点时，需要判断是从左孩子返回的还是从右孩子返回的，若是从左孩子返回的，我们需要继续访问右孩子，而若是从右孩子返回的，我们则访问当前节点，并返回到其父节点。

&emsp;&emsp;判断一次返回是否是从右孩子返回，我们可以使用一个变量 `t`，当一个节点返回时，我们使用 `t` 记录这个节点，在父节点处判断 `t` 是否与这个节点的右孩子相等，若相等，则说明是从右孩子返回的，否则就是从左孩子返回的。



**C 代码：**

```c
int* postorderTraversal(struct TreeNode* root, int* returnSize){
    int* res = malloc(sizeof(int) * 2001);
    struct TreeNode** stack = malloc(sizeof(struct TreeNode*) * 2001);
    int size = 0;
    *returnSize = 0;
    struct TreeNode* r; // r 为辅助节点，用于判断当节点返回时，是从哪个方向返回到父节点的。
    struct TreeNode* p = root;
    while (p != NULL || size > 0) {
        // 先从左走到底
        if (p) {
            stack[size++] = p;
            p = p->left;
        } else {
            p = stack[size-1];
            // 若右孩子还未遍历，遍历右孩子
            if (p->right && p->right != r) {
                p = p->right;
            } else {
                p = stack[--size];
                res[(*returnSize)++] = p->val;
                r = p;
                p = NULL;
            }
        }
    }

    return res;
}
```



## morris 算法遍历节点值

&emsp;&emsp;若需要使用非递归算法后序遍历节点值，那么可使用 morris 算法实现 `O(1)` 复杂度的遍历。

具体可看：[使用Morris算法进行后序非递归遍历](https://yleave.top/2020/09/30/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/#%E8%A7%A3%E6%B3%952%EF%BC%9Amorris-%E7%AE%97%E6%B3%95)