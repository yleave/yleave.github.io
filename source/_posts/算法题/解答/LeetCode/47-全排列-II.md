---
title: LeetCode 47. 全排列 II
index_img: https://cdn.jsdelivr.net/gh/yleave/imagehost/index_img/LeetCode.jpg
banner_img: https://cdn.jsdelivr.net/gh/yleave/imagehost/banner_img/5.jpg
date: 2020-09-19 01:23:02
categories:
    - 算法题
    - 解答
    - LeetCode
tags:
    - LeetCode
    - 回溯
---



https://leetcode-cn.com/problems/permutations-ii/

难度：中等

---

&emsp;&emsp;给定一个可**包含重复数字**的序列，返回所有不重复的全排列。

**示例:**

输入: `[1,1,2]`

输出:

```
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
```

## 解法1：回溯 + 剪枝

&emsp;&emsp;这题求全排列的步骤与 [46.全排列](https://yleave.top/2020/09/17/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/46-%E5%85%A8%E6%8E%92%E5%88%97/) 这题是一样的，区别就是 `46.` 这题给的数字序列是不含重复的数字，而本题则包含重复数字。

&emsp;&emsp;这样的话，我们只需要在原先的基础上对其进行剪枝即可，将造成重复组合的情况去除。

&emsp;&emsp;考虑一组序列：`[2, 2, 1, 1]`，标记一下以便区分：`[2, 2', 1, 1']`，对于这组序列，按照 `46.` 的思路，会造成重复的情况有在固定索引 `0` 处的值时，序列中的两个 `2` 和两个 `1` 都会造成固定值重复，即 `[2, 2', 1, 1']` 、`[2', 2, 1, 1']`，`[1, 2', 2, 1']` 和 `[1', 2', 1, 2]` ，这样，由于第一个固定的数字就重复，后面的所有组合也都是重复的。

&emsp;&emsp;因此，我们要做的就是**让每个索引处固定的值不再重复！**

&emsp;&emsp;要做到这样，我们可以借用一个 `map`，对于每个固定的索引，当一个值是第一次出现时，将其记录在 `map` 中，而若是遇到了 `map` 中已经存的值，则说明这个值已经固定过了，跳过它，这样就完成了全排列过程中的去重要求。



&emsp;&emsp;当然，还有一个很耿直的做法就是：还是像 `46.` 一样计算序列的组合，只在保存每个组合结果时，使用一个 `map` 记录当前组合是否保存过，若未保存过，则记录到结果数组中。。。



剪枝的 JS 代码：

```js
var permuteUnique = function(nums) {
    let res = [];
    let len = nums.length;

    const swap = (i, j) => {
        let tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    };

    const helper = index => {
        if (index === len) {
            res.push(nums.slice());
            return;
        }

        let map = [];
        for (let i = index; i < len; i++) {
            if (map[nums[i]]) {
                continue;
            }
            map[nums[i]] = 1;
            swap(index, i);
            helper(index+1);
            swap(index, i);
        }
    };

    helper(0);

    return res;
};
```

