---
title: NC45实现二叉树先序、中序和后序遍历
index_img: 'https://cdn.jsdelivr.net/gh/yleave/imagehost/index_img/NK.jpg'
banner_img: 'https://cdn.jsdelivr.net/gh/yleave/imagehost/banner_img/44.png'
date: 2020-10-30 12:56:19
categories:
    - 算法题
    - 解答
    - 牛客网
tags:
    - Morris
    - 前序遍历
    - 中序遍历
    - 后序遍历
---


[题目地址](https://www.nowcoder.com/practice/a9fec6c46a684ad5a3abd4e365a9d362?tpId=117&&tqId=35075&rp=1&ru=/ta/job-code-high&qru=/ta/job-code-high/question-ranking)

---

&emsp;&emsp;如标题，实现二叉树的三序遍历。

**例**

&emsp;&emsp;输入：`1, 2, 3`

&emsp;&emsp;输出：`[[1, 2, 3], [2, 1, 3], [2, 3, 1]]`

&emsp;&emsp;输出的数组就是`[前、中、后]` 序的遍历。



## 解法1：Morris 算法

&emsp;&emsp;递归和非递归的三序遍历都比较简单，迭代版本的递归可看下面几个链接：

[前序遍历](https://yleave.top/2020/10/27/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/#%E8%A7%A3%E6%B3%951%E8%BF%AD%E4%BB%A3)

[中序遍历](https://yleave.top/2020/09/24/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/501-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0/#%E8%A7%A3%E6%B3%951%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86)

[后序遍历](https://yleave.top/2020/09/30/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E7%AD%94/LeetCode/145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/#%E8%A7%A3%E6%B3%951%E5%80%9F%E5%8A%A9%E6%A0%88%E8%BF%9B%E8%A1%8C%E5%90%8E%E5%BA%8F%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86)

&emsp;&emsp;这里主要使用 `Morris` 算法进行三序遍历。

&emsp;&emsp;[Morris 算法](https://yleave.top/2020/09/24/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/Morris%E7%AE%97%E6%B3%95/)是一种迭代版本的遍历，使用了树中空闲的指针，因此不需要使用额外空间（`O(1)`），且 **`Morris` 算法能在一次遍历中同时完成三序遍历，三序的区别只是访问节点内容的时机不同。**

&emsp;&emsp;三序遍历各自的 `Morris` 算法实现也在上面的链接中，下面的代码是整合版本。

**JS 代码如下：**

```js
function threeOrders( root ) {
    let preOrder = [], inOrder = [], postOrder = [];
    let len = 0;
    let r = root;
    
    const addPath = node => {
        let count = 0;
        while (node) {
            postOrder[len++] = node.val;
            count++;
            node = node.right;
        }
        
        for (let i = len-count, j = len-1; i < j; i++, j--) {
            let temp = postOrder[i];
            postOrder[i] = postOrder[j];
            postOrder[j] = temp;
        }
    };
    
    while (root) {
        if (root.left) {
            let pre = root.left;
            while (pre.right && pre.right !== root) {
                pre = pre.right;
            }

            if (pre.right) {
                // 1
                pre.right = null;
                addPath(root.left);
            } else {
                preOrder.push(root.val);
                pre.right = root;
                root = root.left;
                continue;
            }
        } else {
            preOrder.push(root.val);
        }
        // 此时可能是借助最右下节点返回父节点的过程，也可能是普通的向右子树遍历
        // 还有可能是刚遍历完左子树，需要往右子树遍历，也就是从上面的 1 处执行下来的
        inOrder.push(root.val);
        root = root.right;
    }
    
    addPath(r);
    
    return [preOrder, inOrder, postOrder];
}
```

